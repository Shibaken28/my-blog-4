[{"content":"これはなに ","date":"2024-01-15T12:08:30+09:00","permalink":"https://shibaken28.github.io/my-blog-4/contents/kosen-math-diff/","title":"高専数学と高校数学の違い"},{"content":"これは何 強化学習の手法のうちの一つであるDeep Q-Network (DQN)で、ぷよぷよを学習させるという記事です。本記事はガッツリぷよぷよAIについて研究したとかではなく、こんなことやってみました程度のものです。私自身、強化学習について最近興味を持った素人で、「強化学習ってどのくらいできるもんなのか」という動機でやりました。\n結果として、サルより強いAIが完成しました\nまた、本記事は長野高専アドベントカレンダーの2日目の記事です。\nDQNとは Deep Q-Network(DQN)をいきなり説明するのは無理なので、次の順で説明します。\n用語 Q学習 ニューラルネットワーク 用語 強化学習特有の用語をいくつか説明します。\n用語 説明 ぷよぷよでの例 エージェント 学習する本人のこと ぷよぷよを操作する人 状態 エージェントに与える状況 盤面の状態 行動 エージェントが取れる行動 ぷよを置く場所と向き 報酬 エージェントが行動を取ったときに与えられる値 ぷよを消した数など エージェントは、報酬の総和(正確には、総和ではないこともある)を最大化するように行動を選択します。ですので、学習の目的によって報酬の付け方が変わります。\n報酬は、各行動を一回行うごとに与えられます。つまり、次のサイクルで学習が行われます。\nエージェントが状態を観測する エージェントが行動を選択する エージェントが行動を実行し、状態が遷移する エージェントが報酬を受け取る 1に戻る また、報酬は負の値にすることも可能です。例えば、ゲームオーバーになってしまった場合には報酬$-1$を与える、ということもできます。\nQ学習 定義 $Q$学習は$Q$関数を用います。$Q$関数は次のように定義されます。\n$$ Q(s,a) = (状態sで行動aを取ったときの評価値) $$\nシンプルな定義です。「評価値」は大きければ大きいほど、その先で得られる報酬が大きいということを表します。\nもし、完全な$Q$関数が完成していたとしましょう。このときは、次の手順で最適な行動ができます。\n現在の状態$s$で行える全ての行動$a_1,a_2,\\dots,a_n$について、$Q(s,a_i)$を計算する $Q(s,a_i)$が最大となる行動$a_i$を選択する Q関数の作り方 ランダムに行動して、その結果得られた報酬を$Q$関数に反映させることで、$Q$関数の各値を求めます。\nある状態$s$で行動$a$を取ったときに、状態$s^\\prime$に遷移し、報酬$r$を得たとします。このとき、$Q$関数の値を次のように更新します。\n$$ Q(s,a) \\leftarrow Q(s,a) + \\alpha(r + \\gamma \\max_{a^\\prime}Q(s^\\prime,a^\\prime) - Q(s,a)) $$\nここで、$\\alpha$は学習率、$\\gamma$は割引率と呼ばれる値です(ただし$0\\leq \\alpha,\\gamma \\leq 1$)。\nこの式は実はそんなに難しいことは言っていないのですが、説明するのが面倒なので省略します。\n理屈はさておき、この更新式を使って、ランダムに動くことを繰り返して$Q$関数を求めることはできます。しかし、状態$s$の場合の数が非常に大きいな場合、$Q$関数を求めるのに時間がかかってしまいます。例えば、ぷよぷよの盤面の場合、縦$12$横$6$の計$72$マスがあり、各マスは$4$色のぷよか、空白のいずれかであるため、$5^{72}$通りの状態があります1。これは約$10^{50}$通りであり、現時点で世界に存在するコンピューターで計算するのは不可能なオーダーです。\nそこで、ニューラルネットワークの出番です。\nニューラルネットワーク 簡単に説明すると関数を予測する構造を持ちます。例えるならば、グラフに点をプロットしていくと、その点を通るような関数を予測してくれます。ニューラルネットワークの中では、偏微分やら何やらを使って(誤差逆伝播法やBackPropagationで調べると出てきます)、誤差が小さくなるようにパラメータが調節されます。\nニューラルネットワークのイメージ ちなみにこの図ですが、卒研の中間発表の際に使ったものを持ったきたものです。中間発表は良い思い出ではないので、あまりこの図を見たくありません。\nこれを使うことで、全パターンの状態を試さなくても、$Q$関数の値を予測してくれるんじゃないか、というのがDeep Q-Network(DQN)のアイデアです。\nぷよぷよの実装 ぷよぷよを学習させるためにはぷよぷよのシステムを作らなければなりません。作りました。\nDQNにおいて必要なのは「行動を与えたときに、次の状態と報酬を返すメソッド」です。これさえあればDQNに突っ込めば学習ができます。OpenAIGymに倣って、そのゲームの「環境」クラスをインスタンス化して使えるようにします。\n以下は主要部分だけ抜粋したものです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def step(self, action): reward = 0 done = False win = False self.prev_action = action puyo = self.puyo_list[self.turn] self.turn += 1 isDropped = self.drop_puyo(action, puyo) if not isDropped: # 落とせなかったら負け done = True reward = -1 else: _dis , _chain = self.process() if self.turn \u0026gt;= self.turn_max: # 全ターン経過で勝ち done = True win = True reward = 1 # print(self.board) return self.states(), reward, done, self.info(), win step()が「行動を与えたときに次の状態と報酬を返す」メソッドです。\n学習方法 『ゼロから作るDeep Learning ❹ 強化学習編』(オライリー・ジャパン)のサポートサイトのコードをベースに書きました。機械学習ライブラリのPyTorchを使っています。\n状態 状態としてエージェントに与えたい要素は次の通りです。\n盤面の状態 次に落とすぷよ$3$つ これをもとに状態を返すメソッドを書きます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def states(self): # 現在の盤面の状態 state = [] for row in range(self.height): for col in range(self.width): state.append(self.board[row][col]) # 次の3ターンで降るぷよの色 for i in range(3): state.append(self.puyo_list[self.turn+i][0]) state.append(self.puyo_list[self.turn+i][1]) # print(state) assert len(state) == STATE_SPACE # dtypeをfloat32に変換 state = torch.tensor(state, dtype=torch.float32) return state これらをすべて1次元ベクトルとして入力にします。$2$次元の盤面をどう$1$次元に変換させるのかというと、単純に各行を横につなげただけです。\nepsilon-greedy法 epsilon-greedy法は学習テクニックの一つで、学習初期にはランダムに行動を選択し、学習が進むにつれてランダムに行動を選択する確率を下げていく方法です。これを使うことで、学習初期にはランダムに行動を選択することで、より多くの状態を試し、偏りなく学習させることが期待されます。\n学習 ソースコードはGistに置いてあります。\n実験A 生き残れるか 条件 次の条件で学習させます。\n盤面の大きさは縦$8$横$6$の計$48$マス\n$30$回ぷよを落とすことができればゲームクリア\n少なくとも、$30\\times 2=60$個のうち$60-48=12$個は消さなければならない ゲームクリアの場合報酬$1$、ゲームオーバーの場合報酬$-1$を与える\n結果 $2000$回の試行を行ったところ、最終的には$4$から$6$割程度の成功率となりました。 実験Aの直近100回の成功率 なお、$1000$回らへんで急激に成功率が上がっているのは、epsilon-greedy法の影響です。学習初期にはランダムに行動を選択する確率が高いため、成功率が極端に低くなっています。\n学習の効果が出ているのかを確かめるため、試しに全てランダムに行動させてみました。すると、成功率は$1$割にも満たない結果となりました。 よって、精度はともかく、少なくとも学習はできていると言えます。サルより強い。 実験Aの直近100回の成功率(ランダム) 実験B 2連鎖以上を起こせるか 条件 次の条件で学習させます。\n盤面の大きさは縦$8$横$6$の計$48$マス $2$連鎖以上を起こした時点でゲームクリア ただし、$30$回ぷよを落とした時点で$2$連鎖以上が起こっていなかった場合ゲームオーバー ゲームクリアの場合報酬$1$、ゲームオーバーの場合報酬$-1$を与える 結果 成功率は案外伸びずに2割程度でした。 実験Bの直近100回の成功率 一応ランダムの場合は成功率が1割未満なため、学習自体はできているようです。 実験Bの直近100回の成功率(ランダム) 実験C ばよえ～～ん 条件 次の条件で学習させます。\n盤面の大きさは縦$12$横$6$の計$96$マス $7$連鎖を起こした時点でゲームクリア ただし、$100$回ぷよを落とした時点で$7$連鎖以上が起こっていなかった場合ゲームオーバー 報酬は、起こした連鎖数の$2$乗 これにより、「$1$連鎖$2$回」よりも「$2$連鎖$1$回」の方が良く評価される 要するにばよえ～んを唱えられればクリアです\n結果 $5000$回の試行のうち、$11$回成功しました。成功率は非常に低いです。\n$1600$回目の試行で$7$連鎖を起こすことができました。\n別のパターン($2593$回目)。※ゲームオーバーの判定は原作と少し違い、「盤面の1番上の行にぷよが既に存在していて、さらにその上に置こうとするとゲームオーバー」となっています。\n$4905$回目の試行。こちらは$8$連鎖起こっていますし、残ったぷよの数が少なめです。\n報酬の総和の平均は次のようになりました。 実験Bの直近100回の報酬の総和の平均 考察 成功率がそこまで高くならないものの、ランダムの場合よりは良い結果が得られているのは確かではあります。ただ、ぷよぷよというゲームの性質上、次のような行動をすれば案外連鎖を起こせてしまいます。\n盤面から溢れない程度にぷよを積んでおく 盤面がほとんどぷよでいっぱいで、ゲームオーバーになりそうな場合は適当なぷよを消す すると、それなりに連鎖が起こる場合がある いわゆる「カエル積み」です。強化学習によって、「盤面から溢れない程度に置く」「満杯になったら適当に消す」ことが良いと認識され、「カエル積み」が生まれているのではないか、という考えです。\n実験Cではカエル積みが何度も試行され、試行回数を大量に重ねた結果、$7$連鎖を起こすことができたと考えます。\n感想と謝罪文と言い訳 遅れてしまいました。ごめんなさい！！！！\n元々この記事はZennに投稿する予定だったのですが、学習の結果があんまりぱっとしなかったことや、強化学習への理解が足りないことなどの理由から、記事のクオリティが低くなりそうだったので、個人ブログに投げることにしました。個人ブログは何をやっても許されるので便利ですね。\n感想ですが、機械学習は難しいですね。私が普段触れている競プロやアルゴリズムは、厳密さや再現性が重要視される分野であることに対し、機械学習は「ニューラルネットワークを使うとなんかうまくいく」とか、「パラメータを調節すると学習率が上がる」みたいな、どこかふんわりとした印象があります。手元で調整したパラメータが、直接結果に現れるのではなく、「ニューラルネットワーク」という得体の知れないものを通して出てくる、謎の仲介者がいる、直接やり取りしたいのに、という気持ちになります。そこがかなりとっつきづく、私はまだまだ機械学習について理解が足りないと感じました。\n空白の上にぷよが置かれる場合が含まれてしまっているため、正確にはもうちょっと少ないですが、大きい数であることには間違いないです。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-12-02T12:08:30+09:00","permalink":"https://shibaken28.github.io/my-blog-4/contents/puyo-dqn/","title":"強化学習でぷよぷよを学習させたかった(願望)"},{"content":"全般 問題数が多くて雑になりました。ごめ\nわからない場合は直接私に訊いてください。DiscordやTwitterでDMを送ってください。\n約束 配布ファイルにある大きな数字や配列などは省略して示しています。 \u0026gt;\u0026gt;\u0026gt;で始まっている行はPythonのインタラクティブモードでの入力を表しています。 特に断りがない場合、全ての解答コードはPython3で書かれています。 RSAの問題で出てくる、$m,e,c$はそれぞれ平文、公開鍵、暗号文を表します。 ライブラリ 次のPythonライブラリを使います。\npycryptodome gmpy2 これらのライブラリは、pip install pycryptodome gmpy2でインストールできます。\n便利ツール CyberChef データ変換に便利なサイトです。データ形式が充実しています。 Substitution Solver 換字式暗号を自動で解いてくれます。 Beginner 序盤の簡単な問題\nwelcome README.mdに書いてあります。sctf{welcome_to_shiba_ctf}\nradix starter 1 こういうちょっとした計算はPythonのインタラクティブモードが便利です。\n1 2 \u0026gt;\u0026gt;\u0026gt; bin(18) \u0026#39;0b10010 sctf{10010}\nradix starter 2 sctf{11010100001011}\nradix starter 3 1 2 \u0026gt;\u0026gt;\u0026gt; int(\u0026#34;10111\u0026#34;,2) 23 sctf{23}\nradix starter 4 sctf{52394}\nradix starter 5 1 2 \u0026gt;\u0026gt;\u0026gt; int(\u0026#34;3b\u0026#34;,16) 59 sctf{59}\nradix starter 6 1 2 \u0026gt;\u0026gt;\u0026gt; hex(97) \u0026#39;0x61\u0026#39; sctf{61}\nradix starter 7 1 2 \u0026gt;\u0026gt;\u0026gt; int(\u0026#34;8128\u0026#34;,9) 5939 sctf{5939}\nradix starter 8 $1$の後ろに$0$が$a$個続く$2$進数は、$10$進数で$2^a$です。よって、$2^64$が答えです。sctf{18446744073709551616}\nradix starter 9 Classic Cipher だいたいの古典暗号は、ネットにソルバが転がっています。 古典暗号は、現代から見れば脆弱で、アソビのようにも感じますが、歴史的背景はかなり興味深いです。計算機を使わないからこその、アルゴリズムの創意工夫も見られて面白いです。\nRomantic シーザー暗号です。$14$文字後ろにずらします。sctf{kimagur3_r0m4ntic}\nSOS シンプルなモールス符号です。sctf{LICENSE}\nNo meaning 換字式暗号です。\n1 classic ciphers are encryption methods that have been used for centuries to secure secret messages. these ciphers are based on mathematical algorithms, transforming plaintext into unreadable ciphertext, readable only by those with the decryption key. examples of classic ciphers include the caesar cipher, which replaces each letter in the plaintext with a fixed number of positions down the alphabet; the vigenere cipher, which uses multiple caesar ciphers based on a keyword; the playfair cipher, which encrypts pairs of letters using a 5x5 grid; the rail fence cipher, which rearranges plaintext letters; and the enigma machine, which was famously cracked by allied codebreakers during world war ii. by the way, here is flag: sctf{plaintext_letters_substituted_with_different_ciphertext_letters} Zigzag レールフェンス暗号(Rail Fence Cipher)です。 `sctf{r@1l_f3nc3_c1ph3r_15_@_53cur3_4nd_345y_70_und3r574nd} 以下のようにジグザグに文字を配置して1行ずつ読む、という暗号化です。\n1 2 3 4 5 s l c c 1 _ _ t @ f 3 f r 3 c { n Cylinder スキュタレー暗号です。$n$文字飛ばしで読むと文が出てきます。 改行して縦読みすると簡単に解けます。\n1 2 3 4 s{__05p cy440t3 t0r_d3r fu3g_p} sctf{y0u_4r3_4_g00d_5t3pp3r}\nSquare 画像の出典でバレていますがヴィジュネル暗号(Vigenère cipher)です。シーザー暗号の改良版で、文字ごとにずらす数を変えます。この問題はKEYが分かっているので、デコードするだけです。 sctf{supercalifragilisticexpialidocious}\nAtCipher アトバシュ暗号(Atbash cipher)です。aをz、bをy、cをx、というようにアルファベットを変換します。この暗号はエンコードとデコードで行う操作が同じです。 sctf{just_like_affine_cipher}\nDigital Crypto 現代暗号に分類するまでもない、エンコード形式などに関する問題です。\nNumbers 文字コード(ASCII)です。sctf{Numbers_are_a_common_language}\nlong_to_bytes 問題文の通りです。 sctf{pycryptodome_is_one_of_the_most_important_library}\nCompression base64です。sctf{base64_enc0ded_s7ring_15_being_one}\nCompression 2 base32です。sctf{B@s3_33_15_@v3ry_5ecure_3nc0d1ng_f0r_m@nypurp053s_bu7_1t_m@y_n07_b3_7h3_f@s73s7_0n3_f0r@ll_54tu@710n5}\nKanji めっちゃ大規模なシーザー暗号です。1文字目をsと仮定したときにずらす数が決定するので、それを使ってデコードします。\n1 2 3 4 5 6 S = \u0026#34;籼籬籽籯粄籛簹籽籉籽簺簹籷籨簺簾籨簾簺籶籹籵簼籨簯簼籯籯簼籬籀簺籿簼粆\u0026#34; k = ord(S[0])-ord(\u0026#39;s\u0026#39;) for c in S: print(chr(ord(c)-k),end = \u0026#34;\u0026#34;) print(\u0026#34;\u0026#34;) sctf{R0t@t10n_15_51mpl3_\u0026amp;3ff3c71v3}\nNumbers 2 8進数で表された文字コードです。数字に$8$以上が出現しないところに注目です。sctf{0c74l_numb3r5_@r3_7h3_b3s7_w@y_70_3nc0d3_d@73}\nEmoji cipher 「Kanji」と全く同じ解き方ができます。sctf{3m0j1_com3_fr0m_j4pan}\nhttp URLエンコードです。sctf{日本語でもok}\nSanity Check 日本人には読めないフォントElectroharmonixで書かれた文章です。注意深く見るとアルファベットが見えてきます。どうしても読めなければこのフォントのアルファベット表と比較しましょう。SCTF{YOU_ARE_NOT_JAPANESE_LOL}\nNumbers 3 15進数です。fが存在しないところに注目です。\n1 2 3 \u0026gt;\u0026gt;\u0026gt; x = int(\u0026#34;495c11db788574a62d038c125c688b9976c81c75370b9de35d1ac9da9a95b39591ea51cc3acd660b1804a44a743a443490826847dc9947d0c7067ed9dd7\u0026#34;,15) \u0026gt;\u0026gt;\u0026gt; from Crypto.Util.number import long_to_bytes \u0026gt;\u0026gt;\u0026gt; long_to_bytes(x) sctf{7h3_r4d1x_15_1mp0rtant_and_1m_5orry_ab0u7_7h15_pr0blem} 酷い問題ですね(私は好きです)\nGlitch 文字コードをうまい感じに扱うと解読できます\n1 2 3 4 5 6 7 8 9 S = open(\u0026#34;glitch.txt\u0026#34;,\u0026#34;r\u0026#34;).read().encode(\u0026#34;unicode_escape\u0026#34;) T = S.decode(\u0026#34;utf-8\u0026#34;) i = 0 while i \u0026lt; len(T): if T[i] == \u0026#34;\\\\\u0026#34;: i += 6 else: print(T[i],end=\u0026#34;\u0026#34;) i += 1 Unicode can be used to represent a wide variety of characters. One of them is the combining character system. Here is an example of a long flag: sctf{V0yag1ng_Thr0ugh_Th3_Unchart3d_Gl1tch3s_0f_Th3_C0sm0s_1n_Pursu1t_0f_H1dd3n_R3v3lat10ns_and_Unv34l1ng_th3_Myst3r13s_of_Th3_Unkn0wn_Un1v3rs3}\nzzzzzzzzzzzzzz 手抜き問題。暗号化スプリクトは以下の通りです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from random import shuffle S = \u0026#34;sctf{h1d3_4nd_533k_j0yfu1_3xpl0r4t10n}\u0026#34; T = \u0026#34;567f[HiDe-4nD-sEeK-JoyFUl-eXP1oRa7ioN]\u0026#34; C = \u0026#34;\u0026#34; for i in range(len(S)): F = [] for j in range(18): F.append(S[i]) for j in range(17): F.append(T[i]) shuffle(F) C += \u0026#34;\u0026#34;.join(F) print(C) Ultimate Caesar 線形変換を複数合成したその結果も線形変換です。例えば、$f(x) = 2x+5$と$g(x) = 3x+7$を合成すると、$g(f(x)) = g(2x+5) = 3(2x+5)+7 = 6x+22$となり、線形変換のままです。 さらに、この問題は$\\pmod 65537$で計算しているので、線形変換$ax+b$の$a,b$はどちらも$0$以上$65536$以下の整数です。$a$を全探索し、1文字目がsとなるような$b$を計算すれば、全通りの線形変換を試せます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 c = [47799, 18389, 14535, 725, 21466, 1781, 25216, 25632, 37871, 52855, 39626, 43890, 63798, 13679, 28100, 62877, 55237, 3163, 35047, 42930, 18652, 36817, 49095, 15836, 31228, 36576, 11850, 37110, 38663, 19959, 38874, 51360, 15748, 12843, 57056, 9250, 32197, 37439] l = 65537 for a in range(0,l): d = 0 b = (c[0] - ord(\u0026#34;s\u0026#34;))%l m = \u0026#34;\u0026#34; for p in c: d = (a*d + b)%l m += chr((p-d)%l) if m.startswith(\u0026#34;sctf{\u0026#34;) and m.endswith(\u0026#34;}\u0026#34;): print(m) print(a,b) break この問題を解くのにparamsは必要ありません。 sctf{c0mp13x1ty_4nd_5urf1ng_7h3_w4v3s}\nBasic Math 数学(主に数論)に関する基本的な問題です。\nEquation 1 割り算するだけです。\n1 2 \u0026gt;\u0026gt;\u0026gt; 162030664//3158 51308 Equation 2 二分探索で求めます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # x^2 x2 = 3386439659231533906596 # xを2分探索で探す l = 0 r = x2 while r - l \u0026gt; 1: m = (l + r) // 2 if m * m \u0026gt; x2: r = m else: l = m print(l) Pythonの標準である関数は誤差が出ることがあるため使わない方が良いです。\nEquation 3 同じく二分探索で求めます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from Crypto.Util.number import * x16 = # # xを2分探索で探す l = 0 r = x16 while r - l \u0026gt; 1: m = (l + r) // 2 if m**16 \u0026gt; x16: r = m else: l = m print(long_to_bytes(l)) # sctf{r00t_of_unity} Equation 4 関数が単調増加であれば二分探索が使えます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from Crypto.Util.number import * def f(x): return x**8 + x**4 + x**2 fx = # # xを2分探索で探す l = 0 r = fx while r - l \u0026gt; 1: m = (l + r) // 2 if f(m) \u0026gt; fx: r = m else: l = m print(long_to_bytes(l)) # sctf{1ncr34s3_y0ur_5k1ll5} Math Class 1 愚直に計算します。\n1 2 \u0026gt;\u0026gt;\u0026gt; sum([a for a in range(1,2023+1)]) 2047276 Math Class 2 等差数列の和の公式を使います。 $10^{12}\\times (10^{12}+1)/2 = 500000000000500000000000$\nMath Class 3 下$10$桁は$10^{10}$で割った余りを求めれば良いです。\n1 2 \u0026gt;\u0026gt;\u0026gt; pow(8128,123456789,10**10) 328442060 Math Class 4 $x$の最大でも$157$未満なので、全探索できます。\n1 2 3 4 5 6 7 a = 29 b = 1 m = 157 for x in range(1,m): if (a*x)%m == b: print(x) break sctf{65}\nMath Class 5 ユークリッドの互除法を使います。\n1 2 3 4 5 6 7 8 def GCD(a, b): if a == 0: return b return GCD(b % a, a) a = 14930888045225624011 b = 8204203643581470607 print(GCD(a, b)) sctf{3806516863}\nMath Class 6 拡張ユークリッドの互助法で逆元を求めます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def inverse(a, m): m0 = m y = 0 x = 1 if m == 1: return 0 while a \u0026gt; 1: q = a // m t = m m = a % m a = t t = y y = x - q * y x = t if x \u0026lt; 0: x = x + m0 return x a = 12345678 m = 998244353 print(inverse(a, m)) あるいは、今回はmodが素数なのでフェルマーの小定理を使っても解けます。\n1 2 3 a = 12345678 m = 998244353 print(pow(a,m-2,m)) sctf{749734780}\nMath Class 7 中国剰余定理を使います。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from Crypto.Util.number import long_to_bytes, bytes_to_long, inverse, getPrime def crt(a, m, b, n): # nx = 1 (mod m) # my = 1 (mod n) # anx + bmy は mでmで割ったあまりがa, nで割ったあまりがbになる x = inverse(n, m) #x = pow(n,-1,m) y = inverse(m, n) return (a * n * x + b * m * y) % (m * n) m = 591233 n = 950753 a = 23 b = 19 g = crt(a,m,b,n) print(g) sctf{549251909625}\nBlock Cipher ブロック暗号に関する問題です。\nAES starter 問題文の通りにやります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # AES from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad from Crypto.Util.number import long_to_bytes, bytes_to_long from Crypto.Random import get_random_bytes from Crypto.Util.strxor import strxor iv = 0xffffffffffffffffffffffffffffffff iv = long_to_bytes(iv) key = 0x01230123012301230123012301230123 key = long_to_bytes(key) enc = 0xf47fda4253994089ee89c8f0b76d3991d36c9085cb0ffaa06781fb56dd7fe9a4 enc = long_to_bytes(enc) dec = AES.new(key, AES.MODE_CBC, iv).decrypt print(unpad(dec(enc), 16)) sctf{iv_m34n5_f0ur}\nECB starter ECBモードは、16バイトごとに暗号化が独立しています。今回の暗号文は32バイトあるので、2ブロックに分けてそれぞれ復元すれば良いです。\nb6506e08641d53366fdbfa35e8549e24をdecryptすると736374667b4543425f69735f7430305f d7666bdf3cbad130ddeb8eb1d0c7b58aをdecryptすると7765616b7d0b0b0b0b0b0b0b0b0b0b0b これらを繋げて16進数デコードするとsctf{ECB_is_t00_weak} 他にも、暗号文を余分に伸ばして回避する方法もあります。\nOFB starter OFBモードは暗号化と復号がブロックごとで同じ操作です。 よって、次のようにして復号できます。\n適当なivを用意(例えば00000000000000000000000000000000)してdecryptして0e1e6412ca1533f9681c64b68dc8817e85c7508d4a3d6ee0570cf4b53adf723102 0e1e6412ca1533f9681c64b68dc8817e85c7508d4a3d6ee0570cf4b53adf723102をもう一度decryptすると736374667b57307264355f756e6c33347368316e675f637233347431763174797d7a3cd23dca7751c2491347e7e264fd76747220244d2c8b26d2373a583913096fcb デコードするとsctf{W0rd5_unl34sh1ng_cr34t1v1ty} CBC starter まず、暗号文を16バイトごとに分割します。\n1 2 3 958fd2d255b337bb0c3d8c95fbcbc56a 6793aad6cb36a4c9bbc6bfc1791ac3f0 dc5b1476371e1333927ebdbc9d2ab27f はじめの16バイトを与えられたivを使ってdecryptするとsctf{d1sc0v3r1ngが得られます。 次の16バイトは、ivを958fd2d255b337bb0c3d8c95fbcbc56aにすれば_CBC_m0d3_1n_cr1が得られます。 最後の16バイトは、ivを6793aad6cb36a4c9bbc6bfc1791ac3f0にすればpt0}が得られます。 よって、フラグはsctf{d1sc0v3r1ng_CBC_m0d3_1n_cr1pt0}です。\nPadding Escapade コードは次のように暗号化しています\nフラグの長さを$L$として、$i=1,2,\\dots,L$に対して、次を行う i文字目までを16バイトの倍数になるようにパディングし、enc配列に追加 フラグの先頭i文字目にランダムな8bitをxor encの順序をシャッフルして出力 そもそも、paddingという操作は「データを16の倍数バイトの長さに延長する」という操作ですが、unpaddingという操作によって、「16の倍数バイトのデータを元の状態に戻す」ことができます(paddingという操作によって、元の長さの情報は失われていないのです)。 ですから、unpaddingをすればその文字列の長さから何文字目の情報であるかがわかります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from Crypto.Util.Padding import unpad from Crypto.Util.number import long_to_bytes, bytes_to_long from random import getrandbits, sample enc = # 省略 ct = [] for e in enc: ct.append(long_to_bytes(e)) # unpad m = [0] * len(ct) for c in ct: x = unpad(c, 16) m[len(x)-1] = chr(x[-1]) print(\u0026#34;\u0026#34;.join(m)) sctf{Unpadd1ng_1s_un1que1y_def1n3d}\nFormat Detection CBCモードのdecryptの手順を見ると、最初の16バイトは最後にivをxorしていることがわかります。最後のxorをこちら側でやってしまえばよいです。次の手順で解きます。\n暗号文をivを00000000000000000000000000000000としてdecryptするとeafafcee0c030e554e6316135d5174335f316e5f7468335f736b377d04040404が得られる。 後半16バイトをデコードするとフラグの一部_1n_th3_sk7}が得られる。 前半16バイトをivの99998888777766661111222233334444とxorを取ることで、736374667b7468335f7234316e623077になり、デコードするとsctf{th3_r41nb0wが得られる。 よって、フラグはsctf{th3_r41nb0w_1n_th3_sk7}です。\nModern Crypto 現代暗号に関連する問題です。CTFのCrypto問題の多くは、このカテゴリに属します。\nXOR starter keyが暗号化スクリプトに直書きされています(多分普通にミス)ので、それを使って復号します。\n1 2 3 4 5 6 7 8 9 c = [66, 82, 69, 87, 74, 105, 126, 99, 110, 89, 80, 66, 110, 88, 95, 69, 2, 67, 2, 66, 69, 88, 95, 86, 110, 65, 67, 1, 65, 84, 67, 69, 88, 84, 66, 76] for key in range(256): flag = \u0026#34;\u0026#34; for i in c: flag += chr(i ^ key) if \u0026#34;sctf\u0026#34; in flag: print(flag) break sctf{XOR_has_int3r3sting_pr0perties}\nXOR Maze 式の上から順に$a,b,c,d$とすると、\n$c \\oplus d = C$ $b \\oplus (c \\oplus d) = b \\oplus C = A\\oplus B \\oplus C \\oplus D$ $a \\oplus (b \\oplus (c \\oplus d)) = a \\oplus A\\oplus B \\oplus C \\oplus D = x$ よって、$a\\oplus b\\oplus c\\oplus d$を計算すれば良いです。sctf{XOR-XOR-XOR}\nXOR XOR XOR 暗号化した結果をそのまま16進数デコードするとsctf{Par17y_15_an_imp0rt4n7_prop3rty}が得られます。つまり暗号化しているように見えて、何も変化していません。\nこれは、$0$から$2^32-1$を$2$進数にしたときに、各ビットで必ず偶数回1が出現していることによります。\nForesight? 1～4 Foresight? 4は他の問題を包含しているめ、それを解くコードだけ載せます。理論の説明は線形合同法のパラメータ推測を参照してください。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from Crypto.Util.number import * def linear_random_crack(rands): t = [rands[i+1]-rands[i] for i in range(len(rands)-1) ] s = [(t[i+2]*t[i]-t[i+1]*t[i+1]) for i in range(len(t)-2) ] m = 0 for a in s: m = GCD(m,a) a = ((t[2]-t[1]) * inverse(t[1]-t[0],m))%m b = (rands[1] - a*rands[0])%m return a,b,m x = [747295850, 164867235, 2576857841, 3363332730, 1094604011, 2843336746, 1656975446, 397591104, 3296405267, 3516873680] cipher = [44926602, 2937937393, 174436646, 2491180612, 315256230, 3211193071, 568689060, 93639370, 1909387862, 3075542788, 1540942839, 198180033, 727016228, 2502033293, 1802750036, 569086897, 375047049, 1629464891, 1407370985, 477707872, 774404513, 2716137718, 1840779688, 1191662382, 3504379912, 748125320, 1658575995, 928538355, 3070989414, 2468916650, 2782012797, 610961179, 3682269712, 2770385176, 2785363482, 1486741234, 2524249046, 1721210836, 3665494948, 2796298560, 431561753, 2330491191, 2141216717, 3524354070, 1129782399, 3057714851, 2038862641] a,b,m = linear_random_crack(x) print(a,b,m) flag = \u0026#34;\u0026#34; for c in cipher: flag += chr(c ^ (a*x[-1]+b)%m) x.append((a*x[-1]+b)%m) print(x) print(flag) これを使うと、各問題のフラグは\n1: sctf{1_0f_th3_w0r$t_rand0m_numb3r_g3n3r@tor5} 2: sctf{d0_n0t_u5e_l1near_c0n9ruent1al_gener@t0r5} 3: sctf{l1near_c0n9ruent1al_gener@t0r_is_n0t_5@fe} 4: sctf{b3_c4r3ful_w1th_l1n34r_c0ngru3nti4l_g3n3r4t0r} Foresight? Final 一つ飛ばしの場合、漸化式が$x_{n+2} = ax_{n+1} + b = a^2 x_n + ab + b$となります。新たに$A=a,B=ab+b$とおけば、$x_{n+2} = Ax_n + B$となり、これはForesight? 4と同じ問題になります。\n$A,B$、そしてmodの$m$が求まれば、あとは$A=a^2,B=ab+b$を解けば良いですが、ここで注意なのはこの方程式は$\\mod m$で解く必要があることです。$a$を$A$からもとめるには、modの世界で平方根を取る必要があります。\n今回は、$m=3 \\pmod 4$であるため、$A^{\\frac{m-3}{4}}$の逆元が$A$の平方根になります。 (そうでない場合はこの手順では求められませんが、別のアルゴリズムを用いることで求めることはできます。Cipolla\u0026rsquo;s algorithmや、Tonelli-Shanks algorithmなどがあります。)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from Crypto.Util.number import * from gmpy2 import iroot def mod_root(a,p): # x^2 = a mod pとなるようなxを返す assert p%4 == 3 k = (p-3)//4 x = inverse(pow(a, k, p),p) assert (x**2 % p) == a return x def linear_random_crack(rands): t = [rands[i+1]-rands[i] for i in range(len(rands)-1) ] s = [(t[i+2]*t[i]-t[i+1]*t[i+1]) for i in range(len(t)-2) ] m = 0 for a in s: m = GCD(m,a) a = ((t[2]-t[1]) * inverse(t[1]-t[0],m))%m b = (rands[1] - a*rands[0])%m return a,b,m x = [ cipher = [ A,B,m = linear_random_crack(x) a = mod_root(A,m) b = B*inverse(a+1,m)%m print(a,b,m) flag = \u0026#34;\u0026#34; for c in cipher: flag += chr(c ^ (a*x[-1]+b)%m) x.append((a*x[-1]+b)%m) print(flag) sctf{th3_s33r_0f_b3y0nd_c4n_p3rceiv3_th3_1nvis1bl3}\nModular Puzzle modはとりあえず無視します。この問題の趣旨は次のとおりです。\n$v=g(a^2+b^2+c^2)$を次の値から求める $s=gab$ $t=gbc$ $u=gca$ 次のように求めることができます。\n$ga^2 = st^{-1}u$ $gb^2 = stu^{-1}$ $gc^2 = s^{-1}tu$ よって、$v = g(s^{-1}tu + st^{-1}u + stu^{-1}) = stu(s^{-2}+t^{-2}+u^{-2})$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrime from random import getrandbits def GCD(a, b): while b: a, b = b, a % b return a p = s = t = u = ct = A = s * t * u % p gc2 = A * pow(s, -2, p) ga2 = A * pow(t, -2, p) gb2 = A * pow(u, -2, p) v = (ga2 + gb2 + gc2) % p m = pow(ct, pow(v, -1, p - 1), p) print(long_to_bytes(m)) # sctf{unv34lin9_th3_p0w3r_0f_m0dul4r_1nv3rs3s_1n_crypt0} ExpHash 長さ$1000$の配列が$4$つ与えられているので、全パターン試すと$10^{12}$通りになります。これは計算に時間がかかるので 高速な次のようなアルゴリズムを使います。求めたいパスワードのハッシュ値を$h$とします。\nlist1とlist2の全組み合わせのハッシュを計算してdict1に保存 list3とlist4の全組み合わせのハッシュを計算してdict2に保存 ここで、重要な次の性質を使います。\n長さ$N$の文字列$s$と文字列$t$のハッシュ値がそれぞれ$h_s,h_t$であるとすると、連結した文字列$s+t$のハッシュ値は$h_s + h_t \\times base^{N} $となる これにより、dict2の全ての要素$h_2$について次の問題を解きます。\n$h_1+base^N \\times h_2 = h$が成り立つ$h_1$を求める。 $h_1 = h - base^N \\times h_2$ $h_1$がdict1に存在するかを調べる 適切なデータ構造(プログラム上ではdictを使用)を使うことで上記の操作は$O(\\log 10^6)$で行うことができます。 よって、この問題は、$X=10^3$とすると、$O(X^2 \\log X^2)$で解くことができました。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 base = 48337 mod = 11135515903660432429 list1 = [\u0026#39;NveEp\u0026#39;, # 省略 list2 = [\u0026#39;6nBxk\u0026#39;, # 省略 list3 = [\u0026#39;fls3N\u0026#39;, # 省略 list4 = [\u0026#39;TLpkV\u0026#39;, # 省略 h = 10560284356650745449 def hash(s, base, mod): ret = 0 for i, c in enumerate(s): ret = (ret + ord(c) * pow(base, i, mod)) % mod return ret dict34 = {} for s3 in list3: for s4 in list4: a = (hash(s3 + s4, base, mod) * pow(base, 10, mod)) % mod dict34[a] = s3 + s4 for s1 in list1: for s2 in list2: l = (h - hash(s1 + s2, base, mod)) % mod if l in dict34: print(s1 + s2 + dict34[l]) print(hash(s1 + s2 + dict34[l], base, mod)) # sctf{xYDpuEYEeO8m5ZQxkmO5} Staircase 問題ファイルのverify関数を使おうとすると、実行に非常に時間がかかってしまうので、別の方法を考えます。\n問題ファイルのverify(a)関数では、a-1の階乗がaで割り切れるかどうかを判定しています。 この判定は、aが素数であるかどうかと同値です。なぜなら、\n$a$が素数ではない場合を考える $a=p_1^{e_1}p_2^{e_2}\\dots p_k^{e_k}$と素因数分解できるとする $s = \\lbrace p_1^{e_1}, p_2^{e_2}, \\dots, p_k^{e_k} \\rbrace $とすると、$s$の全要素の積は$a$である。 一方、$(a-1)!$は、$a$以下の全ての数の積であり、$s$の各要素は全て$a-1$以下であるため、$(a-1)!$は$s$の全要素の積で割り切れる。 という理由によります(簡単に言うと、$a$が合成数だったら$a$の約数が$1$から$a-1$の間に存在するよね、ということです)。\nより詳しく知りたい場合はウィルソンの定理を御覧ください。\nよってこの問題は、素数判定を$O(N)$から$O(\\sqrt N)$に高速化することで解くことができます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from gmpy2 import iroot from Crypto.Util.number import isPrime b = c = def verify(a): return isPrime(a) for i,a in enumerate(b): if verify(a): print(c[i], end=\u0026#34;\u0026#34;) # sctf{unl0cking_th3_myst3r13s_0f_f4ct0ri4ls_4nd_th3ir_3xtr4ordinary_pr0p3rt13s} Smidgen $2^x$の上位$7$桁のみが与えられて、$x$を求める問題です。$x$が大きくなると桁数が大きくなり計算に非常に時間がかかるため、$\\log$をうまく使って、上位7桁のみ求められないかを考えます。 以下、$\\log$の底は$10$とします。\n例えば、$1.234567 \\times 10^{100}$という数は、上位$7$桁が$1234567$となります。これを対数で表すと、 $$ \\begin{align} \\log(1.234567 \\times 10^{100}) \u0026amp;= \\log(1.234567) + \\log(10^{100}) \\\\ \u0026amp;= \\log(1.234567) + 100\\log(10) \\\\ \u0026amp;= 100 + \\log(1.234567) \\end{align} $$ となります。$\\log(1.234567)\u0026lt;1$ですので、対数を取った値の小数部分に各桁の情報が入っています。よって、 $$ 10^{\\log(1.234567)} = 1.234567 $$ と累乗を行うと、数字の復元ができます。\nこのように、$2^x = a \\times 10^b$と考えれば、$\\log(2^x) = \\log(a) + b\\log(10)$となり、$10^{\\log(a)}$の小数点以下6桁までが、$2^x$の上位$7$桁と一致します。\npythonのlog10関数の精度が気になりますが、今回は小数点以下6桁まで求めれば十分ですので、問題ありません。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from math import log10 from Crypto.Util.number import long_to_bytes s = \u0026#34;1873119\u0026#34; # 2^x の 上から7桁 def top7(x): a = x * log10(2) # aの小数部分を取り出す b = a - int(a) # 10^b を求める c = 10 ** b # 10^b の上から7桁を求める d = int(c * 10 ** 6) return d x = 1 y = 1 while True: if str(top7(x)) == s: print(x) print(long_to_bytes(x)) # break x += 1 # PIN RSA starter やるだけです。RSAの説明はネットに山ほどあるので省略します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from Crypto.Util.number import long_to_bytes p = # q = # n = # e = 65537 c = # phi = (p-1)*(q-1) d = pow(e,-1,phi) m = pow(c,d,n) print(long_to_bytes(m)) # sctf{A_good_start} Each RSA $1$文字ずつ暗号化されているということは、各平文$m_i$は高々$128$以下の数であることがわかります。$x^e = c_i \\pmod n$となるような$x$を全探索すれば良いです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from Crypto.Util.number import long_to_bytes from gmpy2 import iroot n = # e = 65537 cs = [ # m = \u0026#34;\u0026#34; for c in cs: for i in range(256): if c==pow(i,e,n): m += chr(i) break print(m) # sctf{it_is_sunday} Small RSA $e$が小さく$m^e \u0026lt; n $となっていると予想できます。実際に$3$乗根を取ると、平文が得られます。\n1 2 3 4 5 6 7 8 9 10 11 from Crypto.Util.number import long_to_bytes from gmpy2 import iroot n = # e = 3 c = # m = iroot(c,e)[0] print(long_to_bytes(m)) # sctf{this_looks_#short} RUSH E $100$回暗号化しているだけなので$100$回復号すれば良いです。ちなみに$(a^x)^y=(a^y)^x$なので$e$の順番はなんでも良いです。\n1 2 3 4 5 6 7 8 9 10 11 12 from Crypto.Util.number import long_to_bytes p = # E = [ # c = # phi = p-1 for e in E: c = pow(c, pow(e, -1, phi), p) print(long_to_bytes(c)) # sctf{Enigma_0f_Ethereal_Expl0ration} 2D Lagrange $a,b,c$のうち、2つの値が求まれば残りの一つは定まります。次のソースコードでは$b,c$を全探索しています。 $a,b,c$が決定すれば、2次方程式になるので、解の公式や二分探索で解けます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from gmpy2 import iroot from Crypto.Util.number import long_to_bytes def function(a,b,c,x): return a*x*x + b*x + c x = 2911 y = 8337062002 ct = # for b in range(3000): for c in range(3000): a = (y - b*x - c)//(x*x) if function(a,b,c,x) != y: continue print(a,b,c) # 二分探索で，f(x) = ctとなるxを求める l = 0 r = ct while r - l \u0026gt; 1: m = (l + r) // 2 if function(a,b,c,m) \u0026gt;= ct: r = m else: l = m assert function(a,b,c,r) == ct assert function(a,b,c,x) == y print(long_to_bytes(r)) # sctf{brute_force_is_not_so_bad} Common N RSA $e_1, e_2$が互いに素であることから、$e_1x + e_2y = 1$となるような$x,y$が存在します。 そのような$x,y$を求め、$c_1^x \\times c_2^y = m^{e_1x+e_2y} = m$となるので、$m$が求まります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse n = # e1 = 135879330917823239005274526173902941241 e2 = 110581307957357787004164255007822749852 c1 = # c2 = # def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) g, a,b = egcd(e1,e2) m = pow(c1,a,n)*pow(c2,b,n)%n print(long_to_bytes(m)) # sctf{C0mm0n_N_15_0n3_0f_7h3_m057_345y_7o_f@c70r1z3_pr1m3_f@c70r5} Many RSA 素数が$9$個しか用意されていないのに、$5$回の暗号化、すなわち$10$個の素数を使っているということは、 必ずある$n_i$と$n_j$が同じ素数を使っていることになります。よって、$n_i$と$n_j$の最大公約数を求めることで、ある素数$p$が求まります。 $i,j$は全探索すればよいです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from gmpy2 import iroot from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrime e = 65537 n = [ # c = [ # def GCD(a, b): if b == 0: return a return GCD(b, a % b) for i in range(1, len(n)): for j in range(i+1,len(n)): if GCD(n[i], n[j]) != 1: p = GCD(n[i], n[j]) q = n[i] // p phi = (p - 1) * (q - 1) d = pow(e, -1, phi) m = pow(c[i], d, n[i]) print(long_to_bytes(m)) # sctf{GCD_15_50_useful_in_m4th_4nd_cryp70_!} Unbalance RSA $n=p_1,p_2,\\dots,p_k$のうち、$p_1,p_2,\\dots,p_x ( x\u0026lt;k ) $だけが求まったとき、 $n^\\prime = p_1p_2\\dots p_x\u0026gt;m$であれば$n^\\prime$を使って復号できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from gmpy2 import iroot from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrime n = # c = # e = 65537 def factor(n): p = [] for i in range(1\u0026lt;\u0026lt;24, 1\u0026lt;\u0026lt;26): if n % i == 0: p.append(i) n //= i return p ps = factor(n) phi = 1 n = 1 for p in ps: phi *= p - 1 n *= p d = pow(e, -1, phi) m = pow(c, d, n) print(long_to_bytes(m)) # sctf{sti11_we4k_rs@} CutRSA $p,q$それぞれ$1024$うち、$p$は上位$512$bit、$q$は下位$512$bitだけわかっています。\n$n$の下位$1$bitは、$p$と$q$の下位$1$bitの積です。よって、$q$の下位$1$ビットがわかっているため、$p$の下位$1$bitが求まります。 $n$の下位$2$bitは、$p$と$q$の下位$2$bitの積です。よって、$q$の下位$2$ビットと$p$の下位$1$bitがわかっているため、$p$の下位$2$bitが求まります。 以下同様に、$p$の下位$512$bitが求まります。 $p$が分かれば、$q$は$n/p$で求まります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from gmpy2 import iroot from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrime n = # c = # e = 65537 s = # # sはpの上位$512$bitとqの下位$512$bitを結合したもの mask = (1\u0026lt;\u0026lt;512) - 1 q = s \u0026amp; mask p = (s \u0026gt;\u0026gt; 512) \u0026lt;\u0026lt; 512 # pの下位ビットから決定していく for i in range(512): if (p*q) % (1\u0026lt;\u0026lt;(i+1)) == n % (1\u0026lt;\u0026lt;(i+1)): pass else: p += 1\u0026lt;\u0026lt;i q = n // p assert p*q == n phi = (p-1)*(q-1) d = pow(e, -1, phi) m = pow(c, d, n) print(long_to_bytes(m)) # sctf{CUT_i5_@_U53FUL_L1NUX_C0MM@ND} Insufficient RSA 求まるフラグがダミーのもの(flag{????????????????}みたいな文字列)になってしまうという問題の不備があります(要修正)\n$m^{e_1e_2}$に$m^{e_1}$の逆元を掛け算していくと、 $$ \\begin{align} m^{e_1e_2} \\times m^{-e_1} \u0026amp;= m^{e_1e_2 - e_1} \\\\ \u0026amp;= m^{e_1(e_2 - 1)} \\\\ m^{e_1e_2}\\times m^{-2e_1} \u0026amp;= m^{e_1(e_2 - 2)} \\\\ \\dots \\\\ m^{e_1e_2} \\times m^{-ke_1} \u0026amp;= m^{e_1(e_2 - k)} \\\\ \\end{align} $$ $k$が$e_2-1$になったときに、$m^{e_1e_2} \\times m^{-ke_1} = m^{e_1}$が成り立ちます。今回$e_2$はそこまで大きくないため、$k$を順に試していけば、$m^{e_2}$が求まります。\n同じ手順を使えば、$m^{e_1}$も求まります。$e_1,e_2$が求まれば、あとはCommon N RSAと同じです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from gmpy2 import iroot from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrime, inverse n = # c1 = # c2 = # c3 = # # c1:m^e1 mod n # c2:m^e2 mod n # c3:m^(e1*e2) mod n c1i = inverse(c1, n) i = 0 c4 = c3 while c4 != c1: c4 = (c1i * c4) % n i += 1 e2 = i+1 c2i = inverse(c2, n) i = 0 c4 = c3 while c4 != c2: c4 = (c2i * c4) % n i += 1 e1 = i+1 def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) g, a,b = egcd(e1,e2) m = (pow(c1,a,n)*pow(c2,b,n)) %n print(long_to_bytes(m)) # @Everyone 共通の$m,e$と異なる$n$に対するデータを複数得られる場合に使えるHastad Broadcast Attackをします。\n$k$個の$c_i = m^e \\pmod {n_i}$を満たす値の組$(n_i,c_i)$と$e$が与えられたとします。 これは、$m^e$に対して、中国剰余定理(Math Class 7を参照)の問題と一致しますので、次の条件を満たす$x$を求めることができます(簡単のため、全ての$n_i$が互いに素であるとします)。\n$$ x = m^e \\pmod {n_1n_2\\dots n_k} $$\nこのとき、$e\\leq k$である場合、全ての$i$について$m\u0026lt;n_i$ですから、$m^e \u0026lt; n_1n_2\\dots n_k$となり、単純に$x$の$e$乗根を取ることで、$m$が求まります。\n今回の問題では、$e=11$の場合の$n$が$11$個以上得られるので、$e=11$のものだけを使って、Hasatd Broadcast Attackを行います。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 pub = [(# from Crypto.Util.number import inverse, bytes_to_long, long_to_bytes, getPrime from gmpy2 import iroot \u0026#34;\u0026#34;\u0026#34; x = dict() x[7] = 0 x[11] = 0 x[13] = 0 for n,e,c in pub: # eを数える x[e] += 1 \u0026#34;\u0026#34;\u0026#34; # e = 11のときのみ使う def crt(a, m, b, n): # nx = 1 (mod m) # my = 1 (mod n) # anx + bmy は mでmで割ったあまりがa, nで割ったあまりがbになる x = inverse(n, m) #x = pow(n,-1,m) y = inverse(m, n) return (a * n * x + b * m * y) % (m * n) def multi_crt(A, M): if len(A) == 1: return A[0], M[0] else: a = A.pop() m = M.pop() b = A.pop() n = M.pop() A.append(crt(a, m, b, n)) M.append(m * n) return multi_crt(A, M) N = [] C = [] for n,e,c in pub: if e == 11: C.append(c) N.append(n) e11, M = multi_crt(C, N) m = int(iroot(e11, 11)[0]) print(long_to_bytes(m)) # sctf{th3_unbr34k4bl3_v01c3_0f_h4st4d_br0adc4st_4tt4ck_unv34l1ng_th3_h1dd3n_s3cr3ts_0f_cr1pt0syst3ms} Hyperdefensiveness $k,b$がランダムな数で、各文字$m_i$について$(2^km_i+b)$が暗号化されています。$k$は$512$未満なので全探索可能ですが、$b$は$n$以下と非常に範囲が広いです。\nフラグの初めの二文字はscであるとわかっているため、この情報が利用できないかを考えます。つまり、既知の$m_1,m_2,c_1,c_2,e,k,n$について($k$は全探索するので便宜上既知であるとする)、次の式を満たすような$b$を求めたいです。\n$$ \\begin{align} (2^km_1+b)^e \u0026amp;= c_1 \\pmod n \\\\ (2^km_2+b)^e \u0026amp;= c_2 \\pmod n \\end{align} $$\n変形すると、 $$ \\begin{align} f(b) \u0026amp;= (2^km_1+b)^e - c_1 \\pmod n \\\\ g(b) \u0026amp;= (2^km_2+b)^e - c_2 \\pmod n \\end{align} $$\nという$2$つの多項式が$0$となるような$b$、すなわち根を求める問題になります。このような問題は、多項式の最大公約数を求めることで解くことができます(Franklin-Reiter\u0026rsquo;s Related Message Attackと呼ぶ)。\n多項式の計算はsagemathに任せると便利です。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 n = 111514100148774326367705704736979222700401163624613214832624545719172770237899669582747006984030817853537084997757295711771232132521914358653635342045379037331503674931338739346404124271446163845765651229207102076432601166326800350688722515916583372070523688695222758956481368503534557433446349136015628686357 e = 7 cs = [36267140803452927179495057268448637938138995328162738572087076174220240409292283541262772017889475150655158065847142060266322895790122174113706941494516841596254131235045666942402107201191704864689684087893142094789041848673700495337259457092014502960338636410206960779545493988287354582365176480889241401397, 84177014604944804713431824977078430985039214840423548727302549935407939656001979736935056882466843836602458913229420653818014792087210619568737881610552000458150387886315505969718562202068244042324330912044030393635010283562361328009574502508818702705813189169328775333079963347257257925439630420220127175829, 26334588403552340607768398401306649416040755108588686852906416781666048381323771223923748405041710715559064788598428283647378768153915565669694911025250778622002628864868653682135547573138160585696497105672184318572016275402944765554398056054008792299636594593784891344328744192547814256637485325927317001395, 39008748355038168689186112775415171775080453538840696392929415443773790351994722271571121500900391631955057916363561421994355312684103960195488880752606720853798798281056868691805850650791447036298961423811854772591007911280152475310164832965003512721252819160190892144211679158575822375393777439609931384228, 82304474098043608661060028321681382334401394934904222339395319421383234876718900465268919670376069360510194518855949296211410738852781393673645359310632298617613158767343280562908595925412679114315777637952825196478714760929249924083956743233566407955764435141409334579687138596172519820900979765467753196573, 88915284105550368348816008646608742292143489029127610126933206845483111178644891122256082598282559325036353326973664929069944575618690996757635254147026094139437865194750539450473269922090279864309652543519451590611102139707332820460670115266911755768845241843718195465579759746419873378517868651352058841458, 98160368638847675399572398674748989820793124316223139981985855809205341298949801328255193676763501201274664892968977440665912753652643866920809757293719818430444255015639083848225580011638253333896713028293846055458529120270575215996484868800961863545736109208008592247509627201121713291801184428552756145377, 70279666367663945104159396963722599443271538912699448265711060345564659125916030957426375309362421105107348749935824650731170999396565032726246601380355258321403300241834231445800732010706990358094627163499472364138529856992133783183420053350913338600465093680827074012324157966344442294730635343631713549906, 26334588403552340607768398401306649416040755108588686852906416781666048381323771223923748405041710715559064788598428283647378768153915565669694911025250778622002628864868653682135547573138160585696497105672184318572016275402944765554398056054008792299636594593784891344328744192547814256637485325927317001395, 64763064376414100725233177531707850921895901489998530541566600837891901271286259632472966731652975882525518714861117936078937742875177256830813148392298636780335110743485184829629555885194866581373993856809276049684559851915531706344971288160366305524324492953122496357054696292196646886565479381358322089901, 53117194717106647885894381448563589551431710951341823296134446602613706746061511004659195024758322208851050987552805791982437418655652792469412944720472972658226563166131320978600741791483309755403405454978613141796416330723219433461776878939616583985714124778821795628729912025022287270480633445555264913828, 39008748355038168689186112775415171775080453538840696392929415443773790351994722271571121500900391631955057916363561421994355312684103960195488880752606720853798798281056868691805850650791447036298961423811854772591007911280152475310164832965003512721252819160190892144211679158575822375393777439609931384228, 86894782492316823641474027353348280639827350140509498202323454802239795365765754893346836370629432362724021133533998222327533787772350966000212845689517598594730975441295282822776716711598532555271750263494233082883744371824351426984036331161881322183261364331109781030043400120020631277862928075639272480540, 98160368638847675399572398674748989820793124316223139981985855809205341298949801328255193676763501201274664892968977440665912753652643866920809757293719818430444255015639083848225580011638253333896713028293846055458529120270575215996484868800961863545736109208008592247509627201121713291801184428552756145377, 84177014604944804713431824977078430985039214840423548727302549935407939656001979736935056882466843836602458913229420653818014792087210619568737881610552000458150387886315505969718562202068244042324330912044030393635010283562361328009574502508818702705813189169328775333079963347257257925439630420220127175829, 64763064376414100725233177531707850921895901489998530541566600837891901271286259632472966731652975882525518714861117936078937742875177256830813148392298636780335110743485184829629555885194866581373993856809276049684559851915531706344971288160366305524324492953122496357054696292196646886565479381358322089901, 53117194717106647885894381448563589551431710951341823296134446602613706746061511004659195024758322208851050987552805791982437418655652792469412944720472972658226563166131320978600741791483309755403405454978613141796416330723219433461776878939616583985714124778821795628729912025022287270480633445555264913828, 55246916646286914625187113796720048819441939566665506017385493092856767339656526237362346906721544511645358309134070927853338504353951702813761072243997031326763934289184435155017089001073820925041450839537239147841610796100383324289859233339039655637333071097315278349550850982664574507930331009748462710911, 106648375177462244814956519863142484434517967715967260171155727468274165192829479031138664506248057814216598696573245004451813985881502107038970656193031218207987149410860333008967386597854794100347199877481501059868628561247838289796884990343108454123533819113308605079660529262282363403293782905105286943413, 64763064376414100725233177531707850921895901489998530541566600837891901271286259632472966731652975882525518714861117936078937742875177256830813148392298636780335110743485184829629555885194866581373993856809276049684559851915531706344971288160366305524324492953122496357054696292196646886565479381358322089901, 53117194717106647885894381448563589551431710951341823296134446602613706746061511004659195024758322208851050987552805791982437418655652792469412944720472972658226563166131320978600741791483309755403405454978613141796416330723219433461776878939616583985714124778821795628729912025022287270480633445555264913828, 31650942089375642510054326764892516358156398346137044526825293211184610770488763216089112327665960486732029154795363125415308882529637371792323952011503181694383542249053937049705363331841430627186294230178074563022408165996381257431458584741639584809242782643138124672566959509661990281446947609872835868259, 57445856580199047555821927276408547257287234119338383547680295248191332034583683110165244464867776524537766857873926746540178335971787038248326614035471638752532669724573592659987617219775753496418743022777874643326596350807062794404419710292631420242689457262146875057234137466703977429352051675954990924180, 52733271064742986069580185401136225085723910924586198924963032082504789759300764373422629882605818076528578345298891993301672368391137050104915904160017718192142731169500900964695475818325453992891982593375220239226277506904476711254127320329801845264516893252806655032312577411519336691811621335647129023361, 53117194717106647885894381448563589551431710951341823296134446602613706746061511004659195024758322208851050987552805791982437418655652792469412944720472972658226563166131320978600741791483309755403405454978613141796416330723219433461776878939616583985714124778821795628729912025022287270480633445555264913828, 26334588403552340607768398401306649416040755108588686852906416781666048381323771223923748405041710715559064788598428283647378768153915565669694911025250778622002628864868653682135547573138160585696497105672184318572016275402944765554398056054008792299636594593784891344328744192547814256637485325927317001395, 86894782492316823641474027353348280639827350140509498202323454802239795365765754893346836370629432362724021133533998222327533787772350966000212845689517598594730975441295282822776716711598532555271750263494233082883744371824351426984036331161881322183261364331109781030043400120020631277862928075639272480540, 53117194717106647885894381448563589551431710951341823296134446602613706746061511004659195024758322208851050987552805791982437418655652792469412944720472972658226563166131320978600741791483309755403405454978613141796416330723219433461776878939616583985714124778821795628729912025022287270480633445555264913828, 98420054751348658774654768769711772575456856329670343536374214734125293362008191863353279362661406706630812620085457858523242832046777520147019565432158787727926701046522801552223950521984840410467512317098698121156619169844565429672876258879490904439880561021274307016589721198271903007801901439744506436516, 8103856376845753749810636625954342348018992185519844669722934214750220704461506083125434201240659143412545192044085752110862173338746105220687527651499789257412505481727824115069835196124083503200171598235085429192694286297720468885721800993830272620709634783849094028115111736986619372457889210633015446035, 84177014604944804713431824977078430985039214840423548727302549935407939656001979736935056882466843836602458913229420653818014792087210619568737881610552000458150387886315505969718562202068244042324330912044030393635010283562361328009574502508818702705813189169328775333079963347257257925439630420220127175829, 26334588403552340607768398401306649416040755108588686852906416781666048381323771223923748405041710715559064788598428283647378768153915565669694911025250778622002628864868653682135547573138160585696497105672184318572016275402944765554398056054008792299636594593784891344328744192547814256637485325927317001395, 86894782492316823641474027353348280639827350140509498202323454802239795365765754893346836370629432362724021133533998222327533787772350966000212845689517598594730975441295282822776716711598532555271750263494233082883744371824351426984036331161881322183261364331109781030043400120020631277862928075639272480540, 98160368638847675399572398674748989820793124316223139981985855809205341298949801328255193676763501201274664892968977440665912753652643866920809757293719818430444255015639083848225580011638253333896713028293846055458529120270575215996484868800961863545736109208008592247509627201121713291801184428552756145377, 52733271064742986069580185401136225085723910924586198924963032082504789759300764373422629882605818076528578345298891993301672368391137050104915904160017718192142731169500900964695475818325453992891982593375220239226277506904476711254127320329801845264516893252806655032312577411519336691811621335647129023361, 73198532513569656825655932815116028623768108369022850693529471046786059562748754190203684724306442952754102776745207511288787858904129031621886376980579480123167701603828307388858285877348902045940914696081392483634390312790021307265070190586697015612393856134764738032761300682449532714249075851386488278344] def my_gcd(a, b): return a.monic() if b == 0 else my_gcd(b, a % b) m1 = ord(\u0026#34;s\u0026#34;) m2 = ord(\u0026#34;c\u0026#34;) e = 7 a = 0 b = 0 for k in range(512): R.\u0026lt;X\u0026gt; = Zmod(n)[] a = 1\u0026lt;\u0026lt;k f1 = (a*m1+X)^e - cs[0] f2 = (a*m2+X)^e - cs[1] try: b = int(- my_gcd(f1, f2).coefficients()[0]) print(f\u0026#34;k = {k}\u0026#34;) for c in cs: for x in range(256): if ((a*x+b)^e) % n == c: print(chr(x), end=\u0026#34;\u0026#34;) break print() except: continue # k = 366 sctf{brut3_f0rc3_7h3_w4y_t0_v1ct0ry} Inverse Reversal なんか別解があるかもしれない\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from Crypto.Util.number import getPrime,inverse n = 115212497901906646076814945650309895223065016560945864089583972246705800990408483001623222186324281257478104684257852308787917125013403838511481248490878740277179793165166692920877439191759389913333342083969182732100040787346793325220621228831728421953145471976655292176384523616588290831652574119800536966597 d = 19342653619736321095019406739262858513292763553015427066205052775548921803712884940275240366691800221581311317505876509706704872192509791241353606371262312134419486455811905110699389036576438861749023222249924933100895188124818488844030692986386829677836303137950484789561971041735662663305221446673307607903 cs = [10242353083978425331223562567797514269135215185677532560179294927783959853514576981778894630349657921370334867951932593410475405995555736289847906042154384112685837678725023193827132344629725212164816493692848875410307544085203226440101540274011526700374931385518493417831316368488321727325515184568151426455, 10614892818365802934451081378888295041081933298314928457901366555968758473121378170911908812818997986081798069596185564224503943996567858768096095178074783142157529299486123996800432099683337523921701427572226532224929782596836875496174442947880382545797686865815099891604486286261919787127731895584214253785, 72453657083310089257132068668974440912111801910670468142317456734350746471656367901264395778244635699977087097440995706702553124375734909696651750134682685709474688342738091903309538593951219266496664218122721154957824947660952033076392157464628668943992581665800520466971397710440867328436725612844277185616, 98647759533143513480808149613887823568238300609882691602096508004696657959802528537131254224850762306677259319833460144958287042247188426802367363927273056606211932763782568610947132004917354050553817497737126062407543531223388475777919791247670350517819379638325075367384138491381057683847737466150749906086, 5024106669088093463562003718960109330705313562374543452438528313602617855905357532401880976240908091589698502023900906193469696286523508656527954451217307246424367688322103788009065126131508639251724653910735464299488376026339973561512095039160255996331127424626346940134555201647184801777652970005802921143, 57173566276152839839326205894969370339758769921399891434875201283350731025118233760406235071539545354369673595264536860334831405072362487356080042621379546106920371432129691982972436507749869786965986222104013143255093818747178117303575600939508848006078594085804147598648950372495589242867378340844539661829, 72453657083310089257132068668974440912111801910670468142317456734350746471656367901264395778244635699977087097440995706702553124375734909696651750134682685709474688342738091903309538593951219266496664218122721154957824947660952033076392157464628668943992581665800520466971397710440867328436725612844277185616, 30435994844696312458494966250848321779446940788476109430292339003759154360078941628171673055563466722255430556678813632559392927613683797507011461879353648054072770458773867982674111453591882581233508653698601274594552675881288898660885862998206884728148995407501713146968533321243438589523371623699094795941, 101327808423581541592927587047949532461793587521748592441894490558592733574958025837374249565965539028382209688316495047271591406329064827819425085902480209825849591040817009596108200881620618935625503689726361288586186992320497576451483131062751737536741217186325586722811410637968567618389787684331857560466, 87327169844523983024186122383572724936154831354783181878608891256805223750743051844195949497070499407051410981035689713887898481337279219925556788783414737155282223548872037661604716321394914122415178667868475649231602861435439948258055912755300227699665009680374017179552306049067806593638989478265257595623, 83389481040888030497790856848973402030638198599319104116648084674236455938345675099368791841144352956046785402693005865670852470990434078462372280366029119995664273357425145926363303962778643242574305196497209905020602604439770139514055798012244591463708875277734005171406049852868517184826790127424279602263, 26792604381377646077098396402793260738684852310097622835968043750488106684330389237457168995202432614926580714465344748955074731719122502856866853487774583986285615961561621872145383441414834424713492508633213590761466745269943443807603367636717881288504235179294189373487936760761540576883070654916009409489, 35426564731555513889237851465082545080255618916833078895301715072525216421320154889997120839511818209471077625066596255091975363510085882249655811276653233946009549269824606063686727755715259122186269630597735752989834148511877377230724853255333533300337152431524296263063305208567628038219756987849457785148, 72453657083310089257132068668974440912111801910670468142317456734350746471656367901264395778244635699977087097440995706702553124375734909696651750134682685709474688342738091903309538593951219266496664218122721154957824947660952033076392157464628668943992581665800520466971397710440867328436725612844277185616, 46694861756002366916735706731645345372121033836980649100683722948357911912209141799920512867115893415002115075227691875589099809025019151369694200136210026519207841609285202410859349378827669505134459181680564235975074207427460022602304708994084086149876123334646641467468267011532759183033751055001391252393, 30281694323753863441458350867904624817874667313481502785042126500756321120109405758999655235727302061889490451635511689922900929396338872303053038123411867687502338609514654580525716898320102869066117558818006714170127735357538143274531326933123213412752430796055539684175708243042908698142872283111107911608, 35426564731555513889237851465082545080255618916833078895301715072525216421320154889997120839511818209471077625066596255091975363510085882249655811276653233946009549269824606063686727755715259122186269630597735752989834148511877377230724853255333533300337152431524296263063305208567628038219756987849457785148, 55947104004191368365525210908485429681715011104626243979740505073406415385317433313938927531181223866386726543803621434029056235995279269101857548719257175008980354239448996290266943546288142431829714013341868359231844108948117002182179094761193999997792925591224764364942764312381437578659564620658162873394, 10242353083978425331223562567797514269135215185677532560179294927783959853514576981778894630349657921370334867951932593410475405995555736289847906042154384112685837678725023193827132344629725212164816493692848875410307544085203226440101540274011526700374931385518493417831316368488321727325515184568151426455, 85267805011078363506697155175062140207445636998652678963847567597112933065517043730217680585462732863070856582374109392402549375548014962953949834827583055566900127699689740704152509523751459328749013852559215003223022025558104675431581960531031400080057668288019225200618673162281176331058730009345028638060, 43047625107074961743170004020658620084375081659174244597272835102164875655042305084803789362225520075857994590638259054752253410693500437272595903397968434067504193320473056550732678581801885531679906689781871720252899783313666739622387198014024957715716687506601726301004202794916941972004298741372447690057, 101327808423581541592927587047949532461793587521748592441894490558592733574958025837374249565965539028382209688316495047271591406329064827819425085902480209825849591040817009596108200881620618935625503689726361288586186992320497576451483131062751737536741217186325586722811410637968567618389787684331857560466, 10242353083978425331223562567797514269135215185677532560179294927783959853514576981778894630349657921370334867951932593410475405995555736289847906042154384112685837678725023193827132344629725212164816493692848875410307544085203226440101540274011526700374931385518493417831316368488321727325515184568151426455, 46694861756002366916735706731645345372121033836980649100683722948357911912209141799920512867115893415002115075227691875589099809025019151369694200136210026519207841609285202410859349378827669505134459181680564235975074207427460022602304708994084086149876123334646641467468267011532759183033751055001391252393, 55947104004191368365525210908485429681715011104626243979740505073406415385317433313938927531181223866386726543803621434029056235995279269101857548719257175008980354239448996290266943546288142431829714013341868359231844108948117002182179094761193999997792925591224764364942764312381437578659564620658162873394, 48701029335169050508642116151835089481818697324049380991235220805438674667171014369618826489746401294080141491827209900960986109207050654566836044829486033474924457434225003427052894914134076164371360065924409850345014725627321986139065590438897603233947896392172107313010455120719211550140742035249226008482, 46694861756002366916735706731645345372121033836980649100683722948357911912209141799920512867115893415002115075227691875589099809025019151369694200136210026519207841609285202410859349378827669505134459181680564235975074207427460022602304708994084086149876123334646641467468267011532759183033751055001391252393, 72453657083310089257132068668974440912111801910670468142317456734350746471656367901264395778244635699977087097440995706702553124375734909696651750134682685709474688342738091903309538593951219266496664218122721154957824947660952033076392157464628668943992581665800520466971397710440867328436725612844277185616, 35426564731555513889237851465082545080255618916833078895301715072525216421320154889997120839511818209471077625066596255091975363510085882249655811276653233946009549269824606063686727755715259122186269630597735752989834148511877377230724853255333533300337152431524296263063305208567628038219756987849457785148, 43047625107074961743170004020658620084375081659174244597272835102164875655042305084803789362225520075857994590638259054752253410693500437272595903397968434067504193320473056550732678581801885531679906689781871720252899783313666739622387198014024957715716687506601726301004202794916941972004298741372447690057, 46694861756002366916735706731645345372121033836980649100683722948357911912209141799920512867115893415002115075227691875589099809025019151369694200136210026519207841609285202410859349378827669505134459181680564235975074207427460022602304708994084086149876123334646641467468267011532759183033751055001391252393, 95986447367326045426093398035717128745163168231027353313760049410714829280428132832024046121355336674565326660817719248178163295994324691661441849140970460223065048107525352432555086007197658274507458708928265358450858922214849451622695839976809845404589461849583560990174570270949221589643971236255473759502, 48701029335169050508642116151835089481818697324049380991235220805438674667171014369618826489746401294080141491827209900960986109207050654566836044829486033474924457434225003427052894914134076164371360065924409850345014725627321986139065590438897603233947896392172107313010455120719211550140742035249226008482, 55947104004191368365525210908485429681715011104626243979740505073406415385317433313938927531181223866386726543803621434029056235995279269101857548719257175008980354239448996290266943546288142431829714013341868359231844108948117002182179094761193999997792925591224764364942764312381437578659564620658162873394, 102196388132599661465127193498136214712734194555655476808934335897150648235342527038264806315430610409951157462783049809187879614657038847599689303851674413518624572369961782451485453027424159211981889371367117652871850755510134374933378219884631142150177303670825264449000800735646906719228306418991923032954, 43047625107074961743170004020658620084375081659174244597272835102164875655042305084803789362225520075857994590638259054752253410693500437272595903397968434067504193320473056550732678581801885531679906689781871720252899783313666739622387198014024957715716687506601726301004202794916941972004298741372447690057, 101327808423581541592927587047949532461793587521748592441894490558592733574958025837374249565965539028382209688316495047271591406329064827819425085902480209825849591040817009596108200881620618935625503689726361288586186992320497576451483131062751737536741217186325586722811410637968567618389787684331857560466, 10242353083978425331223562567797514269135215185677532560179294927783959853514576981778894630349657921370334867951932593410475405995555736289847906042154384112685837678725023193827132344629725212164816493692848875410307544085203226440101540274011526700374931385518493417831316368488321727325515184568151426455, 43047625107074961743170004020658620084375081659174244597272835102164875655042305084803789362225520075857994590638259054752253410693500437272595903397968434067504193320473056550732678581801885531679906689781871720252899783313666739622387198014024957715716687506601726301004202794916941972004298741372447690057, 5723729500504613988911012649235488314230597739998519880019057473508281675665686082911553905048649088376231234736824807660779859279904139231528796753965476265375603355980972192840798014180095210645960735022184908387410405125923950581976641525552168832330666924058878897788723720324546796860220974929285264525, 10242353083978425331223562567797514269135215185677532560179294927783959853514576981778894630349657921370334867951932593410475405995555736289847906042154384112685837678725023193827132344629725212164816493692848875410307544085203226440101540274011526700374931385518493417831316368488321727325515184568151426455, 46694861756002366916735706731645345372121033836980649100683722948357911912209141799920512867115893415002115075227691875589099809025019151369694200136210026519207841609285202410859349378827669505134459181680564235975074207427460022602304708994084086149876123334646641467468267011532759183033751055001391252393, 87307118345310119702653258381222073997804918741479869849232042749266878907749898467232887168663477815484043456727924324857395490287647603394842113311356233210988146555085321731058015777591227193439937161999647013197843369064629243657749023009638738937385179227360016071066981347721566597740037811800028211483, 19267198945211754297861142477484287320095370091394051943504033284349930360528342837033482462198025535111342423655963398315577109419041936760730669884411765478038017214819407760529579393734167528794080178740275931809218061260127483809186886377334175072486121939122414822581819234903557620052078724578274336979, 10242353083978425331223562567797514269135215185677532560179294927783959853514576981778894630349657921370334867951932593410475405995555736289847906042154384112685837678725023193827132344629725212164816493692848875410307544085203226440101540274011526700374931385518493417831316368488321727325515184568151426455, 72453657083310089257132068668974440912111801910670468142317456734350746471656367901264395778244635699977087097440995706702553124375734909696651750134682685709474688342738091903309538593951219266496664218122721154957824947660952033076392157464628668943992581665800520466971397710440867328436725612844277185616, 43047625107074961743170004020658620084375081659174244597272835102164875655042305084803789362225520075857994590638259054752253410693500437272595903397968434067504193320473056550732678581801885531679906689781871720252899783313666739622387198014024957715716687506601726301004202794916941972004298741372447690057, 101327808423581541592927587047949532461793587521748592441894490558592733574958025837374249565965539028382209688316495047271591406329064827819425085902480209825849591040817009596108200881620618935625503689726361288586186992320497576451483131062751737536741217186325586722811410637968567618389787684331857560466, 55947104004191368365525210908485429681715011104626243979740505073406415385317433313938927531181223866386726543803621434029056235995279269101857548719257175008980354239448996290266943546288142431829714013341868359231844108948117002182179094761193999997792925591224764364942764312381437578659564620658162873394, 34127146941936481372477524347174117649543594283221953160342239294107648519617758930779009979264231794082412213309938596375010903970416283286233605009292396324305464727125961014269918486135625551623103604605601774775786507536802097511555024071288539917105378126303073132004204929338960101156320517452626686652, 52036255893604477341934715473810269030247970205817055291498072878207547013204193378727013580540645618246526209850184390851220916461481967751863907859616924688860684737369522252726376036744053616828413005343792610099733100451851438439525606136549372385352089579210361004619804029816700946031427054199386628434, 10242353083978425331223562567797514269135215185677532560179294927783959853514576981778894630349657921370334867951932593410475405995555736289847906042154384112685837678725023193827132344629725212164816493692848875410307544085203226440101540274011526700374931385518493417831316368488321727325515184568151426455, 46694861756002366916735706731645345372121033836980649100683722948357911912209141799920512867115893415002115075227691875589099809025019151369694200136210026519207841609285202410859349378827669505134459181680564235975074207427460022602304708994084086149876123334646641467468267011532759183033751055001391252393, 87307118345310119702653258381222073997804918741479869849232042749266878907749898467232887168663477815484043456727924324857395490287647603394842113311356233210988146555085321731058015777591227193439937161999647013197843369064629243657749023009638738937385179227360016071066981347721566597740037811800028211483, 43047625107074961743170004020658620084375081659174244597272835102164875655042305084803789362225520075857994590638259054752253410693500437272595903397968434067504193320473056550732678581801885531679906689781871720252899783313666739622387198014024957715716687506601726301004202794916941972004298741372447690057, 87327169844523983024186122383572724936154831354783181878608891256805223750743051844195949497070499407051410981035689713887898481337279219925556788783414737155282223548872037661604716321394914122415178667868475649231602861435439948258055912755300227699665009680374017179552306049067806593638989478265257595623, 34127146941936481372477524347174117649543594283221953160342239294107648519617758930779009979264231794082412213309938596375010903970416283286233605009292396324305464727125961014269918486135625551623103604605601774775786507536802097511555024071288539917105378126303073132004204929338960101156320517452626686652, 69401495296315236368718189446344847520286894008520044766291962539023820618489257611028622222220014116454719109759418409883461463688088367181672431220134841451073808647367929163997951756171813410992531555853898652264760449505145105799573640215730814597454224932899513190043479574222894026750074303259912745643, 19267198945211754297861142477484287320095370091394051943504033284349930360528342837033482462198025535111342423655963398315577109419041936760730669884411765478038017214819407760529579393734167528794080178740275931809218061260127483809186886377334175072486121939122414822581819234903557620052078724578274336979, 24346144695681590205349279067665806307892343388448165134580850348646482294775320169625483132724950488697263847722957438768547341498183051173837126838765595397122139533539637543298860767155484880312594916234756288467120142402936525777313927872039953924465047920575821880648588810646217010641449050348837280578] def mat_mul(a, b) : I, J, K = len(a), len(b[0]), len(b) c = [[0] * J for _ in range(I)] for i in range(I) : for j in range(J) : for k in range(K) : c[i][j] += a[i][k] * b[k][j] c[i][j] %= n return c def mat_pow(x, n): y = [[0] * len(x) for _ in range(len(x))] for i in range(len(x)): y[i][i] = 1 while n \u0026gt; 0: if n \u0026amp; 1: y = mat_mul(x, y) x = mat_mul(x, x) n \u0026gt;\u0026gt;= 1 return y m = \u0026#34;\u0026#34; for c in cs: ret = [[c], [2]] mat = [[c, -1], [1, 0]] ret = mat_mul(mat_pow(mat, d-1), ret) for i in range(256): x = (i+inverse(i,n))%n if x == ret[0][0]: m += chr(i) break print(m) # sctf{St4rlight_Wh1sp3rs_1n_th3_Un1v3rs3\u0026#39;s_Myst3r10us_M3l0dy} DSA starter DSAのアルゴリズムをそのまま適用します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # DSA from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes from Crypto.Random.random import randint from hashlib import sha256 from random import shuffle p, q, g, y = (178152782381825178803219174463700910343887635796771256691167008807374935805608810619510355568394750688608183393843518297273118359566453071394197733833035896858630558725699316955042421744365078468534495190922167403912399698372676556069049828057115488315878767055028995972138905736540492834987058578356095483777, 886462388902383667466763577880397720831607417567, 63028074410235712650856818704197230709567749692836951562649290014316138139312359167371415041184383722629991416556492666859022007320300058824552605629526632600490856764473931862464430933236982859019405547828622063621971180492882956812095615397762837988938242853452722411843661219861190400890315806421801546353, 38647414566356138569980136086529833930398825658110621806133281938642505973525550931612864354218115649244247745143865068040333379732358277345437679898306683569802690274384584277131839415050015738332670477850796862979487857316281608801669816739648374889909541749203238997633769097943033727833275138527729141082) r = 853709161711035525874302893962481214917053133801 s = 257021930968164571494098920024334244863049558820 candidates = [ # # 署名の検証 for msg in candidates: w = inverse(s, q) u1 = (bytes_to_long(sha256(msg).digest()) * w) % q u2 = (r * w) % q v = ((pow(g, u1, p) * pow(y, u2, p)) % p) % q if v == r: print(f\u0026#34;Found! {msg}\u0026#34;) break # sctf{this_is_passcode_14987914387428957283749837987938471847812313} DH Starter Diffie-Hellman鍵共有のアルゴリズムは離散対数問題が解くことが難しいことを利用しています。が、今回は$p$が小さいので、Baby-step Giant-step法で解くことができてしまいます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # DSA from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes, getStrongPrime from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import sha256 from random import randint from os import urandom p = 3449512277 g = 2 A = 1853660196 B = 1844600045 iv = 0x20bd91cc19f353375134ed6ac8ab9cd8 ciphertext = 0xc4f8d8b06d616d10ec48c15c1f313c584ee4c11768ec69582cd5a254ba010400679cee579d674c84bb560c38eef5b53e2e668f11fa0044ab79f9c5bd97a94ab6 iv = long_to_bytes(iv) ciphertext = long_to_bytes(ciphertext) # X^K ≡ Y (mod M) となるような K を求める def bsgs(X, Y, M): D = {1: 0} sq = int(M**.5)+1 # Baby-step Z = 1 for i in range(sq): Z = Z * X % M D[Z] = i+1 if Y in D: return D[Y] # Giant-step R = pow(Z, M-2, M) # R = X^(-sq) for i in range(1, sq+1): Y = Y * R % M if Y in D: return D[Y] + i*sq return -1 a = bsgs(g, A, p) s = pow(B, a, p) key = sha256(long_to_bytes(s)).digest()[:16] cipher = AES.new(key, AES.MODE_CBC, iv) print(cipher.decrypt(ciphertext)) # sctf{Ro0t_Expr3ssi0n_Unveiling_Discrete_Logarithms} DHMO Backdoor DHアルゴリズムですが、素数$q$が用意されて、\n$p = q^2$ $g = q+1$ という不思議なパラメータ設定になっています。 この条件下で$A, B$を計算すると、\n$$ A = (1+q)^a \\equiv 1 + aq \\pmod{q^2} \\\\ B = (1+q)^b \\equiv 1 + bq \\pmod{q^2} $$\nというように、離散対数問題のように見えてただの線形方程式になってしまっています。よって、簡単に解けてしまいます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # DSA from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes, getStrongPrime from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import sha256 from random import randint from os import urandom from gmpy2 import iroot p = 95415937817579451380560331137505725674156858513926822163980264696859536466150605410084190929378877860698117457381837054218767245648636289250124372497832405773309953882151215182666896790688601517274746987312158949180001859580605523093541735579880492742320916914652237329506667385776239702594761823614432307209 g = 9768108200546278315194231322082114002915357430681820414703248793717480653233394063038860570648067384600535879456361644343100108834155177088164778679532548 A = 92453853458870576229518823501929360581552725741189278049516561961478833097172834801288760072546654951598477738730124366332805108801506092437910200235296192165845124855345940151854202354847168551454392462737787664299300742218459667689807033294098287219340833990501929320726865292649944555957036455424727547115 B = 56612820070987073806615211708626056370390413126863293367701116303948485194819573186994266503189322508232997547860696305447417646426321081076895093762235273029112042023440682941122763197970972104018354007661120535881288476220273010083950515697901659556323027333128910934151081165951565331390808856583772052696 iv = 0x242277a2562e41e7a2c84f07802a2113 ciphertext = 0x672233ffe1d4d793373950d4c1c177cc5caeb5b7a468e51cf86b29d4feb5bfde7847a038d3bab1050021301a0139f9ac iv = long_to_bytes(iv) ciphertext = long_to_bytes(ciphertext) # (1+q)^a = 1 + aq mod q^2 q = iroot(p, 2)[0] print(A-1) a = (A-1)//q s = pow(B, a, p) key = sha256(long_to_bytes(s)).digest()[:16] cipher = AES.new(key, AES.MODE_CBC, iv) print(cipher.decrypt(ciphertext)) # sctf{DHMO_Weakness_Revealed_Compromise_Eminent} ECC Starter 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes from Crypto.Util.Padding import pad p = 17 a = 0 b = 2 # y^2 = x^3 + ax + b mod p Gx = 12 Gy = 9 def double(p1): if p1 == None: return None x0 = p1[0] y0 = p1[1] if y0 == 0: # 無限遠O return None phi = (3 * x0 * x0 + a) * inverse(2 * y0, p) psi = (-3 * x0 * x0 * x0 - a*x0 + 2*y0*y0) * inverse(2*y0, p) x4 = (phi * phi - 2 * x0) % p y4 = (-phi * x4 - psi) % p return (x4, y4) def add(p1, p2): if p1 == None: return p2 if p2 == None: return p1 x1 = p1[0] y1 = p1[1] x2 = p2[0] y2 = p2[1] if x1 == x2 and y1%p == (-y2)%p: return None if x1 == x2 and y1 == y2: return double(p1) phi = (y2 - y1) * inverse(x2 - x1, p) psi = (y1 * x2 - y2 * x1) * inverse(x2 - x1, p) x3 = (phi * phi - x1 - x2) % p y3 = (-phi * x3 - psi) % p return (x3, y3) P = (12,9) Q = (8,2) R = add(P,Q) print(R) 1 2 3 4 5 6 7 8 9 10 11 a = 0 b = 2 p = 17 K = GF(p) E = EllipticCurve(K,[a,b]) G = E(12, 9) P = E(8,4) print(G+P) sctf{16}\nECC Starter 2 $x$軸に対称な点を加算すると無限遠になります。 sctf{4}\nECC Starter 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes from Crypto.Util.Padding import pad def double(p1): if p1 == None: return None x0 = p1[0] y0 = p1[1] if y0 == 0: # 無限遠O return None phi = (3 * x0 * x0 + a) * inverse(2 * y0, p) psi = (-3 * x0 * x0 * x0 - a*x0 + 2*y0*y0) * inverse(2*y0, p) x4 = (phi * phi - 2 * x0) % p y4 = (-phi * x4 - psi) % p return (x4, y4) def add(p1, p2): if p1 == None: return p2 if p2 == None: return p1 x1 = p1[0] y1 = p1[1] x2 = p2[0] y2 = p2[1] if x1 == x2 and y1%p == (-y2)%p: return None if x1 == x2 and y1 == y2: return double(p1) phi = (y2 - y1) * inverse(x2 - x1, p) psi = (y1 * x2 - y2 * x1) * inverse(x2 - x1, p) x3 = (phi * phi - x1 - x2) % p y3 = (-phi * x3 - psi) % p return (x3, y3) def mul(p1, n): if n == 0: return None if n == 1: return p1 if n % 2 == 0: return double(mul(p1, n//2)) if n % 2 == 1: return add(p1, double(mul(p1, n//2))) p = 58831 a = 5 b = 13 # y^2 = x^3 + ax + b mod p Gx = 28603 Gy = 46279 P = (Gx, Gy) Q = mul(P, 10) print(Q) sctf{15400}\nECC Starter 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes from Crypto.Util.Padding import pad def double(p1): if p1 == None: return None x0 = p1[0] y0 = p1[1] if y0 == 0: # 無限遠O return None phi = (3 * x0 * x0 + a) * inverse(2 * y0, p) psi = (-3 * x0 * x0 * x0 - a*x0 + 2*y0*y0) * inverse(2*y0, p) x4 = (phi * phi - 2 * x0) % p y4 = (-phi * x4 - psi) % p return (x4, y4) def add(p1, p2): if p1 == None: return p2 if p2 == None: return p1 x1 = p1[0] y1 = p1[1] x2 = p2[0] y2 = p2[1] if x1 == x2 and y1%p == (-y2)%p: return None if x1 == x2 and y1 == y2: return double(p1) phi = (y2 - y1) * inverse(x2 - x1, p) psi = (y1 * x2 - y2 * x1) * inverse(x2 - x1, p) x3 = (phi * phi - x1 - x2) % p y3 = (-phi * x3 - psi) % p return (x3, y3) def mul(p1, n): if n == 0: return None if n == 1: return p1 if n % 2 == 0: return double(mul(p1, n//2)) if n % 2 == 1: return add(p1, double(mul(p1, n//2))) p = 3173581703 a = 5 b = 13 # y^2 = x^3 + ax + b mod p Gx = 2922555662 Gy = 1379601526 P = (Gx, Gy) Q = mul(P, p) print(Q) 1 2 3 4 5 6 7 8 9 10 11 12 13 from Crypto.Util.number import getPrime a = 5 b = 13 p = 3173581703 K = GF(p) E = EllipticCurve(K,[a,b]) G = E(2922555662, 1379601526 ) print(G) print((p)*G) sctf{1012290686}\nECC Starter 5 sctf{41712}\nECC vs. RSA 楕円曲線上で、$e$倍した点を復元する問題です。$e$の逆元(楕円曲線の位数上で)を計算すればよいです。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import os from random import getrandbits import hashlib from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad from Crypto.Util.number import long_to_bytes, inverse # secp256k1 bitsize = 256 p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F a = 0 b = 7 Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798 Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 # exponent e2 = 65537 E = EllipticCurve(GF(p),[a,b]) Q = E(93433963105152978020305311287114858750860633144092310644734267100070909728359,49607652788439856681244209356178787315854579032619206302851865258501732308348) c = 0x5ccc961542dab655f1fd94073b8d1becd031b371a2c849465a0b91dce3549d352daa3859e533ce27c343eed24a9f1808 iv = 0xacc9a0d6dba3ebd3d8eb3655baaaae8a G = E(Gx,Gy) n = Q.order() c = long_to_bytes(c) iv = long_to_bytes(iv) d = inverse(e2,n) P = (d)*Q print(P) key = hashlib.sha256(long_to_bytes(int(P[0]))).digest() cipher = AES.new(key, AES.MODE_CBC, iv) m = cipher.decrypt(c) print(unpad(m,16)) # sctf{Crypt0_Unveiled_Thr0ugh_ECC_RSA_Enigmas} Knapsack Starter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from Crypto.Util.number import * q = 19476848988204872060832823259129600051004287455211043516206652751259893783183944942428856467 r = 29311266273294587273200436915502354865358876784826842913113098289713485249949916371307504229 c = 945990657049790727811563555213826037534670582134726526157349843403732326518548975197241258807 w = [263228976889951266540541834687364181713, 457935464639243892337831056783295578478, 1058195876074085625891598742796685364429, 1934211975170539017039476473246851471980, 3813329232257528690875093473358573391068, 7548351188526979796201239878428904609165, 15342376214376299641734234847361388410502, 30676111579055058805152748403012090457953, 61314165415482354434033552561206591940507, 122457509135354125562625114523776211913998, 245045468370028825796324167156568593108193, 490132911968585330062812415035249827516095, 980336727631959359084042995890560952266031, 1960712218890410427185218236979660909762713, 3921165295359268585867075266058558190047491, 7842448389418084606567626834395565528136167, 15684854680112704228353230728336753483365450, 31369856681810663918836565124030252512150917, 62739514158667052998477170704377763994464875, 125479138474588541117450796477672911548395031, 250958183125832955449049108788435947510860683, 501916497265011968966166509486889068874362376, 1003833059492784419306001709963036828597523022, 2007665977862164000887774833362203778917130761, 4015331819318235561394427804904380224700572183, 8030663847599794966775791679517475340506474867, 16061327666741485196225754142518721068080943118, 32122655345323353998576534454136019803643540679, 64245310729616839356083520012998574603423950304, 128490621341110194559129167379408144239346618394, 256981242546615628019276807071248658031631670062, 513962485288126713902190842333844183528809648761, 1027924970600288450786489616484085599828091152701, 2055849940990482356003425008869926100483221671690, 4111699882034627857142016435195095613774416853442, 8223399764305165028674983621512397264248203767081, 16446799528556974948616834997022842102628346949905, 32893599057155661341614967294809786188099159169000, 65787198114289863299284895203500669221171935691836, 131574396228310085788505514630103708420408554186039, 263148792456705125867287379096890451580988570193459, 526297584913529438181012879437140704409720583631137, 1052595169826954745965463773116138739756314031103225, 2105190339654059980131128392303874984820051581883518, 4210380679308075385776419970405407011648148027267268, 8420761358616068204682608730984585935797023148735240, 16841522717232249663297795069152658737760298312512891, 33683045434464430867773797571752143270644886204883278, 67366090868928845127882400245536153537986749318215467, 134732181737857628263363749789729833943267541695128439, 269464363475715229776799440963157258797709780239020914, 538928726951430501414854528372286612741407042677372934, 1077857453902860973085094919440328725332384482706712426, 2155714907805722202837631837419704718414663552265559180, 4311429815611444242553606338400042927549486188375483412, 8622859631222888393731412712717380322153162722607002277, 17245719262445776934016465912139643732064795350553784834, 34491438524891553747147568874352654535400550049840450634, 68982877049783107438718799754373184986004472676167594261, 137965754099566215102192084895283887966788005118662563572, 275931508199132430030634007293021764123584504939475470385, 551863016398264859986523382523585129022471394554055009435, 1103726032796529720155003462265105606483256466111108698616, 2207452065593059440240384970300352371199272846808008235379, 4414904131186118880368717968671301367907045659783220840939, 8829808262372237760948511909701827407796814078799892455848, 17659616524744475521701487905508934342721167847585411763221, 35319233049488951043417845329985524424774757313815096694704, 70638466098977902086887899164405215395786894649535300442723, 141276932197955804173745880247287180957442722334964370966546, 282553864395911608347748022365954348935775529435297210695625, 565107728791823216695400500048797452026936615561498504495800, 1130215457583646433390684998047707208069791052942278824204418, 2260430915167292866781340631462439052033775806549042273627757, 4520861830334585733562622652226068575770631209817472344431374, 9041723660669171467125263454374722081820235557791494551987159, 18083447321338342934250524265736708001496740499019055190094538, 36166894642676685868501113338137592286332612302544482485057756, 72333789285353371737002141672613582208906219392570439901703721, 144667578570706743474004416859793180811316017009618604250081956, 289335157141413486948009002951513754094921145079351292435147195, 578670314282826973896017865424292766255735419976456877004028357, 1157340628565653947792035726945634328313560050099335903802848245, 2314681257131307895584071484916560363546573736102282928362726573, 4629362514262615791168142936189402163593833141975026198871598830, 9258725028525231582336285931712985131658354715212582574367146995, 18517450057050463164672571753794287902392074875599395173445001321, 37034900114100926329345143433025043698658494079021716869810363729, 74069800228201852658690286945201185424116608368809782136879911153, 148139600456403705317380573848376468768454936157017896526821436751, 296279200912807410634761147836417492562880077408464415839925812836, 592558401825614821269522295541413003283623417844614775602991844926, 1185116803651229642539044591270817571719591114346031119224088519762, 2370233607302459285078089182311797790423709027951884197767219627489, 4740467214604918570156178364606021453368837362296775448471763559944, 9480934429209837140312356729250069790145748311960267934480838087905, 18961868858419674280624713458751382088628232003250304088543309769230, 37923737716839348561249426917310834526882249877135880939563199524561, 75847475433678697122498853834661002608365834191029460986523516653115, 151694950867357394244997707669233984078243395832393601212193574769823, 303389901734714788489995415338484802549497462764751593085610926721251, 606779803469429576979990830677134428924180420604088449473776489960306, 1213559606938859153959981661354245194413895941475040359205842686583473, 2427119213877718307919963322708252614754809336878944200561730368191557, 4854238427755436615839926645416710779751561776235946421137139708078928, 9708476855510873231679853290833317577704121721159966375281875830564338, 19416953711021746463359706581666732514173999893774109133822452371497323, 38833907422043492926719413163333385657156715009012938122750440578262832, 77667814844086985853438826326666897878038082310410763610504701470130183, 155335629688173971706877652653333586682032746273505115591234037181868344, 310671259376347943413755305306667131736767942225328981428811870395643998, 621342518752695886827510610613334390180071117312961860832391406841819242, 1242685037505391773655021221226668763320733426469906257502944537706725839, 2485370075010783547310042442453337627736279726847249205695542477157255942, 4970740150021567094620084884906675211827314506471042035293373265626939830, 9941480300043134189240169769813350276670008651025396844479521796298847105, 19882960600086268378480339539626700605915482613788268719820910533965573007, 39765921200172536756960679079253401436720214961803864078851996311157935833, 79531842400345073513921358158506802706672865389846451345114874503205005213, 159063684800690147027842716317013605468371993692078184096538877564792444780, 318127369601380294055685432634027210881752581399639207186287992365392777467, 636254739202760588111370865268054421884250687817733779499977175887424514055, 1272509478405521176222741730536108843689152570208250597214250682306871063453, 2545018956811042352445483461072217687200958170585479765867661071453005313204, 5090037913622084704890966922144435374727224095711352896489635140639284558709, 10180075827244169409781933844288870749150803604132946792902861730960130519101, 20360151654488338819563867688577741498440231818050984814414131779001893954002, 40720303308976677639127735377155482996907736287635668656167583298448205710726, 81440606617953355278255470754310965993749845305293880609616965926254291966065, 162881213235906710556510941508621931987383518233854591584928195206484523084469, 325762426471813421113021883017243863975031551177758729440470449095297505125034, 651524852943626842226043766034487727950001553814845214384370479452678770364486, 1303049705887253684452087532068975455899963985904839518584012121113144472278629, 2606099411774507368904175064137950911800064973447132296429922340194207206283403, 5212198823549014737808350128275901823600031933516369803366230858975355751742222, 10424397647098029475616700256551803647199952513646467290746525005642958338658131, 20848795294196058951233400513103607294399865165820761853103287568442192655904557, 41697590588392117902466801026207214588799775496407528083559167958620980948129123, 83395181176784235804933602052414429177599478133657109937098904135479294173925163, 166790362353568471609867204104828858355199142821865559664818176369748440091865937, 333580724707136943219734408209657716710398084055335450415180886098089029002838155, 667161449414273886439468816419315433420796288526206915881212684246336427399630981, 1334322898828547772878937632838630866841592652133597315692233339916367877136281186, 2668645797657095545757875265677261733683185227803667762780671479934012015987584583, 5337291595314191091515750531354523467366370314564538407749812829898633825373399680, 10674583190628382183031501062709046934732740774556387387862300273499571252048865079, 21349166381256764366063002125418093869465481720805671426454128431134329516135095761, 42698332762513528732126004250836187738930963282482100862796467954829168376044456878, 85396665525027057464252008501672375477861926499746255378365668800226613007580617247, 170793331050054114928504017003344750955723853028399583392630736846908044182196193007, 341586662100108229857008034006689501911447706242980595606170845145627101786522415403, 683173324200216459714016068013379003822895412498690191005975508101333950029720159355, 1366346648400432919428032136026758007645790825004255814047917130079813940756486579954, 2732693296800865838856064272053516015291581649768642168926936527369393080354781167740, 5465386593601731677712128544107032030583163299770499928222287223443786634370668059852, 10930773187203463355424257088214064061166326599293081832651132958631628113141503796974, 21861546374406926710848514176428128122332653198798219733689320505230168037031634772693, 43723092748813853421697028352856256244665306397312102686768877285823463474179918401903, 87446185497627706843394056705712512489330612794900982032101851797136904153336456238020, 174892370995255413686788113411425024978661225589557302145435604480844789031725418075992, 349784741990510827373576226822850049957322451179335479358445853411807130258467327702021, 699569483981021654747152453645700099914644902358741940569264175414201762057057799022129, 1399138967962043309494304907291400199829289804717165770650446407070302606046582025974620, 2798277935924086618988609814582800399658579609434558489360516727584419391721419833736445, 5596555871848173237977219629165600799317159218868899160948298515143384316463999067586636, 11193111743696346475954439258331201598634318437737879857707609916687973601545341951410159, 22386223487392692951908878516662403197268636875475806289175077655992859464525002451610176, 44772446974785385903817757033324806394537273750951700014946615606735494776383693258655688, 89544893949570771807635514066649612789074547501903184095022764183600184336070525246028640, 179089787899141543615271028133299225578149095003806543606123912894383587333125968090708987, 358179575798283087230542056266598451156298190007613060740055284132334732369346512327144844, 716359151596566174461084112533196902312596380015226109582319932656020963488351038028739646, 1432718303193132348922168225066393804625192760030452163868958382266333790500844020941445604, 2865436606386264697844336450132787609250385520060904416604457827324560131134874955795659071, 5730873212772529395688672900265575218500771040121808724814913279500673400050155498850067943] n = len(w) c = (c * inverse(r, q))%q m = 0 for i in range(n-1, -1, -1): if c \u0026gt;= w[i]: m += 1 \u0026lt;\u0026lt; i c -= w[i] print(long_to_bytes(m)) # sctf{NP-Hard_Knapsack} What\u0026rsquo;s in the bag? $w,q$の値がわかりませんが、配布ファイルをよく見ると乱数は使っておらず、毎回同じ値が求まるようにできているので、これを利用して$w,q$を求めます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from Crypto.Util.number import * b = [460512672224238860814315137993310742357595503044391945632042049419054327951919468685681985, 1381538016672716582442945413979932227072786509133175836896126148257162983855758406057045955, 4144614050018149747328836241939796681218359527399527510688378444771488951567275218171137865, 5686547812913902340122430027557447584953827435183531575031782650803505850248688861484284418, 3565054764460613216639132686148457837458980011520492811028642585388595541839792998394594900, 3947869956241292748053319360183431053675688887546427476052575072654825621066242202154655523, 5096315531583331342295879382288350702325815515624231471124372534453515858745589813434837392, 1794357920468900223159480750341167189574944252842592499306412236338625567330495854246253822, 5383073761406700669478442251023501568724832758527777497919236709015876701991487562738761466, 2654632609939008204707169356546619788771995981553230579691004760025708097068189102158026044, 1216603492676477712257429371377916907614736797644640782039661596566163286751430513444948955, 3649810478029433136772288114133750722844210392933922346118984789698489860254291540334846865, 4202137096947752508452785644139309709831380031786716081323601685584508576309737827975411418, 5859116953702710623494278234155986670792888948345097286937452373242564724476076690897105077, 4082762186827038066754677305944075094976164551005189946745651752705772164521956486633056877, 5500992223340567298399953219570282826227242506000518883203602574606355489112732666870041454, 3008387995740608091471702262186963561279225223971454735544102356797144458431924414551866008, 2277869650081277372551028088298948225136424524899313249598954386880472370842636450626468847, 86314613103285215789005566634902216708022427682888791763510477130456108074772558850277364, 258943839309855647367016699904706650124067283048666375290531431391368324224317676550832092, 776831517929566942101050099714119950372201849145999125871594294174104972672953029652496276, 2330494553788700826303150299142359851116605547437997377614782882522314918018859088957488828, 244189324225555577045372199165137094648565495298941175810995964055983749603440473843337307, 732567972676666731136116597495411283945696485896823527432987892167951248810321421530011921, 2197703918030000193408349792486233851837089457690470582298963676503853746430964264590035763, 6593111754090000580225049377458701555511268373071411746896891029511561239292892793770107289, 6284746587988907936946990735852219749131302825184133326623967721512761708972404795252063513, 5359651089685630007112814811032774329991406181522298065805197797516363118010940799697932185, 2584364594775796217610287036574438072571716250536792283348888025527167345126548813035538201, 1005799447186841750966782411461371759013897604595325893013311393070541030926509646077485426, 3017398341560525252900347234384115277041692813785977679039934179211623092779528938232456278, 2304900687541028856836963004890403372423827294342882080086449854123908273885450021668239657, 167407725482539668646810316409267658570230736013595283225996878860763817203213271975589794, 502223176447619005940430949227802975710692208040785849677990636582291451609639815926769382, 1506669529342857017821292847683408927132076624122357549033971909746874354828919447780308146, 4520008588028571053463878543050226781396229872367072647101915729240623064486758343340924438, 65437089804619356663478232626795426786187323071116027239041820699947184554001443964514960, 196311269413858069990434697880386280358561969213348081717125462099841553662004331893544880, 588933808241574209971304093641158841075685907640044245151376386299524660986012995680634640, 1766801424724722629913912280923476523227057722920132735454129158898573982958038987041903920, 5300404274174167889741736842770429569681173168760398206362387476695721948874116961125711760, 2406624148241409865497053131787403791641017212251092705020457063065243837716077297318876926, 472578107583682694627080697100268916221800489738227158028018505684770508695095098927501601, 1417734322751048083881242091300806748665401469214681474084055517054311526085285296782504803, 4253202968253144251643726273902420245996204407644044422252166551162934578255855890347514409, 6012314567618885853067100123445318279287362075917082309723146969977842730314430878013414050, 4542355028575563755473142973812069920459583933721145015102735542911606182037019047981983796, 132476411445597462691271524912324843976249507133333131241501261712896537204783557887693034, 397429234336792388073814574736974531928748521399999393724503785138689611614350673663079102, 1192287703010377164221443724210923595786245564199998181173511355416068834843052020989237306, 3576863109031131492664331172632770787358736692599994543520534066248206504529156062967711918, 3983294989952847576128914819636369903374958930784932673528249515233658509134331395874006577, 5202590632717995826522665760647167251423625645339747063551395862190014522949857394592890554, 2113183223872893675839839885417616836868374641989139276587482219548121559943298597720413308, 6339549671618681027519519656252850510605123925967417829762446658644364679829895793161239924, 5524060340574949278830401572234666614412869483872151575220634608911172030583413793425461418, 3077592347443754032763047320180114925836106157586352811595198459711594082843967794218125900, 2485482705190715196425063262278402318807067325744007477752242695623821244078766589625248523, 709153778431598687411111088573264497719950830216971476223375403360502727783162975846616392, 2127461335294796062233333265719793493159852490650914428670126210081508183349488927539849176, 6382384005884388186699999797159380479479557471952743286010378630244524550048466782619547528, 5652563343372070756371841994954256521036170121828127943964430523711651641239126761800384230, 3463101355835118465387368588338884645706008071454281917826586204113032914811106699342894336, 3642009730364808494298027066754711478416773067347794796446405928828137739980183304999553831, 4178734853953878581030002502002191976549068055028333432305865102973452215487413121969532316, 5788910224721088841225928807744633470945953018069949339884242625409395642009102572879467771, 3872141999882172719949629026710015495435356760179746105586022509206264917121034132580144959, 4869131662505971257984808381868104027604819133524187359724714844107833746909965604711305700, 1112806313236819970226267749080427165411955106542460165107439165301579231823623228075658746, 3338418939710459910678803247241281496235865319627380495322317495904737695470869684226976238, 3267962481990832830172331043461902030006344811867090528933599804203252081959472259651799537, 3056593108831951588652914432123763631317783288586220629767446729098795241425279985926269434, 2422484989355307864094664598109348435252098718743610932268987503785424719822703164749679125, 520160630925376690419915096066102847055045009215781839773609827845313155014972701219908198, 1560481892776130071259745288198308541165135027647345519320829483535939465044918103659724594, 4681445678328390213779235864594925623495405082942036557962488450607818395134754310979173782, 549748360704076837609550197260891953083712954796007759820759984801533176497989346879262992, 1649245082112230512828650591782675859251138864388023279462279954404599529493968040637788976, 4947735246336691538485951775348027577753416593164069838386839863213798588481904121913366928, 1348617064728980811729697929520197815857747485462107601093814222619473756539438779681842430, 4045851194186942435189093788560593447573242456386322803281442667858421269618316339045527290, 5390259245420280403703202667419837884018476222143917452810975320064302804401812224107452693, 2676189061979747407381450605735628734652926372401650444366220593170986404299163086264099725, 1281272848798695320280273118944943745257527970189900376065309096001998208444352465763169998, 3843818546396085960840819356834831235772583910569701128195927288005994625333057397289509994, 4784161302047710980658379372242551248616500584694052427554429180507022871546035398839400805, 857895231862039138246980720203768828446999460052055368596582174499146605731832610459944061, 2573685695586117414740942160611306485340998380156166105789746523497439817195497831379832183, 973762749617805342358747783571976997321743993453447360335886886981358447133356701110367372, 2921288248853416027076243350715930991965231980360342081007660660944075341400070103331102116, 2016570409419701179364651353885850517194444794065975285989629299321265019747073516964177171, 6049711228259103538093954061657551551583334382197925857968887897963795059241220550892531513, 4654545010496216810553704788448769737347500852563675659839958326869463168817388066619336185, 469046357207556627932956968822424294640000263660925065453169613586467497545890613799750201, 1407139071622669883798870906467272883920000790982775196359508840759402492637671841399250603, 4221417214868009651396612719401818651760002372948325589078526522278207477913015524197751809, 5916957307463482052325759459943513496578755971829925810202226883323661429285909779564126250, 4256283248109352353249120983306655572333765621459675516539975282949062278951455752634120396, 6021555407187510157883284251658024258300045717363975592586573165336225832401230464873232011, 4570077547281436669921695358450187857497634858061824863693014128986755488297417808561437679, 215643967563216206036928678826678655090402280155372677012337019938344455985979839626054683, 646931902689648618110786036480035965271206840466118031037011059815033367957939518878164049, 1940795708068945854332358109440107895813620521398354093111033179445100103873818556634492147, 5822387124206837562997074328320323687440861564195062279333099538335300311621455669903476441, 3972572698339418885263065588437086144920082398555084923932593247983978925958093423652170969, 5170423757877709753925118067049315976058996048650203814764427060440975773421143477927383730, 2016682599352035458047196804624063010774485851920509530226575814301005311357156847723892836, 6050047798056106374141590413872189032323457555761528590679727442903015934071470543171678508, 4655554719887225318696613845092682179567870373254483857972476961687125793308138043456777170, 472075485380582152361684138754161621301108825733349659850725518039455371018140544312073156, 1416226456141746457085052416262484863903326477200048979552176554118366113054421632936219468, 4248679368425239371255157248787454591709979431600146938656529662355098339163264898808658404, 5998743768135171211901393048100421316428687147785389858936236303554334013036657903396846035, 4501642630124419831976021747777379031883559149326067662742003543641080030203700124132279751, 10339216092165692199907846808252178248175153948101074159305263901318081704826786338580899, 31017648276497076599723540424756534744525461844303222477915791703954245114480359015742697, 93052944829491229799170621274269604233576385532909667433747375111862735343441077047228091, 279158834488473689397511863822808812700729156598729002301242125335588206030323231141684273, 837476503465421068192535591468426438102187469796187006903726376006764618090969693425052819, 2512429510396263204577606774405279314306562409388561020711179128020293854272909080275158457, 789994194048242711868741624953895484218436081150632105100184700549920558365590447796346194, 2369982582144728135606224874861686452655308243451896315300554101649761675096771343389038582, 362653409293637504954595926323116899264673583340637988868309621438324020837177237137986569, 1087960227880912514863787778969350697794020750021913966604928864314972062511531711413959707, 3263880683642737544591363336908052093382062250065741899814786592944916187534595134241879121, 3044347713787665731910011312462213821444935603182174742411007095323787558150648609696508186, 2385748804222450293865955239124699005633555662531473270199668602460401669998809036060395381, 409952075526803979733787019112154558199415840579368853565653123870244005543290315152056966, 1229856226580411939201361057336463674598247521738106560696959371610732016629870945456170898, 3689568679741235817604083172009391023794742565214319682090878114832196049889612836368512694, 4321411702083160550948170817766230612682976548627908089239281660985627145215701716076408905, 6216940769108934750980433755036749379347678498868673310684492299445920431193968355200097538, 5156233633045710449213143868586363220640533202575918017986771531315839284675631479542034260, 1974112224856037543911274209235204744519097313697652139893609226925595845120620852567844426, 5922336674568112631733822627705614233557291941092956419680827680776787535361862557703533278, 4272421349423244091473310486592957783269373529248767344975777675308440597179314087052341480, 6069969711129185372555852761516930891106869440731251077893980342414360787084805468127895263, 4715320459106462313939400888026907755918106028163651319615235660221160352348142818325427435, 651372703038293138090045267556838350351815790460852044779001613641559048138154868918023951, 1954118109114879414270135802670515051055447371382556134337004840924677144414464606754071853, 5862354327344638242810407408011545153166342114147668403011014522774031433243393820262215559, 4092474307752820924703064827510750542096524048412903294966338201300172290823907874728388323, 5530128586117915872245115784270309167588320998223658927865661920389555868018586831156035792, 3095797084072653813007189956287042585362460700640874869530280394146745595149486907409849022, 2540096915077414537157491170599185297386130954907573651557488498929275780995323929200417889, 872996408091696709608394813535613433457141717707669997639112813276866338532834994572124490, 2618989224275090128825184440606840300371425153123009992917338439830599015598504983716373470, 1109673335684723484611474623558578442413024312353979021718662635980836042342378158119991233, 3329020007054170453834423870675735327239072937061937065155987907942508127027134474359973699, 3239765684021964459639192913765263523015967664170760238434611040316563376628266630050791920, 2972002714925346477053500043033848110346651845497229758270480437438729125431663097123246583, 2168713807635492529296421430839601872338704389476638317778088628805226371841852498340610572, 6506141422906477587889264292518805617016113168429914953334265886415679115525557495021831716, 6023835594438338959939635481032531933645837211259642945936092292225115337670398899007236794, 4576918109033923076090749046573710883535009339748826923741571509653424004104923110963452028, 236165652820675424544089743197247733202525725216378857158009161938350003408495746832097730, 708496958462026273632269229591743199607577175649136571474027485815050010225487240496293190, 2125490875386078820896807688775229598822731526947409714422082457445150030676461721488879570, 6376472626158236462690423066325688796468194580842229143266247372335450092029385164466638710, 5634829204193615584343111802453181472002081448496585515732036749984428267181881907341657776, 3409898938299752949301178010835659498603742051459654633129404882931362792639372135966714974, 3482402477758711946039455334245036037109975007363912942354861965283127373464979614871015745, 3699913096135588936254287304473165652628673875076687870031233212338421115941802051583918058, 4352444951266219906898783215157554499184770478215012653060346953504302343372269361722624997, 6310040516658112818832270947210721038853060287629987002147688177001946025663671292138745814, 5435532875693244652768655445108278199156678568859859092376359163983916068084740290357979088, 2812009952798640154577808938800949680067533412549475363062372124929826195347947285015678910, 1688735521255373561869348118140906581501349090633375132153763691278517581590705062017907553, 5066206563766120685608044354422719744504047271900125396461291073835552744772115186053722659, 1704031017017268253095975666744274316109639521670274275317167854484736225410071972102909623, 5112093051051804759287927000232822948328918565010822825951503563454208676230215916308728869, 1841690478874320474135623604174583927584253401002366563787805323340704019784374162867928253, 5525071436622961422406870812523751782752760203007099691363415970022112059353122488603784759, 3080625635587790463492455041047370430855778314991197160023542543044414169153093879753095923, 2494582569622824488613286424880168833866083797958540523037274945622281503006144846230158592, 736453371727926563975780576378564042897000246860570612078472153355883504565297745661346599, 2209360115183779691927341729135692128691000740581711836235416460067650513695893236984039797, 6628080345551339075782025187407076386073002221745135508706249380202951541087679710952119391, 6389652362372923423617918165697344240816504371205304612052042773586932614356765546798099819, 5674368412837676467125597100568147805047010819585811922089422953738875834164023054336041103, 3528516564231935597648633905180558497738530164727333852201563494194705493585795576949864955, 3838255355555259891081823017279733034514339347166950599571337799073155476304249937820465688, 4767471729525232771381390353577256644841766894485800841680660713708505424459613020432267887, 807826514294604510416013664207885017122798389427300610975276774103594264472565475238545307, 2423479542883813531248040992623655051368395168281901832925830322310782793417696425715635921, 523144291510893691880044279609022695403934357830654541744138283421387375799952484117778586, 1569432874532681075640132838827068086211803073491963625232414850264162127399857452353335758, 4708298623598043226920398516481204258635409220475890875697244550792486382199572357060007274, 630307196513035877033038152919727858503725367397570713025028285355537137692443485121763468, 1890921589539107631099114458759183575511176102192712139075084856066611413077330455365290404, 5672764768617322893297343376277550726533528306578136417225254568199834239231991366095871212] c = 312842359600262511112435880530064569250589001035021284923827012948353613267507190924348823432 n = len(b) w = [] sum = 0 for i in range(n): w.append(2*sum + 1) sum += w[-1] q = sum while True: if isPrime(q): break q += 1 r = ( b[0] * inverse(w[0], q) )% q c = (c * inverse(r, q))%q m = 0 for i in range(n-1, -1, -1): if c \u0026gt;= w[i]: m += 1 \u0026lt;\u0026lt; i c -= w[i] print(long_to_bytes(m)) # sctf{kn4p5ack_Adventur3} ","date":"2023-11-21T10:17:43+09:00","permalink":"https://shibaken28.github.io/my-blog-4/contents/shiba-ctf-writeup/","title":"ShibaCTF Writeup"},{"content":"謝罪 常体と敬体がごっちゃです。ごめんなさい。 エンタメとしてお楽しみください。\n解法を書くのに、公式解説、公式解説放送を主に参考にしています。それだけで理解できなかったものは、他の方のブログを参考にしています。その際は、参考にしたブログのリンクを貼っています。\nABC212-G Power Pair 問題概要 素数$P$が与えられ、$x^n \\equiv y \\pmod{P}$を満たす$n$が存在する$(x,y)$の組$(0\\leq x,y\\leq P-1)$の個数を求める問題。\n素数$P$に対する原始根$r$が必ず存在するため、$x=r^a,y=r^b$とか表現すると、 $$ x^n \\equiv y \\pmod{P} \\Leftrightarrow r^{an} \\equiv r^b \\pmod{P} \\Leftrightarrow an \\equiv b \\pmod{P-1} $$ となるので(最後の変換はフェルマーの小定理より)、$an \\equiv b \\pmod{P-1}$を満たす$(a,b)$の組$(1\\leq a,b\\leq P-1)$を数えれば良い。\nさて、ここからどう数えるかだが、\n$P-1$と$a$の最大公約数が$1$であるような$a$を見つけてきたとき、$n=1,2,\\cdots P-1$のとき$b$は$P-1$通りの値を取る。 $P-1$と$a$の最大公約数が$2$であるような$a$を見つけてきたとき、$n=1,2,\\cdots P-1$のとき$b$は$(P-1)/2$通りの値を取る。 というように、$P-1$と$a$の最大公約数が$g$であるような$a$を見つけてきたとき、$n=1,2,\\cdots P-1$のとき$b$は$(P-1)/g$通りの値を取ることがわかる。\n$a=1,2,\\cdots P-1$のそれぞれに対して$P-1$との最大公約数を取るのは$O(P\\log P)$かかってしまうので、$GCD(P-1,a)$の値が$g$になるような$a$の個数を数えることにする。これは$g$が大きい順に数えるとうまくいく(説明がめんどいのでコードを貼ってごまかす)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 mint ans = 1; map\u0026lt;long,long\u0026gt; mp; for(auto\u0026amp;i:f){ //fはP-1の約数(降順) // GCD(P-1, x) = iとなるxの個数を求める long n = P/i; for(auto\u0026amp;j:f){ if(j\u0026lt;=i)continue; if(j%i==0){ n -= mp[j]; } } mint a = P/i; mint b = n; ans += a*b; mp[i] = n; } 提出コード\n感想 原始根って便利なんですね\nABC212-H Nim Counting 問題概要 長さ$K$の数列$(A_1,A_2,\\cdots,A_K)$が与えられ($1\\leq A_i\\leq 2^{16}$)、ここから$1$個以上$N$個以下の数を選び(重複可能)、それらの選んだ数のXORをとったとき、$0$にならないような選び方の個数を求める問題。\nこの問題ではxorの畳み込みという技術を使います。xorの演算子を$\\oplus$、xor畳み込みの演算子を$*$とすると、xor畳み込みというのは、\n$$ A = (a_1, a_2, \\cdots, a_n) \\\\ B = (b_1, b_2, \\cdots, b_n) \\\\ c_i = \\sum_{x\\oplus y = i} a_x b_y $$ となるようなベクトル$C = A * B = (c_1, c_2, \\cdots, c_n)$を求めることで、$O(n\\log n)$で行えます。すなわち、これでxor畳み込み後に添え字が0$以外の要素の総和を求めることでこの問題は解けそうです。\nHadamard変換 天下り的ですが、 $$ \\begin{aligned} H_0 \u0026amp;= 1 \\\\ H_k \u0026amp;= \\begin{pmatrix} E_{k-1} \u0026amp; E_{k-1} \\\\ E_{k-1} \u0026amp; -E_{k-1} \\end{pmatrix} \\begin{pmatrix} H_k \u0026amp; 0 \\\\\\ 0 \u0026amp; H_k \\end{pmatrix} \\end{aligned} $$ と行列$H_i$を定義します($E_k$は$k$次の単位行列)。このとき、$H_k$は$2^k$次の行列です。 $$ H_k H_k = 2^k E_{2^k} $$ が成り立ちますので、$H_k^{-1} = 2^{-k} H_k$となります。また、 長さ$2^k$のベクトル$A$と$B$に対して次が成り立ちます。 $$ (H_k A) (H_k B) = H_k (A * B) $$ 左辺はベクトルの各要素ごとの積を表しています。これを変形すると、 $$ A * B = 2^{-k} H_k ((H_k A) (H_k B)) $$ が成り立ちます。しかし、これは長さ$2^k$のベクトルと$2^k$次の正方行列の積の計算をする必要がありますので、$n=2^k$として、結局$O(n^2)$かかってしまいます。 しかし、この行列$H_k$とベクトルの積はうまいことに高速化ができます。\n高速Walsh-Hadamard変換 $H_k$を変形します。 $$ \\begin{aligned} H_k \u0026amp;= \\begin{pmatrix} E_{k-1} \u0026amp; E_{k-1} \\\\ E_{k-1} \u0026amp; -E_{k-1} \\end{pmatrix} \\begin{pmatrix} H_k \u0026amp; 0 \\\\\\ 0 \u0026amp; H_k \\end{pmatrix} \\\\ \u0026amp;= \\begin{pmatrix} E_{k-1} \u0026amp; E_{k-1} \\\\ E_{k-1} \u0026amp; -E_{k-1} \\end{pmatrix} \\begin{pmatrix} E_{k-2} \u0026amp; E_{k-2} \u0026amp; 0 \u0026amp; 0 \\\\ E_{k-2} \u0026amp; -E_{k-2} \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; E_{k-2} \u0026amp; E_{k-2} \\\\ 0 \u0026amp; 0 \u0026amp; E_{k-2} \u0026amp; -E_{k-2} \\end{pmatrix} \\begin{pmatrix} H_{k-2} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; H_{k-2} \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; H_{k-2} \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; H_{k-2} \\end{pmatrix} \\\\ \u0026amp;= \\cdots \\end{aligned} $$ この行列の積への分解は高々$O(\\log n)$回で終わります(上記の変形をし続けると最後に$H_0$が対角上に並んだ行列、すなわち単位行列が現れます)。 そして、各分解された行列をよく見ると、各行で$0$ではない要素は必ず$2$つです。すなわち、この分解された行列単体とベクトルの積は、$O(n)$で行うことができ、行列は$O(\\log n)$個しかありませんので、結局$O(n\\log n)$で行うことができます。\nピンと来ないという私のために、$n=8$のときの$H_3$を分解してみます。 $$ \\begin{aligned} H_3 \u0026amp;= \\begin{pmatrix} E_2 \u0026amp; E_2 \\\\ E_2 \u0026amp; -E_2 \\end{pmatrix} \\begin{pmatrix} E_1 \u0026amp; E_1 \u0026amp; 0 \u0026amp; 0 \\\\ E_1 \u0026amp; -E_1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; E_1 \u0026amp; E_1 \\\\ 0 \u0026amp; 0 \u0026amp; E_1 \u0026amp; -E_1 \\end{pmatrix} \\\\\u0026amp; \\begin{pmatrix} E_0 \u0026amp; E_0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ E_0 \u0026amp; -E_0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; E_0 \u0026amp; E_0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; E_0 \u0026amp; -E_0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; E_0 \u0026amp; E_0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; E_0 \u0026amp; -E_0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; E_0 \u0026amp; E_0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; E_0 \u0026amp; -E_0 \\end{pmatrix} \\begin{pmatrix} H_0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; H_0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; H_0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; H_0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; H_0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; H_0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; H_0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; H_0 \\end{pmatrix} \\\\ \u0026amp;= \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -1 \\end{pmatrix} \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 1 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; -1 \\end{pmatrix} \\\\\u0026amp; \\begin{pmatrix} 1 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 1 \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 1 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; -1 \\end{pmatrix} \\end{aligned} $$ これを実装するのにも結構頭を使います。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 template\u0026lt;class T\u0026gt; vector\u0026lt;T\u0026gt; Hadamard(const vector\u0026lt;T\u0026gt;\u0026amp;A,const int k){ // 2^k次行列 if((int)A.size()!=(1\u0026lt;\u0026lt;k)){ cout\u0026lt;\u0026lt;\u0026#34;A size should be 2^k\u0026#34;\u0026lt;\u0026lt;endl; return vector\u0026lt;T\u0026gt;(); } vector\u0026lt;T\u0026gt; res = A; int h = 1; for(int i=0;i\u0026lt;k;i++){ vector\u0026lt;T\u0026gt; tmp(1\u0026lt;\u0026lt;k,0); for(int j=0;j\u0026lt;(1\u0026lt;\u0026lt;k);j+=h*2){ for(int l=j;l\u0026lt;j+h;l++){ tmp[l] = res[l] + res[l+h]; tmp[l+h] = res[l] - res[l+h]; } } h \u0026lt;\u0026lt;= 1; res = tmp; } return res; } template\u0026lt;class T\u0026gt; vector\u0026lt;T\u0026gt; xor_convolution(const vector\u0026lt;T\u0026gt;\u0026amp;A,const vector\u0026lt;T\u0026gt;\u0026amp;B,const int k){ // xor convolution // A,Bのサイズは2^k vector\u0026lt;T\u0026gt; a = Hadamard(A,k); vector\u0026lt;T\u0026gt; b = Hadamard(B,k); vector\u0026lt;T\u0026gt; res(1\u0026lt;\u0026lt;k); for(int i=0;i\u0026lt;(1\u0026lt;\u0026lt;k);i++){ res[i] = a[i] * b[i]; } res = Hadamard(res,k); return res; //これを2^kで割る必要がある } このコードは最後に得た値の各要素を$2^k$で割り算してやる必要があるので注意です。\n問題に戻る 問題で求めたいのは、$C=(c_1,c_2,\\cdots,c_{2^{16}})$($c_i$は$i$個の石がある山の個数)があって、 $$ H(H(C)) + H((H(C))^2) + H((H(C))^3) + \\cdots + H((H(C))^N) $$ です($C^i$は各要素の$i$乗を取ることを意味します)。Hadamard変換は線形変換なので、次のように変形できます。$D=H(C)$とすると、 $$ H( D + D^2 + D^3 + \\cdots + D^N) $$ かなりスッキリしました。あとは、等比数列の和の公式を使って、括弧の中身を計算することができます。\n等比数列の和の公式は $$ \\frac{d_i(d_i^N-1)}{d_i-1} $$ です。$d_i=0,1$の場合はこのまま計算すると値がおかしくなるのでそこだけ別処理することに注意します。\n提出コード\n参考サイト yamate11のブログ xor畳み込み Qiita xor畳み込みと高速Hadamard変換 感想 これのAND版やOR版もあるらしい。考えた人天才。\nABC213-G Connectivity 2 問題概要 $N$頂点$M$辺の単純無向グラフ$G$で、$0$本以上の辺を取り除いて新しいグラフ$H$を作る。各$k=2,3,\\cdots,N$に対して、頂点$1$と$k$が$H$で連結になるような辺の取り除き方の個数を求める問題。\n言い換え 問題で求められている「頂点$1$と$k$が連結(ry」の個数を$C(k)$とします。また、次のように$f(S),g(S)$を定義します。\n$f(S) := $ $S$を頂点集合とする$G$の連結部分グラフの個数 $g(S) := $ $S$を頂点集合とする$H$の部分グラフの個数 すると、次のように$C(k)$を表現できます。ちなみに$V$は$G$の頂点集合です。 $$ C(k) = \\sum_{\\lbrace 1,k \\rbrace \\subset S \\subset V} f(S) g(V\\setminus S) $$ 全ての$f(S),g(S)$が既知ならば、これは$O(N2^N)$で計算できます。\ng(S)の計算 これは簡単です。 辺の両端が頂点集合$S$に含まれるような辺の個数を$E(S)$とすれば、$2^{E(S)}$が$g(S)$になります。 各頂点集合について$M$個の辺がそれぞれ含まれているかどうかを判定するので$O(M2^N)$で計算できます。\nf(S)の計算 問題はこちらです。$f(S)=g(S)-$(頂点集合が$S$であるような非連結なグラフの個数)です。$g(S)$は既知なので、後者を計算する必要があります。 連結でないグラフというのは、連結成分が$2$個以上あるグラフのことです。「この$2$個以上の連結成分」というのを、「$1$つの連結成分があって、残りの使ってない頂点たちを好きなようにしてもらう」という数え方をします。\n$S$に含まれる頂点を$1$つ取ってきて、これを$v$とすると$f(S)$は次のようになります(この$v$がないとカウントが重複してしまいます)。 $$ f(S) = g(S) - \\sum_{ v \\in T \\subsetneq S} f(T) g(S\\setminus T) $$\nこれを$S$についていい感じの順番で計算していくことで、$O(3^N)$で計算できます。\n部分集合の部分集合の列挙 部分集合の$i$の部分集合$j$の列挙は$O(3^N)$でできます。\n1 2 3 4 5 6 for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; N); i++) { for (int j = i; j \u0026gt;= 0; j--) { j \u0026amp;= i; // (i, j) は条件を満たす } } 提出コード\n感想 $f(S),g(S)$に分けて$g(S)$の計算方法考えるのむずくね？？\nABC213-H Stroll 問題概要 問題\nDPで解けそうな問題設定だが、時間が間に合わない。\nDP解 $d_{s,t}$を$t$キロメートル歩いて地点$s$にいる通り数とすると次のように計算できる。 $$ d_{s,t} = \\sum _{(s^\\prime,i,x)} d_{s^\\prime,t-x} \\times p_{i,t-x} $$\nただし、シグマ記号は「$s^\\prime$から$s$に向かう$i$番目の長さ$x$の道」を全てのペアについて足し合わせることを意味する。 これを$t$の小さい方から計算すれば$O(MT^2)$で計算できるがこれだと時間がかかりすぎる。\nシンプルに$N=2$のときを考えると、 $$ d_{1,t} = \\sum_u d_{2,u} \\times p_{t-u} $$ という式になって、畳み込みっぽい見た目をしている。実際には$d_{2,u}$が定数ならば畳み込みで計算できる。\n分割統治FFT 定数ならば畳み込みができるということで、半分を事前に計算して定数にし、いい感じに再帰的に計算するとなんと$O(T\\log^2T)$で計算できてしまうのだ。言葉での説明が難しいので図を用意した。 図は単純に$1$次元のDPを分割統治FFTで解いたものである。\n分割統治FFT ただ、計算に使用する数値は全て確定していなければならないので、以下のような順番で計算する必要がある。\n分割統治FFT(計算順序) 今回は、頂点ごとにDPの値を持つが、全ての辺について上記の図のような遷移があるので、各遷移を全ての辺ごとに行う。計算量は$O(MT\\log^2T)$となる。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void DCFFT(int l,int r,vector\u0026lt;edge\u0026gt;\u0026amp;E,vector\u0026lt;vector\u0026lt;mint\u0026gt;\u0026gt;\u0026amp;p, vector\u0026lt;vector\u0026lt;mint\u0026gt;\u0026gt;\u0026amp;dp){ int m = (l+r)/2; if(l+1==r)return ; DCFFT(l,m,E,p,dp); for(int i=0;i\u0026lt;(int)E.size();i++){ auto [u,v] = E[i]; // [m,r)を更新 /* 本来だったら for(int i=m;i\u0026lt;r;i++){ dp[v][i] += sum_x (dp[u][i-x]*p[v][x]); } をやるが、FFTを使う */ auto dp2u = vector\u0026lt;mint\u0026gt;( dp[u].begin()+l, dp[u].begin()+m ); auto p2 = vector\u0026lt;mint\u0026gt;( p[i].begin(), p[i].begin()+r-l ); auto dp3u = convolution(dp2u,p2); for(int j=m;j\u0026lt;r;j++){ dp[v][j] += dp3u[j-l]; } } DCFFT(m,r,E,p,dp); } 提出コード\n感想 添字をミスりまくってめっちゃ時間かかった。 地味に赤diff初AC。\nABC214-G Three Permutations 問題リンク 包除原理 条件が扱いづらいので、包除原理を使います。\n$f(x)$を、$x$個の相異なる添字を選んだときに、その添字で$p_i=r_i$または$q_i=r_i$となるような$r_i$の割り当て方の個数とする。 すると、包除原理により、求める答えは $$ N! + \\sum_{x=1}^N (-1)^x f(x) (N-x)! $$ となります。$(N-x)!$は残りの$N-x$個の添字に対する割り当て方の個数です。\nこの数え方にすぐに納得しない私は具体例を考えてみました。\n$N=3, p=(1,2,3), q=(2,3,1)$のとき $r=(3,1,2)$の$1$通りだけであるが、これを上記の計算式で求める。 $f(1)$について $i=1$を被らせるとき、$r_1=1,2$のどちらかで$2$通り $(1,3,2),(1,2,3),(2,1,3),(2,3,1)$の$4$通りがある $i=2$を被らせるとき、$r_2=2,3$のどちらかで$2$通り $(2,1,3),(2,3,1),(3,1,2),(3,2,1)$の$4$通りがある $i=3$を被らせるとき、$r_3=3,1$のどちらかで$2$通り $(3,1,2),(3,2,1),(1,2,3),(1,3,2)$の$4$通りがある $f(1) = 2+2+2$ ここで注目したいのが、例えば$(1,2,3)$という順列は$i=1$と$i=2$のパターンの両方に含まれているということである。ここで$2$回取り除かれている順列は、$f(2)$以降で調整されていくのが包除原理である。 $f(2)$について $i=1,2$を被らせるとき$(1,2,3),(1,3,2),(2,3,1)$の$3$通りがある $i=2,3$を被らせるとき$(1,2,3),(3,2,1),(2,3,1)$の$3$通りがある $i=3,1$を被らせるとき$(1,2,3),(2,1,3),(2,3,1)$の$3$通りがある $f(2) = 9$ ここで、$(1,2,3),(2,3,1)$のパターンは逆に足しすぎていので、$f(3)$で調整する。 $f(3)$について $i=1,2,3$を被らせるとき$(1,2,3),(2,3,1)$の$2$通りがある $f(3) = 2$ よって、$3! - 6\\times 2! + 9\\times 1! - 2\\times 0! = 6 - 12 + 9 - 2 = 1$となり、正しく計算できていることがわかる。 グラフに変換 グラフを使います。頂点を$N$個用意して、頂点$p_i$と$q_i$を繋ぐ辺を張ります。\n辺を張る ここで注意するべきは、連結成分は必ずサイクルになります。なぜなら、$p,q$はどちらも順列であるので、同じ数がちょうど$2$回出現する$\\Leftrightarrow$頂点の次数が$2$であるからです。\n「各辺は、その両端の頂点番号を使ってはいけない」ことを示します。 次の画像は被らせる添字とグラフの対応を表したものです(画像には「サイクル」とありますが、「連結成分」と書くべきでした)。\n被らせる添字を選ぶ 元のグラフの連結成分ごとに、$k$個の辺を選ぶ(=$k$個の数を被らせる)方法の場合の数をそれぞれ計算すれば、DPによって$f(x)$を計算できます。 次の節ではそれぞれの連結成分で、$k$個の辺を選ぶ方法の場合の数を計算する方法を説明します。\nDPで計算 サイクル状の頂点と辺を、$v_1,e_1,v_2,e_2,\\cdots,v_y,e_y,v_1$と割り振ります。\nDP[$i$][$j$] $:=$ $i$番目までの辺を使って、$j$個の辺を選んだときの場合の数 しかし、これだと情報が不十分です。辺$e_1$を選ぶと$v_1,v_2$のどちらかを選べます。$e_1$が$v_2$を選んだ場合、$e_2$は$v_3$を選ぶしかありません。逆に、$e_1$が$v_1$を選んだか、$e_1$を選んでいない場合は、$e_2$は$v_2,v_3$の$2$つの選択肢から選ぶことができます。よって、この情報を追加します。\nさらに、円環なので、一番初めの頂点$v_1$が使われたという情報によって、$e_y$が$v_1$が選べるかどうかが決まります。よって、この情報も追加します。\nDP[$i$][$j$][$k$][$l$] $:=$ $i$番目までの辺を使って、$j$個の辺を選んだとき、$i$番目の辺が$v_{i+1}$を選んだ/選んでいない($k=0/1$)、$v_1$を使った/使っていない($l=0/1$)の場合の数 こちらのDPですが、遷移が多いので注意深く実装します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 mint dp[3001][3001][2][2]; vector\u0026lt;mint\u0026gt; f(int n){ if(n==1){ return vector\u0026lt;mint\u0026gt;{mint(1), mint(1)}; } rep(i,3001)rep(j,3001)rep(k,2)rep(l,2)dp[i][j][k][l] = mint(0); // nはサイクルの長さ // dp[i][j][k][l] := // i番目までの辺を見て、j個使ったとき、 // k=0: 直前を使っていない k=1: 直前を使った // l=0: 0を使っていない l=1: 0を使った dp[0][0][0][0] = 1; for(int i=1;i\u0026lt;=n;i++){ for(int j=0;j\u0026lt;=n;j++){ if(i==1){ // 使わない dp[i][j][0][0] += dp[i-1][j][0][0]; if(j\u0026gt;0){ // 前を使う dp[i][j][0][1] += dp[i-1][j-1][0][0]; // 後ろを使う dp[i][j][1][0] += dp[i-1][j-1][0][0]; } }else if(i==n){ // 使わない dp[i][j][0][0] += dp[i-1][j][0][0]; dp[i][j][0][0] += dp[i-1][j][1][0]; dp[i][j][0][1] += dp[i-1][j][0][1]; dp[i][j][0][1] += dp[i-1][j][1][1]; if(j\u0026gt;0){ // 前を使う dp[i][j][0][0] += dp[i-1][j-1][0][0]; dp[i][j][0][1] += dp[i-1][j-1][0][1]; // 後ろを使う dp[i][j][1][0] += dp[i-1][j-1][0][0]; dp[i][j][1][0] += dp[i-1][j-1][1][0]; } }else{ rep(l,2){ // 使わない dp[i][j][0][l] += dp[i-1][j][0][l]; dp[i][j][0][l] += dp[i-1][j][1][l]; if(j\u0026gt;0){ // 前を使う dp[i][j][0][l] += dp[i-1][j-1][0][l]; // 後ろを使う dp[i][j][1][l] += dp[i-1][j-1][0][l]; dp[i][j][1][l] += dp[i-1][j-1][1][l]; } } } } } vector\u0026lt;mint\u0026gt; res(n+1, mint(0)); rep(j,n+1){ rep(k,2){ rep(l,2){ res[j] += dp[n][j][k][l]; } } } return res; } 提出コード\nABC214-H Collecting 問題概要 問題リンク\n$K$人で分担して有向グラフ上の落とし物をできるだけ多く拾う問題。\n最小費用流問題 強連結成分にある落とし物はすべて取るのが最適なので、強連結成分一つをまとめて1つの頂点として考えた新しいグラフを作ります。そのグラフはDAGになります。(このとき、頂点$1$から辿ることができない頂点とその頂点から出てる辺は無視します)。\nサンプル$1$の場合、次のようなグラフを作り$S$から$T$へ$K=2$だけ流せば最小コストの符号を取ったものが答えとなる。\n最小費用流 しかし、負辺があるので、(私が知っている)アルゴリズムが適用できない。\n負辺を取り除いたものがこちらです。 負辺を取り除く SからTまでグラフにそって適当なルートを通ったときに、通った辺のコストが「全体の落とし物のうち拾えなかった個数」を示しています。\nこのようなグラフは、強連結成分分解後に$M$頂点にしてトポロジカル順に頂点番号をつけたグラフについて、次のような操作によって機械的に構築できます。\n各頂点$u$ごとに$i_u$と$o_u$を用意して、$i_u$から$o_u$に$(1,0)$と$(\\infty,X_u)$の辺を張る。$X_u$ 辺$(u,v)$に対して、$o_u$から$i_v$に$(\\infty, X_{u+1}+X_{u+2}+\\cdots+X_{v-1})$の辺を張る。 $S$から$i_1$に$(K,0)$の辺を張る。 各頂点$u$ごとに、$o_u$から$T$に$(\\infty,X_{u+1}+X_{u+2}+\\cdots +X_M)$の辺を張る。 各頂点について容量が$1$の辺があるのは、一人だけ「$X_u$を拾えなかった」ことを回避できるからです。 よって、求まったコストを$K\\sum_u X_u$から引けば答えになります。\n提出コード\n参考サイト kmjp\u0026rsquo;s blog 2021-08-16 AtCoder ABC #214 : H - Collecting 感想 フローのこういうテクニックは覚えていきたい。\nABC215-G Colorful Candies 2 $N$個のキャンディがあり、$i$番目のキャンディの色は$C_i$である。 $K=1,2,\\cdots,N$について、$N$個のうち$K$個のキャンディを選ぶ(同様に確からしい)とき、キャンディの種類数の期待値を求める問題。\n式を作る とりあえず$K$を固定して考える。確率変数$X_i$を種類$i$のキャンディを$1$以上選ぶとき$1$、選ばないとき$0$とすると、答えは次の式で求められる。 $$ E\\left[\\sum_i X_i\\right] = \\sum_i E\\left[X_i\\right] $$ 線形性で右辺に変形できる。その種類のキャンディが$m$個あった場合に$1$つ以上選ぶ組み合わせは$_N \\text{C} _K - _{N-m} \\text{C} _K$通りと二項係数で計算できる。\nこの計算方法だと、各$K$について最大$N$種類の計算をすることになるので、$O(N^2)$かかりそうだが、ちょうど$x$個ある種類のキャンディをまとめて数え上げれば$O(N\\sqrt(N))$になる(詳しくはコード、計算量の節を参照)。\nメインの実装自体はかなり簡潔。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int main(void){ std::cin.tie(0)-\u0026gt;sync_with_stdio(0); int N;cin\u0026gt;\u0026gt;N; Combination\u0026lt;mint\u0026gt; comb(N+1); map\u0026lt;int,int\u0026gt;mp; rep(i,N){ int c;cin\u0026gt;\u0026gt;c; mp[c]++; } map\u0026lt;int,int\u0026gt; mp2; for(auto\u0026amp;[k,v]:mp){ mp2[v]++; //v個あるキャンディの種類数 } for(int k=1;k\u0026lt;=N;k++){ mint ans = 0; for(auto\u0026amp;[m,a]:mp2){ mint A = a; ans += (comb.com(N,k) - comb.com(N-m,k)) / comb.com(N,k) * A; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } mapを使っているため定数倍が重め。\n提出コード\n計算量について $a_i$を種類$i$の個数だとすると、種類数(キャンディが$1$個以上ある)が$M$個、キャンディの総数が$N$個のとき、次の条件たちを満たす。\n$a_1+a_2+\\cdots+a_M=N$ $1 \\leq a_i \\leq N$ 計算量は、$a_i$の種類数を$D$とすると、$O(DN)$である。$D$は高々$O(\\sqrt N)$にしかならないというのがミソである。\nなぜなら、$D$をできるだけ大きくしようとすると、$a_i$はできるだけ小さくするべきなので、 $a_1 = 1, a_2 = 2, \\cdots$と設定していくべきであり、$1+2+3+\\cdots+D = O(D^2) = O(N)$となる。\n感想 今回の記事の中ではかなり簡単に見えるが、$X_i$の定義を思いつくところは経験値が必要だと思った。\n","date":"2023-08-20T12:08:30+09:00","permalink":"https://shibaken28.github.io/my-blog-4/contents/high-typical/","title":"[WIP]ABCの高度典型を解いてうはうはしたい"},{"content":"はじめに 受験を終えてテンションがクルクルクロックルなときに執筆したため、文章がフワフワチョコランタです。ご了承ください。 真面目ver.はお世話になったZENPENに投稿する予定です。\n受験先で遊ぶのはけしからん！勉強しなさい！という思想の方はこの記事を読むことをおすすめしません。\n書こうと思っていたことと、書きながら思いついたことを全部だらだらと書いたので、めっちゃ長くなりました。蛇々足々です。\n自己紹介 長野高専 電子情報工学科 情報系の学科です。\n受けた大学 次の大学を受けました。上から順に志望順です。\n筑波大学 情報学群 情報科学類 (情報メディア創成学類を併願) 東京農工大学 工学部 知能情報システム工学科 山梨大学 工学部 コンピュータ理工科 結果は全て合格でした。ありがとうございます。\n山梨大学 行動 おもいっきり地元です。実家から徒歩で行ける距離にあります。 最寄り駅は甲府駅です。すぐ近くにヨドバシカメラがありますが、それ以外はマジでなにもないです。 甲府駅から山梨大学は1.5kmくらいで十分徒歩でも行けますが、登り坂になるのでバスを使うのがいいと思います。30分～1時間ごとに1本出てます。\n山梨大学に受験する人におすすめなのが、武田神社です。 名前の通り、戦国武将であるあの武田信玄が祀られている神社です。 山梨大学から2kmくらい上ったところにあります。勝運を肖りましょう。 境内自体はかなりコンパクトなのですぐ見終わります。 あと、近くで売っている信玄ソフトがめっちゃウマいです。 信玄餅をモチーフにした、きなこと黒蜜とソフトクリームの組み合わせ、マズいわけがない。 不穏なサジェスト なお、甲府盆地は扇状地となっていて、基本的には坂道で甲府駅は海抜280mくらいなのですが、武田神社は340mくらいあります。頑張りましょう。 あと、盆地は暑いです。受験当日はまだ6月でしたが、ワイシャツが汗でびっしょりになりました。\n*三年次編*入学試験 大学すぐ近くにはローソンとセブンイレブンがあります。昼食はそこで済ませました。\n試験 専門 プログラミング、計算機アーキテクチャ、情報数学のうち2科目を選択します。私はプログラミングと情報数学を選択しました。 端から計算機アーキテクチャを選択するつもりはありませんでした。\n山梨大学の過去問は公式ホームページで公開されています。あと、僕が過去問を解きまくった記事が存在します。以下にリンクを貼っておきます。\n山梨大学コンピュータ理工科過去問を解く\n傾向とかは上の記事で説明しているので、詳しくは書きませんが、3つの選択問題はどれも出題範囲が広めなため、対策は簡単ではありません。 例えば、過去問のプログラミングの問題を見ると、次のような問題が出題されています。\n令和3年度出題 平成29年度出題 このように、アルゴリズムや構文に関する問題の他に、コンパイラの処理やホワイトボックステストについて問われた過去があります。 「たまたま自分の知らない問題」が出題される可能性に怯えながら試験を迎えるのはとてもに怖いものです。\n幸い、プログラミングの問題は全部アルゴリズム関連の問題だったので助かりました。でも、プログラミングの問題のソースコードが全てC++で書いてあったのは驚きました(といってもC++特有の書き方はcin,coutくらいで、vectorとかは使わずにCでも使える配列を使っている。また、過去問ではCとC++の両方で書かれていたので、C++に移行することを暗示していたのかもしれない)。あと、ワーシャルフロイド法が出たので競プロやってて良かった～～～になりました。\n情報数学は、行列の累乗(対角化)、情報エントロピー、ハフマン符号化、離散確率(ベイズの定理)の問題が出ました。どれも射程圏内でした。 過去問にはグラフ理論の問題があったのが怖かったのですが、今年度は素直でした。\n私が受けた年のプログラミングの第1問を以下に再現しておきます(細かい部分はうろ覚えなので少し違うかもしれない)。\n次のプログラムを実行するとどうなるか。\n1 2 3 4 5 #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ cout \u0026lt;\u0026lt; \u0026#34;/(^o^)\\\u0026#34; \u0026lt;\u0026lt; endl; } (1) /(^o^)\\と出力される。 (2) /(^o^)\u0026quot;と出力される。 (3) /(^o^)\\\u0026quot;と出力される。 (4) そもそも、コンパイルできない。\n／^o^＼ﾌｯｼﾞｯｻｰﾝ　ﾌｯｼﾞｯｻｰﾝ\n＼＼(^o^) ﾀｶｲｿﾞ\n(^o^)／／　ﾀｶｲｿﾞ\n／^o^＼ﾌｯｼﾞｯｻｰﾝ\n面接 面接の順番はおそらく遠い人からです。 待ち時間が暇なので、たまたま学校から借りていた楕円曲線論入門の本を読もうとしましたが、内容が難しすぎて全然時間が潰せませんでした。そもそもこういうのは本単体で読むものじゃないですね。\n『楕円曲線論入門』 3人の面接官がいました。\n訊かれた内容は\n志望理由 高専の授業で面白かったやつ 最近気になったニュース 合否には関係ないが、何か私達(大学側)に質問はありますか でした。10分ほどで終わりました。雰囲気は良かったです。\n面接の詳しい話は後ろの方で全大学まとめて書きます。\n東京農工大学 1日目：午前に数学と英語、午後に理科 2日目：午前に専門、午後に面接 行動 おちこぼれフルーツタルトの第5話8分52秒あたりに出てくる大学です。\nほぼ同じ画角で登場する。おしゃれ。 最寄りの東小金井駅から徒歩数分でつく駅近大学です。さらに東京なので立地が神がかっています。 農工大は小金井キャンパスと府中キャンパスの2つありますので間違えないように注意しましょう。\nおちフルOPで映る北口 おまもり 吉祥寺にある東急REIホテルに泊まりました。前泊含め2泊です。ちゃんと部屋が明るくできるタイプのホテルです。\n明るい 長野→大宮→新宿→吉祥寺というルートで来ました。ところで長野駅さん、Suicaの導入はいつになったらするんですか。\n画像はJR東日本より。東小金井はJR中央線の駅ですが、通勤快速以上の列車は止まってくれないそうです(止まってくれるのは各駅停車、快速のみ)。\nホテルに着いた後はせっかくなので吉祥寺駅周辺をウロウロしました。吉祥寺サンロード商店街というアーケード街があり、20時21時でも人がまあまあいて明るかったです(田舎者並感)。時間感覚が狂います。 ロフトが入っている建物の地下一階にゲーセンがあったのですが、太鼓の達人が大量にありました。 📢【吉祥寺店】\n「プラサカプコン吉祥寺店」に\n人気アーケードゲーム「太鼓の達人」 が増台しています🎵\nなんと全部で12台ご用意しました‼️\n設置台数が日本最大級になります☺️\nみなさまのご来店お待ちしております😃#カプコン #吉祥寺 #プラサカプコン #太鼓の達人 pic.twitter.com/Nh8wup2t4g\n\u0026mdash; カプコンアミューズメント (@Capcom_amuse) May 16, 2022 あと、同じ場所にルイージマンションの筐体が置いてありました。珍しい。遊んでくればよかった。\n吉祥寺ラウワンはボルテが4台。ヘッドホンの貸出もしていました。 ホテルは朝食付きで、和食か洋食のプレート選択+和洋共通のバイキングでした。ただ、食堂が7時開店で、特に1日目はあんまりゆっくり食べられませんでした。 和食。写真を取るのが下手。 ごはんと味噌汁。寮食よりうまい。 洋食。容器の角にパンを乗っけていてマナーが悪い。 こういう食堂で食べる朝食は、自室で食べるのに比べて人の目に付きますし、しっかり目が覚めて良いですね。\n親に「宝華」というお店の油そばがめちゃくちゃウマいとおすすめされたのですが、寮の門限という制約と時間が噛み合わずに行けませんでした。悲しい。\n宝華も農工大も駅に近い 試験 数学 農工大の数学は簡単です。毎年、偏微分、重積分、行列の固有値、微分方程式の基本的な問題が出題されます。 ほとんどの人が満点を取るであろう科目、計算ミスが非常に怖いです。計算量はそれなりにあるので時間たっぷり使って見直しをしました。\n以下に検算に使える知識を列挙しておきます(ほぼ自明ですが)。\n偏微分\u0026hellip;(関数が連続であれば)$\\partial^2 f /(\\partial x \\partial y)$と$\\partial^2 f /(\\partial y \\partial x )$は等しい 重積分\u0026hellip;逐次積分とか計算順序変更とか(できないこともあるが)いろんな手法で計算 固有値\u0026hellip;単純に固有ベクトルと固有値の性質($A\\bm{x}=\\lambda \\bm{x}$)を満たしているかをチェック。 微分方程式\u0026hellip;答えの関数を微分して代入して解になっているかを確かめる。 行基本変形は計算ミスの巣窟ですので変形するたびに2回は見直しました。 また、\n行基本変形により各列ベクトルの一次関係は変わらない という性質は階段行列への変形が合っていたかの確認にとても便利です。\n英語 長文が2つ(全て選択問題)と、英文の穴埋め出題。 英文の穴埋めというのは、英検とかの自由英作文の解答例があったとして、その解答の部分部分のフレーズ(数単語)を虫食いにして、そこに入りそうな数単語を書け(唯一の正解は決まっておらず、意味が通れば正解)、というものです。自由英作文の代わりとなるような問題ですが、いつもの英作文に対して自由度が下がるため、「知っている簡単な単語だけでどうにかする」という突破法が使いづらいです。\n私は英語の対策を全くしておらず、「TOEIC830点パワーで行けるやろ！」と高を括っていたのですが完全敗北しました。 薄々気づいてはいましたが、TOEICはマジでTOEICでしかなく(そもそも得点はリスニング\u0026gt;リーディングだったし)、受験英語などとは全く違いますね。 TOEICでは「文章の意味を曖昧でいいからとにかく素早く読む」という方法を取っていたため、かなり細かい違いまで訊かれるT-F問題とか全部Trueに見えました。 自信を持って答えた問題はなく、体感1～4割くらいです。\n物理 物理は他の科目の半分の配点しかありません。 私が受ける大学の中で物理の試験があるのはここだけで、しかも他の科目に比べて半分の配点、加えて力学だけではなく電磁気もある、ということでモチベーションが全然湧きませんでした。物理はあまり好きではないので物理の勉強が一番苦痛でした。\n力学は剛体で、回転運動と並進運動が両方起こっていて、滑りながら運動している円柱の問題が出題されました。 こう書くと難しそうに見えますが、結構シンプルな問題で、微分方程式も一次のものしか出てこず、かなりすんなり解けてしまったため逆に怖かったです。 周りの様子を伺ったところ、他の受験生も同じような感想を持っていたようです。\n電磁気はクーロン力、電場、電位についての問題でした。 結局電磁気のソレノイドとかそこらへんがあまりわかっていないまま受験当日になったのですが、運が良かった。 終盤は、等電位線の方程式を求める数学の二次曲線みたいなの問題が出題され、ちょっと悩みましたが、なんとか解けました。\n専門 時間が120分もあります。要項には、「計算機基礎」「論理回路または電気電子回路から選択」「数理・情報工学または電磁気学から選択」と書いてあります。 私は、論理回路と数理・情報工学を選択しました。\n計算機基礎は例年通り基数変換やビット演算について出題されました。あとは確率の平均(期待値)と分散についての問題が出ました。\n論理回路はフリップフロップを使った回路が出できました。過去問では毎回真理値表を埋めてカルノー図を作る問題が出題されていたのですが、 急にフリップフロップ、しかもなんか知らない名前がついている回路で問題の意図がさっぱりでした。時間をフルに使って問題の意図なんとか汲み取り、解答欄を埋めました。 一瞬電気回路に逃げようかと思いましたが、ラプラス変換とか書いてあって意味不明だったのでやめました(電気科の人曰く基本的な問題だったらしい)。\n「数理・情報工学」=プログラミングはヒープソートの実装について出題されました。ソートのなかでは難しい方ですし、それなりに難易度はあったと思います。\n面接 2日目の最後に面接があります。1日目の帰り際に、「面接を円滑に進めるためのアンケート(Googleforms)」が配れられ、20:00までに回答しろと言われました。 「回答内容は合否に一切関係がありません」とも言われました(じゃあなんで回答必須なんだ\u0026hellip;)。\n内容は、\n志望理由はなんですか。 第何希望ですか。併願大学はどこですか。 気になる研究室はありますか。 修士、博士、どこまで決めてますか。 どこで農工大を知りましたか。 オープンキャンパスに参加しましたか。 webサイトは閲覧しましたか。 これまでにハードウェアを作成したことはありますか。 これまで100行以上にわたるプログラムを書いたことはありますか。 自慢できることを書いてください などの質問攻めで、合否に関係ないとはいえ、流石に雑な回答をするわけにもいかないので結構時間がかかりました。 私はパソコンで回答しましたが、スマホしか持っていなかったらかなり厳しかったです。\nなるほど、ここに書いた内容について、面接管が気になったことを、さらに踏み込んで訊いたりするのかな、と思ったのですが、実際は違いました。 面接管は事前アンケートに書いてあった内容を、あたかもアンケートの回答を知らない体で質問してくるのです(本当に知らないのかもしれませんが、もしそうだったら円滑に進めるための意味がないじゃないか)。私は完全にアンケートの内容を知っていると思っていたので、困惑してカタコトな受け答えになってしまいました。 特に意味のあることを話すこともできず、歯切れの悪い会話が続き、最悪の空気で面接が終わり、最悪なテンションで帰りました。\nそもそも、面接で訊かれる質問が、アンケートという形で事前に公開されたというのなら、完全に「合否に一切関係ない」というのはちょっと無理があるのではないかと思いました。フェアな受験のためにも、アンケートの利用方法について明示して欲しかったです。 受験生目線で言えば、フォーム形式で面接の質問に答えるのは非常にやりやすく、自己アピールもしやすいので、合否に関係あるのであればそれはそれで良いと思います(事前に告知されていないのに合否に関係させるのはアンフェアではないか、という意見もあるとは思うので、そもそもアンケートを実施するべきではないのかもしれない)。\n面接の順番は遠い順で、長野の私は3番目でした。\n筑波大学 行動 JR新幹線で長野→大宮に来たのですが、野田線こと「東武アーバンパークライン」を探すのに時間がかかりました。 JRの改札に間違えて入ってしまい、入場料140円を取られました(笑)。東武アーバンパークラインで「流山おおかたの森」までいき、そこからつくばエクスプレス(TX)でつくば駅に行きます。ちなみにどれもICカードが使えます。長野駅さん(以下略)。\nところで、「東武アーバンパークライン」って長いですよね。 そもそも、都会を意味するurbanの発音は\u0026quot;ə́ːrbn\u0026quot;ですし、\u0026ldquo;ə\u0026quot;はアとエの中間みたいな曖昧母音な音なので、「アーバン」というカタカナを認識しずらいんですよね(?)。 というか、最初に「バンパー」の部分に目が行くので、略して「東武バンパー」と呼ぶことにしました。\nTXは他の路線より割高と聞きますがどうでしょうか。私が乗った列車では、東武バンパー「大宮→流山」で1時間17分を540円に対し、TX「流山→つくば」で8分を740円です。高すぎやねん！と時間と値段のギャップでツッコみたくなりますが、これは罠で、距離を出すと38.4kmと31.8kmです。東武バンパーで乗ったのは各駅停車で、TXは区間快速ですし、割と妥当とも思えます。\nTX快速で筑波→秋葉原の58.3kmを1210円で45分 気軽にアキバに遊びに行ける！\nつくばと言えば、「学園都市！」「研究所！」みたいなイメージで遊ぶ場所ないんじゃないかとちょっと心配でしたが、駅前にはショッピングモールがありましたし、何よりゲーセンも見つかったので全然問題なさそうです。 夕食は24時間営業のラーメン屋で食べました。 写真だと分かりづらいがネギたっぷりのラーメン つくばの街の雰囲気ですが、とにかく道路が広くて交通量が多い印象です。自転車や自動車メインの生活で、徒歩での移動は向いてない気がしました。\n筑波大(春日エリア)から1kmくらい離れたホテルグランド東雲というホテルに泊まりました。 内装は普通のビジネスホテルですが、部屋がそこまで明るくなりません。本当に寝るためだけというか、作業をするのには向いていません。 前日ホテルでもガッツリ勉強をしたいという人は、外で明るい勉強場所を見つける必要が出てきます。\n試験 筑波大学は、次の条件を満たす人にとっては非常に有利な入試形態です。\n数学がまあまあ得意 競プロをやっている TOEICで十分高いスコアを取得している 情報科学類の試験内容は、数学、情報基礎、英語の3つで、英語はTOEICのスコア提出が試験の代わりになります。\n情報基礎はプログラミングで、アルゴリズムの問題が出題されます。 特に競プロチックな問題が出題されるので、競プロをやっている人はほぼ対策なしで満点が狙えます。\n試験は数学と専門を同時に120分1発勝負です。専門→数学の順で解きました。\n専門 大問1ではフィボナッチ数列に関する問題が出ました。 プログラミングではベタな話題ですが、行列を用いて$O(\\log N)$まで高速化する問題でした。\n競プロでは行列累乗と呼ばれるテクニックですが、以前自身でまとめたこともあり、「これAtCoderでやったやつだ！」となりました。\n以前書いた記事→ 行列累乗まとめ\n大問2では、グラフの幅優先探索をする問題が出ました。 これも競プロでinf回書いたコード(データ構造とかは自分で実装していないけど)なのですんなり解けました。\n数学 筑波の数学は難しいです。編入数学過去問特訓(黄色い本)でもC問題で猛威を振るっていました。 例年微積分と線形代数の2題が出題されていて(変な漸化式の年もあったが)、少なくともどちらかが難問、というイメージです。 特に、極限をイプシロン-エヌ論法で証明させる問題が少なくとも過去に2回出題されていて、過去問を解くときには数学の先生に何度か質問しに行きました。\nということで、過去問で特に苦戦した問題を紹介します。\nまず、イプシロン-エヌ論法の問題です。数学の先生にききにいったら、「無理だね！」と言われました。 平成29年度 数学1(3) 次は線形代数の問題です。慣れてしまえば基本的な問題なのかもしれませんが、抽象的な問題設定の理解に時間がかかりました。 平成31年度 数学2(2) これは意味不明な問題です。解答例を読んだのですが、あんまりわかりませんでした。 令和4年度 数学1(2) ちなみに同年の数学1の(1)もガウス積分の一般化みたいな難しい問題です。恐ろしいですね。\nこれ以外にも、陰関数の偏微分だったり、2変数関数のテイラー展開を要求してきたり、普通に旧帝大レベルに匹敵する難易度のこともあると思います。\nそんな中で、恐らく今回はここ数年で最も易化した年だと思います。\n数学1(1)：$\\tan ^{-1} x$の第3次導関数を求めよ 数学1(2)：$\\tan ^{-1} \\frac{1}{2}$を〇〇と近似したときに誤差が△△以下になることを示せ 数学の大問1は、微分に関する問題ですが、(1)は微分するだけ、(2)はマクローリンの定理を使って剰余項に代入とかして不等式で示すと解けます(たぶん)。 (1)は計算ミスが超怖い。(2)は後回しにしていたら時間がなくなってしまいました(マクローリン展開した結果を書いたところで時間切れ)。\n数学の大問2は行列の問題で、対角化と行基本変形できますか？みたいな問題でした。最後は係数に文字を含んだ連立方程式を場合分けして解く問題で、ゴリ押しでも解けるとは思いますが、それまでの問題の結果を利用するとちょっと楽になるタイプの問題でした(たぶん)。\n全体的に計算量で時間を削ってくるタイプの問題で、解くことができても計算ミスがあるかもしれないから安心できない、言い方は悪いですがいやーな問題でした。 徹底研究とか過去問特訓の問題集を解いているときに、この計算量の問題を本番で解かされるきついな\u0026hellip;みたいな問題に出会うことがありますが、まさにそれを体験しました。\n正直数学がどれくらい取れたかは未知数です。\n後輩へのアドバイス 編入試験の流れ ステップ1：大学に願書と成績証明書等を送る 近年はwebで情報登録+書類郵送という形式もある。 願書は大学のwebサイトからダウンロードできる場合、取り寄せが必要な場合がある。 成績証明書は学校の学生課(的存在)で発行申請できる。調査書、在学証明書、卒業見込証明書も同様。 ステップ2：大学から受験票が送られてくる これで受験番号が割り振られる。 ステップ3：試験を受ける 2日間に渡る場合や、思いっきり平日に試験がある場合もあるので、公欠届けやスケジュール管理に注意。 大学を調べるときはメモしよう まずはどの大学に行くかを決める必要がありますが、受験をするにあたって重要な要素は以下の通りです。\n出願期間 受験日 合格発表日 確約書、入学手続きの日程 日程は、併願を検討する際に非常に重要です。当然、合格直後に入学手続きをしなければならない場合は、それよりあとに合格発表がある大学と併願することができません。よく確認しましょう。 面接の有無 受験科目 科目やTOEICの有無だけではなく、数学であれば、複素関数や確率統計は出題されるか、専門であれば、選択問題の内容はどのようなものか、なども確認しましょう。勉強を始めるときに必要になります。 これらはそのときに確認するだけではなく、それをメモとしていつでも一覧で参照できるような状態にしておくべきです。\n私は大学ごとを行として、上記の情報を列にした表を作りました。ExcelとかGoogleスプレッドシートなどで作ると良いでしょう。友達と共有するのもアリです。 大学のホームページのURLも保管しておきましょう。要項はダウンロードしましょう。\n過去問の入手方法 公式で過去問を公開していないか。 公開している場合、webarchiveを使ってさらに過去の問題を参照できる可能性が高い1。 学校の進路相談室に尋ねる。 先輩に尋ねる。 編入コミュニティに参加する。 その他 出願したらホテルを予約しよう！1ヶ月以上前とかに予約しよう！ TOEICは早いうちから受けておこう 成績証明書や調査書の発行には時間がかかる場合があるので、早めに申請しよう！ ネットで閲覧できる願書は実はサンプルで、実際は願書の取り寄せが必要な場合があるので要項をちゃんと読もう！ 面接はワイシャツで行こう！逆にペーパーテストだけであれば私服でも良い(私は筑波は私服で行きました)。 受験生のみなさまへ 過去問が欲しいとか、質問等があれば、何かしらの手段で連絡してもらえればできるだけ対応します。編入学は情報が少ないので、少しでも役に立てれば幸いです。\n面接 高専のアルゴリズムとデータ構造という授業の円周率を求める課題で熱中した 高専プログラミングコンテストやAtCoderにも積極的に参加した 数理技術アルゴリズム系の研究をしたい 志望理由は「アルゴリズム関係の行きたい研究室があるから」 というストーリーを用意して、あとはその場のノリとノリで話す予定でした。\n気になるニュースを訊かれたときは、「AI技術がたくさん出てきているが、ChatGPTによる学校の課題の代行や、画像生成AIによる著作権問題など、技術に時代が追いついていないと感じています」と答えました。\n「ChatGPTで面接練習をしました」と言ったらウケました。\n合格発表 梨大：一番最初の結果発表だったので緊張しました。 農工大：第2希望だったので緊張しました。 筑波大：本命だったので緊張しました。 これは大学編入全般に言えることですが、どこも倍率が高い！\n生々しい話をしますが、合格発表の数字の飛び方がエグくないですか。 これ受験番号連番で割り当てているよね？？って疑うくらい、数字がバラバラです。 情報科学類の場合、合格者で最もの数字の大きい人が618584ですが、少なくとも618501から618584までの84人いたってことなんでしょうか？？？しかも百の位が0の人もいますし、更に多くの人がいることになります。見えてる情報だけの単純計算で6.68倍です。えっぐ。 昨年度は7.26倍(138/19)ですので筑波は今後も人気が続きそうです(令和5年度入学試験実施結果)。\n感想 執筆疲れた。\n今は入学手続きがわからないという幸せな悩みがあります。\nグレーな方法なので、自己責任でお願いします。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-07-10T12:08:30+09:00","permalink":"https://shibaken28.github.io/my-blog-4/contents/hennyu_taikenki/","title":"高専→大学編入体験記"},{"content":"はじめに 解答はあくまで私が解いたものであり、正解を保証するものではありません。\n途中で解答を書くのに飽きて雑になっているところがあります。問題文が不完全な場合があります。\n山梨大学は編入試験を含め、入試問題を公開しています。神。 山梨大学過去問集へのリンク\n傾向と対策 コンピュータ理工科は成績証明書：口述試験：筆記試験の配点の比が1:1:8となっています(ただし、口述試験単体でも否だと、他の点数に関わらず不合格になります)。\n出題範囲 年度 プログラミング 計算機アーキテクチャ 情報数学 令和5年度 計算量、ソート、ハッシュ表、二分探索木 論理回路、ビット演算、仮想記憶 数学的帰納法、確率、グラフ理論 令和4年度 計算量、組み合わせの探索、動的計画法、リスト 論理回路、ノイマン型コンピュータ エントロピー、行列 令和3年度 コンパイラ、二分木、基礎問題 仮想記憶、サブシステム 数論証明、確率、行列 令和2年度 二分木、基礎問題、ポインタ 基礎問題、プロセッサ 命題、関係、行列 平成31年度 二分探索、ヒープ、基礎問題 ビット演算、RISC/CISC、アセンブリ 集合、関係、行列、確率 平成30年度 逆ポーランド記法、双方向リスト、基礎問題、木構造、オブジェクト指向 アセンブリ、メモリ、ビット演算 命題、行列(+グラフ理論)、確率 平成29年度 テスト、オブジェクト指向、基本問題、双方向リスト ノイマン型コンピュータ、論理回路、仮想記憶 整数、関係、確率 当たり前っちゃ当たり前ですが、基本情報や応用情報技術者試験と重なっている部分も多く、それらの試験の対策をしたことがあると解きやすいと思います。\nプログラミング 他の学校に比べ、難易度は高めだと思います。プログラミングの基礎知識、というよりはアルゴリズム寄りです。基本的なデータ構造やアルゴリズムはもちろん、計算量やプログラミング的な思考力が問われます。一方で、コンパイルの処理やオブジェクト指向について説明させる問題が出題されることもあり、多くの知識が求められます。 二分木に関する問題が頻出です。再帰処理に対する理解が必要です。 ポインタを扱うリスト構造も頻出です。ポインタの理解が必要です。 その他、ハッシュテーブルや動的計画法、ヒープ構造など、様々なアルゴリズムが出題されているため、対策が難しくなっています。 bit全探索や、部分和問題についての動的計画法あたりはAtCoder茶色以上のレベル感です。 行きがけ順、帰りがけ順、分離チェイン法など、語句を知っておく必要があります。 たまにソフトウェア工学に関する問題(オブジェクト指向、テスト)が出題されます。 計算機アーキテクチャ 出題範囲が広く、暗記の量が多いです。また、読解力が求められる問題も多く出題されています。 情報数学 命題、集合、関係、行列、確率などの特に離散数学に関する問題が出題されます。 命題：数学的帰納法での証明問題や、命題に関する基礎的な問題が出題されます。 行列：固有値と固有ベクトル、行列式、逆行列、行列の積などに関する問題が出題されます。 確率：基本的な確率の問題です。ベイズの定理や重複組合せが出題されることもあります。 関係：反射律、対称律、同値関係あたりの定義は覚えておいたほうが良いです。 集合：一度包除原理を使った問題が出題されましたが、基本的には高校数学レベルです。 グラフ理論：令和5年度、突如2部グラフと2彩色グラフに関する証明問題が出ました。 その他、情報エントロピーやハフマン符号化に関する問題が出題されています。 基本的に情報数学は他の科目に比べて優しいですが、稀に破天荒な問題が出題されることがあります。\n令和5年度 筆記試験 プログラミング、計算機アーキテクチャ、情報数学の3科目を出題し、2科目の選択解答 としました。試験時間は80分です。試験問題は別紙の通りです。 口述試験 コンピュータ理工学に関する専門分野の基礎的事項、意欲、コミュニケーション力、思 考力に関する口述試験を行いました。試験時間は10分です。 プログラミング 問1 ソートアルゴリズムの安定性とは何かを説明しなさい。\n安定性とは、同じ値を持つ要素があった場合、ソート前とソート後でそれらの順番が入れ替わるかどうかのことである。ソート前とソート後で順番が変わらない場合、安定なソートであり、変わる場合、不安定なソートである。\n「挿入ソート」，「マージソート」，「クイックソート」の3つのアルゴリズムについて、安定かどうかを答えなさい。\n挿入ソート：安定 数字を挿入するときに、確定部分を前から順番に見ていって、挿入する数字よりも大きい数字があったら、その数字の前に挿入するようにすると安定なソートになる。逆に、確定部分を後ろから見ていき、挿入する数字よりも小さい数字があったら、その数字の後ろに挿入するようにすると不安定なソート(同じ数字は逆順)になる。 マージソート：安定 要素を分割したときに、同じ値を持つ要素があった場合、左側の要素を優先してマージするようにすると安定なソートになる。逆に、右側の要素を優先してマージするようにすると不安定なソートになる。 クイックソート：不安定 ピボットの選択により、同じ値を持つ要素の順番が変わることがあるため、不安定なソートになる。 データ数が$n$のとき、「挿入ソート」，「マージソート」，「クイックソート」の3つのアルゴリズムの平均計算量、最悪計算量、最良計算量のオーダーを答えなさい。\n挿入ソート\n平均計算量：$O(n^2)$ 最悪計算量：$O(n^2)$ 逆順の配列をソートする場合 最良計算量：$O(n)$ 整列済みの配列をソートする場合 マージソート\n平均計算量：$O(n\\log n)$ マージする際に、$n$回比較する。それを$\\log n$回繰り返すので、$O(n\\log n)$となる。 最悪計算量：$O(n\\log n)$ 最良計算量：$O(n\\log n)$ 数列がどのような形をしていても、比較回数は変わらない。 クイックソート\n平均計算量：$O(n\\log n)$ 厳密な導出は結構難しいので、省略 最悪計算量：$O(n^2)$ ピボットが常に最大値または最小値の場合 最良計算量：$O(n\\log n)$ ピボットの選択により、$n$回比較する。それを$\\log n$回繰り返すので、$O(n\\log n)$となる。 問2 キー値が 0 から 15 までの整数値を取るとき，キー値の集合からハッシュ表を作成することを考えます．レコードはキー値のみで他にデータはないものとします．ハッシュ表のサイズ L を 5 とし，ハッシュ表の各要素は 0~4 の番地を持つものとします．ハッシュ関数 h(x)を h(x) = 3x mod L とします．\nハッシュ値が 2 で衝突するような 3 つの異なるキー値を挙げなさい．\n$3x \\mod 5 = 2$となるような$x$を求めると、$x=4,9,14$。\n空のハッシュ表に，(a)の 3 つのキー値を分離チェイン法（チェイン法，分離連鎖法）によって格納する様子を図示しなさい．ただし，キー値が格納されているところだけの様子が分かればよく，その他の部分は書き入れる必要はありません．\nチェイン法は、結合リストを用いて同じ番地に複数のデータを入れる。(図は省略)\n空のハッシュ表に，(a)の 3 つのキー値を開番地法（空き番地法，オープンアドレス法）によって格納する様子を図示しなさい．ただし，代替ハッシュは線形走査法（線形探査法）で求めなさい．また，キー値が格納されているところだけの様子が分かればよく，その他の部分は書き入れる必要はありません．\nオープンアドレス法は、衝突が起きた場合に、ひとつ後ろの番地に格納する方法である。その場所も衝突していた場合は、さらにひとつ後ろの番地に格納する。これを繰り返す。(図は省略)\n問3 データ数を n とする時，平衡２分探索木に格納されたデータの中から，特定のデータを探索する作業の平均計算量のオーダーを答えなさい．平衡２分探索木は「どのノードの左右部分木の高さの差も 1 以下」という条件を満たす２分探索木です．\n木の高さのオーダーは$O(\\log n)$であるため、平均計算量のオーダーも$O(\\log n)$となる。\n次のプログラムは，２分探索木の実装の一部です．空欄（ア）～（ウ）に当てはまる，再帰を用いたコードを記述しなさい．\npの子のうち、高い方の高さに1を加えたものが高さである。\n1 2 3 4 5 int height(BinaryNode* p){ // p が指しているノードを根とする木の高さを返す． if ( p == NULL ) return 0; return 1 + ( ( height(p-\u0026gt;left) \u0026gt; height(p-\u0026gt;right) ) ? height(p-\u0026gt;left) : height(p-\u0026gt;right) ); } 全てのノードについて検証をしなければならないということに注意。再帰関数に慣れていないと難しい。 あるノードの子を根とする木が平衡２分探索木のバランス条件を満たしていて、かつ、そのノードの左右部分木の高さの差が1以下であるとき、そのノードを根とする木は平衡２分探索木のバランス条件を満たしている。\n1 2 3 4 5 6 7 8 9 10 bool is_balanced(BinaryNode *p) { // p が指しているノードを根とする木が平衡２分探索木のバランス条件を満たしているかどうかを返す． if (p == NULL) return true; if (is_balanced(p-\u0026gt;left) \u0026amp;\u0026amp; is_balanced(p-\u0026gt;right)) return (abs(height(p-\u0026gt;left) - height(p-\u0026gt;right)) \u0026lt;= 1); else return false; } main 関数の「エ」の時点での２分探索木を図示しなさい．この２分探索木を前順（行きかけ順，preorder）ならびに中順（通りがけ順，inorder）でなぞったときのノードの訪問順序を答えなさい．\n二分探索木は次のようになる\n1 2 3 4 5 6 7 5 / \\ 2 7 / \\ / 1 3 6 \\ 4 行きかけ順(preorder): 5, 2, 1, 3, 4, 7, 6 通りがけ順(inorder): 1, 2, 3, 4, 5, 6, 7 (帰りかけ順(postorder): 1, 4, 3, 2, 6, 7, 5) 情報数学 問1 $𝑛$ 個の元からなる集合 $𝐴$ には $2^n$ 個の部分集合があることを数学的帰納法を用いて証明しなさい．\n$n=0$のとき。$2^0=2$である。$A$の部分集合は$\\phi$の1つである。よって、$n=0$のとき成立する。 $n=k$のとき、$A= \\lbrace a_1,a_2,\\cdots a_k \\rbrace $の部分集合は$2^k$個あると仮定する。$n=k+1$のとき、$A= \\lbrace a_1,a_2,\\cdots a_k,a_{k+1} \\rbrace $の部分集合は、$a_{k+1}$を含まない部分集合は$2^k$個ある。$a_{k+1}$を含む部分集合は、$a_{k+1}$を含まない部分集合に$a_{k+1}$を加えたものである。よって、$2^k+2^k=2^{k+1}$個ある。よって、$n=k+1$のときも成立する。 問2 2 個の赤球と 18 個の白球が入った袋から，太郎，花子がこの順で 1 回ずつ球を取り出すとき，太郎が赤球を取り出す事象を 𝑇，花子が赤球を取り出す事象を 𝐻 とします．なお，取り出した球は袋に戻さないものとします．次の問いに答えなさい．\n太郎が赤球を取り出した後，花子も赤球を取り出す確率 𝑃(𝑇∩ 𝐻) を求めなさい．\n$$ \\frac{2}{20} \\times \\frac{1}{19} = \\frac{1}{190} $$\n太郎が赤球を取り出す確率 𝑃(𝑇) と花子が赤球を取り出す確率 𝑃(𝐻) は等しいことを証明しなさい．\n太郎が赤球を取り出す確率は$\\frac{2}{20}=\\frac{1}{10}$である。 花子が赤球を取り出す確率は、 太郎が赤球を取り出した後、花子が赤球を取り出す確率は$\\frac{2}{20} \\times \\frac{1}{19} = \\frac{1}{190}$である。 太郎が白球を取り出した後、花子が赤球を取り出す確率は$\\frac{18}{20} \\times \\frac{2}{19} = \\frac{18}{190}$である。 よって、花子が赤球を取り出す確率は$\\frac{1}{190} + \\frac{18}{190} = \\frac{19}{190} = \\frac{1}{10}$であり、太郎が赤球を取り出す確率と等しい。 問3 (i)$\\rightarrow$(ii)について $|C|=2$であるから、$C$の要素を$0,1$としたときに、頂点の集合$L,R$を次のように定める。$L=\\lbrace v\\in V|f(v)=0 \\rbrace,R=\\lbrace v\\in V|f(v)=1 \\rbrace$とする。このとき、$L,R$は$L\\cup R=V$かつ$L\\cap R=\\phi$である。すなわち、$L\\subseteq V$かつ$R=V\\setminus L$であり、各辺$(v,w)\\in E$に対して、$v\\in L,w\\in R$または$v\\in R,w\\in L$である。よって、$G$は二部グラフである。\n(ii)$\\rightarrow$(i)について $f:V\\rightarrow C$を次のように定める。$f(v)=0$ if $v\\in L$、$f(v)=1$ if $v\\in R$とする。このとき、各辺$(v,w)\\in E$に対して、$f(v)\\neq f(w)$である。よって、$G$は2彩色可能である。\n(i)$\\rightarrow$(iii)について 対偶を示す。「$G$に奇数の長さの閉路が存在する$\\rightarrow$$G$が2彩色不可能である」を示す。 長さが奇数の閉路が頂点$v_1,v_2,\\cdots,v_{2k+1}$を通るとする。$f(v_1)=0$とする。このとき、$f(v_2)=1,f(v_3)=0,\\cdots,f(v_{2k+1})=0,f(v_1)=0$となる。$f(v_1)=f(v_{2k+1})$となり、$G$は2彩色不可能である。\n(iii)$\\rightarrow$(i)について 長さが偶数の閉路の通る頂点を$v_1,v_2,\\cdots,v_{2k}$とする。$f(v_1)=0$とする。このとき、$f(v_2)=1,f(v_3)=0,\\cdots,f(v_{2k})=0,f(v_1)=0$となる。$f(v_1)\\ne f(v_{2k})$となり、閉路は2彩色可能である。また、閉路でない頂点は明らかに2彩色可能である。よって、$G$は2彩色可能である。\n令和4年度 筆記試験 プログラミング、計算機アーキテクチャ、情報数学から２科目を選択して解答してもら いました。解答時間は80分です。試験問題は別紙の通りです。 口述試験 コンピュータ理工学に関する専門分野の基礎的事項、意欲、コミュニケーション力、思 考力を試問しました。試験時間は10分です。 プログラミング 問1 素数判定のプログラムの穴埋め\n1 2 3 4 5 6 7 8 9 10 11 12 bool isPrimeA(const int N)｛ for(int i=2; i*i\u0026lt;=N; ++i) { if(N%i==0) return false; ｝ return true; ｝ bool isPrimeB(const int N)｛ for(int i=2; i\u0026lt;N; ++i) { if(N%i==0) return false; ｝ return true; isPrimeAとisPrimeBについて、それぞれのプログラムの最悪計算量を求めなさい。\n入力が素数であった場合に計算量が最悪となる。\nisPrimeAの最悪計算量は$O(\\sqrt{N})$である。 isPrimeBの最悪計算量は$O(N)$である。 isPrimeAの方が効率が良い。\n問2 部分和問題を解くプログラムについて、以下の問いに答えなさい。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # include \u0026lt;iostream\u0026gt; using namespace std; bool isSubsetSum(const int a[], const int N, const int W){ for(int bit = 0; bit \u0026lt; (1\u0026lt;\u0026lt;N); ++bit){ int sum = 0; for(int i = 0; i \u0026lt; N; ++i){ if(bit \u0026amp; (1\u0026lt;\u0026lt;i)) sum += a[i]; } if(sum == W) return true; } return false; } int main(){ const int N = 4, W = 19; const int a[] = {3,5,7,9}; if(isSubsetSum(a,N,W)) cout \u0026lt;\u0026lt; \u0026#34;Yes\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026#34;No\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 関数boolisSubsetSum( )内の//(A)の行の｢bit\u0026amp;(1くくi)｣は,この部分和問題を解くためのどのような処理をおこなっているか.この中の｢\u0026amp;｣および｢くく｣の機能の説明を含めて, 150字程度で説明しなさい．\n\u0026lt;\u0026lt;は左シフト演算子、\u0026amp;はAND演算子である。(1\u0026lt;\u0026lt;i)は下からi番目のビット(一番下を0番目とする)のみが1である数を表し、bit \u0026amp; (1\u0026lt;\u0026lt;i)はbitの下からi番目のビットが1であるかどうかを判定する。i番目のビットが立っているときに、a[i]を部分和の用いるとすると、bitが$0$から$2^N-1$まで変化することで、全ての部分和を求めることができる。\nこのプログラムの最悪時間計算量を求めなさい．\n部分和問題の答えがNoだったときに、for文が2^N回実行される。よって、計算量は$O(2^N)$である。\nこのソースコードのアルゴリズムの時間計算量よりも効率の良い、$O(NW)$の時間計算量のアルゴリズムを説明しなさい。\n動的計画法を説明する。\nbool型の二次元配列dpを用意し、dp[i][j]の値を「i番目($a_0,a_1,\\cdots a_{i-1}$)までの数からいくつかを選んで和をjにすることができるか」の判定問題の答えとする。 dp[0][0]はtrueとする。dp[i][j]の値は、dp[i-1][j]の値とdp[i-1][j-a[i]]の値を用いて、dp[i][j] = dp[i-1][j] || dp[i-1][j-a[i]]として求めることができる。dp[N][W]の値がtrueであれば、部分和問題の答えはYesである。\n問3 都県名の一覧を処理するソースコードについて、答えなさい。\nこのソースコードをコンパイルして実行したときの,標準出力への出力をすべて書き出しなさい．\nこの実装では、リスト構造を用いている。 func1ではvのnextをpのnextに変更し、pのnextをvにしている。すなわち、pの次の要素をvに変更している。\nfunc2では、nの次が指しているポインタをcurとし、curのprefを表示している。curはcurのnextに変更し、curのnextがnであれば終了する。\nfunc3では、n以外のリストの要素を全削除している。\n以上のことを踏まえると、\n1 2 3 4 5 Tokyo-\u0026gt; Kanagawa-\u0026gt;Tokyo-\u0026gt; Saitama-\u0026gt;Kanagawa-\u0026gt;Tokyo-\u0026gt; Nagano-\u0026gt;Saitama-\u0026gt;Kanagawa-\u0026gt;Tokyo-\u0026gt; Nagano-\u0026gt;Yamanashi-\u0026gt;Saitama-\u0026gt;Kanagawa-\u0026gt;Tokyo-\u0026gt; となる。\nmain( )関数内の｢//(A)｣の行で呼び出されるfunc1( )について,このときに渡される実引数に基づく実行の様子を説明しなさい.必要であれば,図を用いてかまわない．\n略\nこのソースコードで都県名の一覧に用いられているデータ構造の代わりに配列の使用を考える.設問(b)の処理においては,時間計算量の観点から,配列の方が効率が悪い.その理由を150字程度で説明しなさい．\nこのソースコードのアルゴリズムでは、どの場所に挿入するのも$O(1)$で行うことができるが、配列は挿入する場合、挿入する場所以降の要素を全てずらす必要があるため、最悪で$O(N)$の計算量がかかる。\n情報数学 問1 2種の記号AとBの発生確率がそれぞれ$0.8$と$0.2$である記憶のない情報源Sを考える.このとき,以下の設問に答えなさい.計算には $\\log_2 10=3.322$を用いてよい.また,答えは小数点以下第4位を四捨五入して表しなさい．\n$S$のエントロピーを求めなさい．\n$$ H(S) = -\\sum p_i \\log_2 p_i = -0.8 \\log_2 0.8 - 0.2 \\log_2 0.2 \\simeq 0.722 $$\n$\\log 0.2 = \\log (2/10) = \\log 2 - \\log 10 = -2.322 $、$\\log 0.8 = \\log (8/10) = \\log 8 - \\log 10 = -0.322$であることに注意。\n$S$を2次に拡大してからハフマン符号化した場合に生成される符号を示しなさい。また、1情報源記号あたりの平均符号長を求めなさい。(b)\n$S$を$2$次に拡大し、ハフマン符号化すると、以下のようになる($AB$と$BA$は逆でも良い)。\n情報源 AA AB BA BB 発生確率 0.64 0.16 0.16 0.04 符号 0 10 110 111 また、1情報源記号あたりの平均符号長は、$0.64\\times 1 + 0.16\\times 2 + 0.16\\times 3 + 0.04\\times 3 = 1.56$となる。\nAとBの発生確率が偏っているので,ランレングス符号化を行う.ただし,Aは長さ4までのランを考え,Bは長さ1のランのみを考える.すなわち,下記の5種類のランを考える.これをハフマン符号化し,生成される符号を示しなさい.また, 1情報源記号当たりの平均符号長を求めなさい． (c)\n情報源 AAAA AAAB AAB AB B 発生確率 0.4096 0.1024 0.128 0.16 0.2 符号 0 110 111 100 101 1情報源記号あたりの平均符号長は、$0.4096\\times 1 + 0.1024\\times 3 + 0.128\\times 3 + 0.16\\times 3 + 0.2\\times 3 = 2.08$となる。\n(c)の符号化は(b)の符号化に比べて,どれだけ符号化の効率(1情報源記号当たりの平均符号長に対するエントロピーの比)が改善されているか答えなさい．\n$(b)$のエントロピーは$1.444$、$c$のエントロピーは$2.468$である。\nエントロピーは「一つの情報源に対してどれほどの情報量があるか」を示す指標であるから、エントロピーを平均符号長で割ることで、一つの記号あたりの情報量を示すことができる。\n$b$の場合、$1.444/1.56 = 0.925$ $c$の場合、$2.468/2.08 = 1.186$ これらの差である$0.261$bit(binary unit)分だけ、符号化の効率が改善されている。\n問2 固有値の問題。詳細は省略する。 $$ A=\\begin{pmatrix} 2 \u0026amp; 1 \u0026amp; -1 \\\\ 1 \u0026amp; 0 \u0026amp; -1 \\\\ 1 \u0026amp; -1\u0026amp; 0 \\end{pmatrix} $$\n$A$の固有値と固有ベクトルは、 $$ \\lambda_1 = 1, \\lambda_2 = -1, \\lambda_3 = 2 $$ $$ v_1 = (1,0,1)^T, v_2 = (0,1,1)^T, v_3 = (3,1,1)^T $$ である。\n$$ x = (-1,-3,-1)^T = 2v_1-2v_2-v_3 $$ と表されるので、 $$ A^n x = 2 \\cdot 1^n v_1 - 2 \\cdot (-1)^n v_2 - 2^n v_3 $$ よって、 $$ A^n x = \\begin{pmatrix} 2-3\\cdot 2^n \\\\ -2\\cdot (-1)^n - 2^n \\\\ 2 - 2 \\cdot(-1)^n - 2^n \\end{pmatrix} $$\n令和3年度 プログラミング 問1 なんと、アルゴリズムではなくコンパイルの仕組みが出ています。？？？？？？？？？\n(ア)：プリプロセス マクロの展開やヘッダファイルなどを処理する。 (イ)：構文解析 字句解析では、ifやelseやセミコロン、括弧などを解析する。 構文解析では、字句解析をもとに構文構造をまとめる。 (ウ)：アセンブリファイル (エ)：オブジェクトファイル (オ)：ライブラリファイル 実行ファイルの実行速度を高速化するために、コンパイラは様々な最適化を行う。\n関数のインライン展開：関数呼び出しを関数の中身に置き換える。 定数の畳み込み：定数同士の計算を、計算結果に置き換える。 ループの展開(アンローリング)：ループ処理の内容を展開する。 無用命令の削除：冗長で無用な命令を削除する。 定数伝搬：変数を定数で置き換える。 共通部分式の削除：同じ計算を複数回行う場合、一度計算した結果を変数に格納しておき、再利用する。 例えば、a = b + c; d = b + c;というコードがあった場合、b + cを一度計算しておき、a = b + c; d = a;とする。 ループ内不変式の移動：ループ内で変化しない変数の計算をループの外に移動する。 問2 二分木をC言語を用いて実装する。\n着目ノードの左の部分技のすべてのノードの値は、着目ノードの値より小さく\n着目ノードの右の部分木のすべてのノードの値は、着目ノードの値より大きい\nその声質から、木の最も右のノードが木に保持される値の最大値、ミットも左のノードの値が最小値である。\n入力データが1,2,3,4,5,6,7,8のとき、1が根で、右の子が2、2の右の子が3、3の右の子が4、4の右の子が5、5の右の子が6、6の右の子が7、7の右の子が8となる。\n入力データが4,6,2,8,1,5,3,7,-1のとき\n1 2 3 4 5 6 7 4 / \\ 2 6 / \\ / \\ 1 3 5 8 / 7 ある整数がノードに含まれるかどうかの処理の計算量は、木の高さに依存する。 最良の場合、木の高さが$O(\\log n)$であるから、$O(\\log n)$ 最悪の場合、木の高さが$O(n)$であるから、$O(n)$ 問3 大きさ3の配列vを入力とし、次の条件を満たすようなvの要素を返す。\n一つ以上の他の要素よりも大きいかまたは等しい。 一つ以上の他の要素よりも小さいかまたは等しい。 要するに、中央値を求めれば良い。中央値を求める問題を10問も解かされる謎の問題。\nv[0] v[1] v[2] 中央値 3 5 7 5 3 7 5 5 5 3 7 5 3 5 5 5 5 5 5 5 3 0 1 1 0 0 0 0 3 -1 0 0 -2 -3 -4 -3 -2 0 -2 -2 CかC++で実装せよ。\nいくつか方法はある。\nバブルソートのようにスワップしながらソートし、真ん中の値を返す。 各v[i]について、それぞれ条件を満たすかを調べる。 最大値と最小値を求め、v[0]+v[1]+v[2]から最大値と最小値を引く。 一番実装が楽そうなのは3番目の方法。変な方法ではあるが、特に指定されていないので問題ないと思われる。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int func(int v[3]) { int max = v[0]; int min = v[0]; int sum = 0; for (int i = 1; i \u0026lt; 3; i++) { if (v[i] \u0026gt; max) { max = v[i]; } if (v[i] \u0026lt; min) { min = v[i]; } sum += v[i]; } return sum - max - min; } 情報数学 問1から3のうち、2問選択して解答する。\n問1 $r(n+3)$と$r(n)$の差が$3$の倍数であることを証明せよ。 $$ r(n) = \\sum_{i=1}^{m} d_i \\quad (d_iは10進数表記でi番目の桁の数字を表し、mはnの桁数) $$\n方針として、$n$を$3$で割ったあまりと、各位の数の和を$3$で割ったあまりが等しいことを証明すれば良い。\n$$ \\begin{align} n \u0026amp;\\equiv \\sum_{i=1}^{m} 10^{i-1}d_i \\pmod 3 \\\\ \u0026amp;\\equiv \\sum_{i=1}^{m} (3\\times 333\\cdots 3 + 1)^{i-1}d_i \\pmod 3 \\\\ \u0026amp;\\equiv \\sum_{i=1}^{m} 1^{i-1}d_i \\pmod 3 \\\\ \u0026amp;\\equiv \\sum_{i=1}^{m} d_i \\pmod 3 \\\\ \u0026amp;\\equiv r(n) \\pmod 3 \\end{align} $$\nよって、$n \\equiv r(n) \\pmod 3$、つまり$n$を$3$で割ったあまりと、各位の数の和を$3$で割ったあまりが等しい。 $n$を$3$で割ったあまりを$a$と置けば、$n = 3k+a$と整数$k$を用いて表せる。 $n+3=3k+a+3=3(k+1)+a$であるから、$n+3$を$3$で割ったあまりも$a$である。 したがって、$r(n+3) - r(n) \\equiv a - a \\equiv 0 \\pmod 3$である。\n問2 ある会社は、A,B,C社から同じ製品を2:3:5の比率で購入している。A,B,C社の製品にはそれぞれ2.5%,1.5%,1.0%の割合で不良品が含まれている。\n(a) 購入した製品の中から1つを選んだとき、不良品である確率を求めよ。\nA社の製品を選び、かつ不良品である確率は$\\frac{2}{10}\\times \\frac{25}{1000} = \\frac{1}{200}$ B社の製品を選び、かつ不良品である確率は$\\frac{3}{10}\\times \\frac{15}{1000} = \\frac{9}{2000}$ C社の製品を選び、かつ不良品である確率は$\\frac{5}{10}\\times \\frac{10}{1000} = \\frac{1}{200}$ したがって、不良品である確率は$\\frac{1}{200} + \\frac{9}{2000} + \\frac{1}{200} = \\frac{29}{2000}$ (b) 購入した製品の中から1つを選んだら不良品であった。この不良品が、A社、B社、C社の製品である確率をそれぞれ求めよ。\nベイズの定理を用いる(個人的に、特にベイズの定理という名前を認識して使う必要はないと思う)。\nA社の製品である確率は$\\frac{1}{200} \\div \\frac{29}{2000} = \\frac{10}{29}$ B社の製品である確率は$\\frac{9}{2000} \\div \\frac{29}{2000} = \\frac{9}{29}$ C社の製品である確率は$\\frac{1}{200} \\div \\frac{29}{2000} = \\frac{10}{29}$ (ここで、$\\frac{10}{29} + \\frac{9}{29} + \\frac{10}{29} = \\frac{29}{29} = 1$であることを確認できる。) 問3 固有値に関する問題。詳細は省略する。 $$ A=\\begin{pmatrix} 3 \u0026amp; -2 \u0026amp; -1 \\\\ 0 \u0026amp; 1 \u0026amp; -1 \\\\ 2 \u0026amp; 1 \u0026amp; 5 \\end{pmatrix} $$\n(a) 行列$A$の行列式を求めよ。\n$24$\n(b) 行列$A$の固有値を求めよ。\n$\\lambda_1 = 2, \\lambda_2 = 3, \\lambda_3 = 4$ $a_1= (-1,-1,1)^T, a_2 = (-3,-2,4)^T, a_3 = (-1,-1,3)^T$\n(c) 対角化する行列$P$とその逆行列$P^{-1}$を求めよ。\n$$ P = \\begin{pmatrix} -1 \u0026amp; -3 \u0026amp; -1 \\\\ -1 \u0026amp; -2 \u0026amp; -1 \\\\ 1 \u0026amp; 4 \u0026amp; 3 \\end{pmatrix} $$\n$$ P^{-1} = \\frac{1}{24}\\begin{pmatrix} 6 \u0026amp; 9 \u0026amp; 3 \\\\ -2 \u0026amp; 17 \u0026amp; 3 \\\\ -2 \u0026amp; -7 \u0026amp; 3 \\end{pmatrix} $$\nこのとき、$P^{-1}AP = \\begin{pmatrix} 2 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 3 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 4 \\end{pmatrix}$ である。\n令和2年度 プログラミング 問1 二分木について、「親から子へ」「左から右へ」の順番を原則に答えよ (a) 深さ優先探索、幅優先探索をしたとき、訪問する順番を答えよ。\n深さ優先探索: A,B,D,E,H,I,C,F,G,J 幅優先探索: A,B,C,D,E,F,G,H,I,J (b) in-order, pre-order, post-orderで木を巡回したとき、訪問する順番を答えよ。\npre-order(行きがけ順、前順): A,B,D,E,H,I,C,F,G,J in-order(通りがけ順、中順): D,B,H,E,I,A,F,C,J,G post-order(帰りがけ順、後順): D,H,I,E,B,F,J,G,C,A stackを使っているので、右を先に探索するためには、左、右の順番でpushする必要がある。 問2 d[]には-10000から10000までの整数が格納される。d[]の最大値と最小値を求めるプログラムを作成する。\n1 2 3 4 5 6 7 int d[100], minimum, maximum, i; // dに値を格納する処理 mininmum = 10000; maximum = -10000; for (i = 0;i \u0026lt; 100;i++){ if (d[i] \u0026gt; maximum) maximum = d[i]; else if (d[i] \u0026lt; minimum) minimum = d[i]; } (a) 上記のプログラムでは最大値と最小値が正しく求められない場合がある。その場合を示せ。\nelseが使われているため、maximumとminimumが同時に更新されることがなくなっている。 すなわち、d[0],d[1],d[2],...,d[99]が常に増え続けるよう(ただしd[0]!=-10000)な入力に対してはminimumが更新されず、10000のままとなってしまう。\n(b) 上記のプログラムを修正し、最大値と最小値を正しく求めるプログラムを作成せよ。\n単に、else ifをifに変えるだけで良い。\n(c) d[]の中に最小あるいは最大を取る値が複数個含まれていた場合に、最小値や最大値の値がそれぞれ何個含まれているかを求めるプログラムを作成せよ。\nループを$2$回回せば良い。\n1 2 3 4 5 6 7 8 9 10 11 12 13 int d[100], minimum, maximum, i, count_min, count_max; // dに値を格納する処理 mininmum = 10000; maximum = -10000; for(i = 0;i \u0026lt; 100;i++){ if (d[i] \u0026gt; maximum) maximum = d[i]; if (d[i] \u0026lt; minimum) minimum = d[i]; } count_min = 0; count_max = 0; for(i = 0;i \u0026lt; 100;i++){ if (d[i] == maximum) count_max++; if (d[i] == minimum) count_min++; } 問3 (a) 値がコメントのようになるように(1),(2),(3),(4)を埋めよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void rotate(int *x, int *y, int *z){ int tmp; // (1) // (2) // (3) // (4) } int main(void){ int a=7, b=61, c=199; // a=7, b=61, c=199 rotate(\u0026amp;a, \u0026amp;b, \u0026amp;c); // a=61, b=199, c=7 rotate(\u0026amp;a, \u0026amp;b, \u0026amp;c); // a=199, b=7, c=61 } a,b,cがb,c,aの順番になれば良い。\n1 2 3 4 5 int tmp; tmp = *x; *x = *y; *y = *z; *z = tmp; (b) 関数定義において引数をポインタとする実装方法の特徴と有効な使い方について簡単に説明せよ。また、この実装方法の危険性についても説明せよ。\nポインタを用いると、値をコピーせずに、関数内で値を変更することができる。また、値をコピーする必要がないため、メモリの節約になる。ただし、ポインタはアドレスを指すため、誤ってアドレスの変更やアドレスの指す値の変更をしてしまうと、予期せぬ動作をする可能性がある。\n情報数学 問1 次の3つの命題を仮定したとき、これらの命題から得られる結論をすべて求めよ。\n$P_1$: ソクラテスは、人である。 $P_2$: 人はいつか死ぬ。 $P_3$: ベニクラゲは死なない。 整理すると、\nソクラテス$\\rightarrow$人間 人間$\\rightarrow$死ぬ ベニクラゲ$\\rightarrow$死なない また、これらの対偶も成り立つので、\n人間ではない$\\rightarrow$ソクラテスではない 死なない$\\rightarrow$人間ではない 死ぬ$\\rightarrow$ベニクラゲではない これらを組み合わせると、\n1 2 ソクラテス -\u0026gt; 人間 -\u0026gt; 死ぬ -\u0026gt; ベニクラゲではない ベニクラゲ -\u0026gt; 死なない -\u0026gt; 人間ではない -\u0026gt; ソクラテスではない よって、$P_1,P_2,P_3$の他に、\nソクラテスは死ぬ ソクラテスはベニクラゲではない 人間はベニクラゲではない ベニクラゲは人間ではない ベニクラゲはソクラテスではない 死なないならばソクラテスではない の6つの結論が得られる。\n問2 $R$を集合$A$上の同値関係とする。各要素$a\\in A$に対して$a$と同値関係にある要素の集合を同類値と呼び、$[a]$と表す。すなわち$[a]= \\lbrace x|(a,x)\\in R \\rbrace$である。このとき、次を証明せよ。\n同値関係の定義は、関係が反射律、対称律、推移律を満たすことである。\n(a) $A$の各要素$a\\in A$に対して、$a\\in[a]$である。\n同値類は反射律を満たすから、$(a,a)\\in R$である。よって、$a\\in[a]$である。\n(b) $[a]=[b]$のとき、かつこのときに限り、$(a,b)\\in R$である。\n$\\rightarrow$の証明： (a)の結論より、$ a \\in [a]$である。また、$[a]=[b]$であるので、$a \\in [b]$である。よって、$(a,b)\\in R$である。\n$\\leftarrow$の証明： $R$は同値関係であるため、$(a,b)\\in R$のとき$a,b$は同値である。よって、$[a]=[b]$である。\n(c) $[a]\\ne [b]$ならば、$[a]$と$[b]$は互いに素である。\n対偶を示す。$a,b$が互いに素ではないとき、$a,b$は同値である。よって、(b)より$[a]=[b]$である。\n問3 固有値に関する問題。詳細は省略する。 $$ A=\\begin{pmatrix} 0 \u0026amp; 1 \u0026amp; 2 \\\\ -4 \u0026amp; 1 \u0026amp; 4 \\\\ -5 \u0026amp; 1 \u0026amp; 7 \\end{pmatrix} $$\n行列式は$10$\n固有値と固有ベクトルは、$1$に対して$(1,-1,1)^T$、$2$に対して$(1,0,1)^T$、$5$に対して$(1,1,2)^T$である。\n平成31年度 プログラミング 問1 $n$子の整数より構成される配列$x$から整数$t$を探索する関数searchを作る。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int search(int t, int* x, int n){ int lower, upper, middle; lower = 0; upper = n01; while(lower \u0026lt;= upper){ middle = (lower + upper) /2; if(x[middle] \u0026lt; t) lower = middle; //(1) else if (t \u0026lt; x[middle]) upper = middle; //(2) else return middle; } return -1; } (a)このプログラムが正しく動作するのに、xは昇順と降順どちらである必要があるか(ただし、狭義単調増加、狭義単調減少を指す)。\nプログラムでは、二分探索を行っている。x[middle]がtより小さいときに、下限lowerがmiddleにおきかわっている。middleより前を見る必要がない、ということだから、xは昇順である必要があることがわかる。\n(b)入力によって、プログラムが停止しない場合がある。例えば、x={1,2,3}で、t=3のときに停止しない。プログラム中の(1),(2)の部分を変更して、このような場合にも停止するようにせよ。\nlower = middle + 1、upper = middle - 1とすればよい。(要検証)\n(c)xが(a)とは逆の順序である場合に、(1),(2)の部分を修正してプログラムが動作するようにせよ。\n(b)で、(1)と(2)を逆にすればよい。\n(d) このプログラムの計算量が$O(\\log n)$になることを説明せよ。\n一回で半分になるので、ループはおよそ$\\log_2 n$回実行される。\n問2 (a) ヒープに関する説明の穴埋め問題\nヒープは、要素の「あつまり」を表す ?型のデータ構造である。抽象的機能として、要素の並びを保持し、挿入と削除が可能な優先度付きキューの実装の一つと位置づけられる。一般に以下の2つの性質を持つ2分木と定義され、性質1より最小要素は必ず根頂点に格納される。 性質1：略 性質2：略 (b)n子の整数より構成される配列xに対し、以下の\u0026lt;対応付け規則\u0026gt;から構成される2分木をxの2分木と呼ぶ。配列x={20,18,13,19,24,15,28,40}(この順番どおりに格納されている)の2分木を図示しなさい。\n規則1:x[0]を根頂点とする。 規則2:$0\\leq i \\leq (n-1)/2$を満たす整数$i$に対し、x[2*i+1]をx[i]の左の子とする。 規則3:$0\\leq i \\leq (n-2)/2$を満たす整数$i$に対し、x[2*i+2]をx[i]の右の子とする。 具体例を考えれば良い。\nx[0]が根である。 x[0]の左の子がx[1]で、右の子はx[2]である。 x[1]の左の子がx[3]で、右の子はx[4]である。 x[2]の左の子がx[5]で、右の子はx[6]である。 以下同様 これは単に、上から下へ、左から右に、順番に並べたものと一致する。\n1 2 3 4 5 6 7 20 / \\ 18 13 / \\ / \\ 19 24 15 28 / 40 (c) 次ページのC言語のプログラムは、配列xの各要素を移動する関数shiftを表している。(b)の配列x={20,18,13,19,24,15,28,40}について、shift(0,x,8)実行したときのxを答えなさい。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void shift(int i, int* x, int n){ int parent, child, temp; parent = i; child = 2*parent + 1; while(child \u0026lt; n){ if(x[child] \u0026lt; x[parent]){ temp = x[child]; x[child] = x[parent]; x[parent] = temp; parent = child; child = 2*parent + 1; }else{ break; } } } 初期はx={20,18,13,19,24,15,28,40}でparent = 0, child = 1\nx[1] \u0026lt; x[0]なので、x={18,20,13,19,24,15,28,40}でparent = 1, child = 3\nx[3] \u0026lt; x[1]なので、x={18,19,13,20,24,15,28,40}でparent = 3, child = 7\nx[7] \u0026lt; x[3]なので、変化はなくx={18,19,13,20,24,15,28,40}で終了\n(d) (c)の結果のxを、二分木をヒープにするには、プログラムにどのような処理を追加すればよいか。\n任意の配列xではなく、少なくとも(c)で回答したxについてヒープになれば良い。 余談ではあるが、任意のxについてヒープにする必要があると勘違いをし、非常に悩んだ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void shift(int i, int* x, int n){ int parent, child, temp; parent = i; child = 2*parent + 1; while(child \u0026lt; n){ if(child+1\u0026lt;n)if(x[child] \u0026gt; x[child + 1])child ++; if(x[child] \u0026lt; x[parent]){ temp = x[child]; x[child] = x[parent]; x[parent] = temp; parent = child; child = 2*parent + 1; }else{ break; } } } 問3 省略\n情報数学 問1 40名のクラスについて、選択科目A,B,Cの履修状況は以下のとおりである。\nA,B,Cのそれぞれの履修者は18名 少なくともAとBを履修している者は9名 少なくともAとCを履修している者は8名 少なくともBとCを履修している者は5名 一課目以上履修している学生は35名 (a)1科目も履修していない学生 (b)A,B,Cの3科目をすべて履修している学生 (c)A,Bのみを履修している学生 (d)A,Cのみを履修している学生 (e)Aのみを履修している学生、をそれぞれ求めなさい。\nベン図を書いて、パズルチックに解く。あるいは、包除原理を用いる。 3要素の場合の包除原理は以下の通り。 $$ |A\\cup B\\cup C| = |A| + |B| + |C| - |A\\cap B| - |B\\cap C| - |C\\cap A| + |A\\cap B\\cap C| $$ これを今わかっている情報に当てはめる。 $$ 35 = 18 + 18 + 18 - 9 - 8 - 5 + |A\\cap B\\cap C| $$ よって、$|A\\cap B\\cap C| = 3$である。\nなお、この程度の数字の大きさであれば、適当に数を当てはめていって辻褄が合うようなものを探すという方法でも良いだろう。\nあとは、単純な足し算や引き算で求められ、$(a)5,(b)3,(c)6,(d)5,(e)4$\n問2 $R$を集合$A$上の二項関係とする。 (a) $R$が同値関係であるときに満たされる$3$つの性質について、空欄を埋めなさい。\n任意の$a\\in A$に対して$aRa$が成立するとき、$R$は反射的である。 任意の$a,b\\in A$に対して$aRb\\Rightarrow bRa$が成立するとき、$R$は対称的である。 任意の$a,b,c\\in A$に対して$aRb\\land bRc\\Rightarrow aRc$が成立するとき、$R$は推移的である。 (b) 整数$m\u0026gt;1$について、$2$つの整数$x,y$に対して、$x-y$が$m$で割り切れるとき、$x$と$y$は$m$は法として合同であると言い、$x\\equiv y\\pmod{m}$と表す。この関係が、整数の集合$\\mathbb{Z}$上の同値関係であることを示しなさい。\n反射的であること 任意の$x$について、$x-x=0$は$m$で割り切れるので、$x\\equiv x\\pmod{m}$である。 対称的であること 整数$k$を用いると$x-y=mk$と表され、$y-x=-mk$は$m$で割り切れるので、$y\\equiv x\\pmod{m}$である。 推移的であること 整数$k,l$を用いると$x-y=mk,y-z=ml$と表され、$x-z=(x-y)+(y-z)=m(k+l)$は$m$で割り切れるので、$x\\equiv z\\pmod{m}$である。 問3 行列$A$に関して答えなさい\n$$ A = \\begin{pmatrix} 1 \u0026amp; 1 \u0026amp; 1 \\\\ 1 \u0026amp; 1 \u0026amp; 2 \\\\ 1 \u0026amp; 2 \u0026amp; 0 \\end{pmatrix} $$\n(a) $A$の逆行列は存在するか。存在するならば、求めなさい。\n$|A|=-1\\ne 0$なので、$A$は正則である。よって、$A^{-1}$が存在する。\n$$ A^{-1} = \\begin{pmatrix} 4 \u0026amp; -2 \u0026amp; -1 \\\\ -2 \u0026amp; 1 \u0026amp; 1 \\\\ -1 \u0026amp; 1 \u0026amp; 0 \\end{pmatrix} $$\n(b) $A$を隣接行列としてもつ多重グラフ$G=(V,E)$を描きなさい。ただし、頂点集合$V={v_1,v_2,v_3}$とする。\n問4 (a) 正$4$面体サイコロの、出目を確率変数$X$とすると、確率分布表は以下の通りである。\n$X$ $1$ $2$ $3$ $4$ $P(X=x)$ $\\frac{1}{4}$ $\\frac{1}{4}$ $\\frac{1}{4}$ $\\frac{1}{4}$ 2つのサイコロを振り、2つの出目の和を$Y$とすると、$Y$の確率分布表と、期待値を求めなさい。\n$Y=2$は$(1,1)$ $Y=3$は$(1,2),(2,1)$ $Y=4$は$(1,3),(2,2),(3,1)$ $Y=5$は$(1,4),(2,3),(3,2),(4,1)$ $Y=6$は$(2,4),(3,3),(4,2)$ $Y=7$は$(3,4),(4,3)$ $Y=8$は$(4,4)$ $Y$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $P(Y=y)$ $\\frac{1}{16}$ $\\frac{1}{8}$ $\\frac{3}{16}$ $\\frac{1}{4}$ $\\frac{3}{16}$ $\\frac{1}{8}$ $\\frac{1}{16}$ 期待値は、 $$ E[Y]= 2\\cdot \\frac{1}{16} + 3\\cdot \\frac{1}{8} + 4\\cdot \\frac{3}{16} + 5\\cdot \\frac{1}{4} + 6\\cdot \\frac{3}{16} + 7\\cdot \\frac{1}{8} + 8\\cdot \\frac{1}{16} = \\frac{40}{8} = 5 $$\n(b) $n$人いるとき、少なくとも$2$人が同じ誕生日である確率を求めなさい。ただし、$1\u0026lt;n\u0026lt;365$であり、閏年は考えないとする。\n少なくともは、余事象を考えるとやりやすい。すなわち、$n$人とも誕生日が異なる確率を求め、それを$1$から引けばよい。\n$$ 1-\\frac{365}{365}\\cdot \\frac{364}{365}\\cdot \\frac{363}{365}\\cdots \\frac{365-n+1}{365} = 1-\\frac{365!}{(365-n)!365^n} $$\n平成30年度 プログラミング 問1 次の算術式を逆ポーランド記法(後置記法)で表しなさい。 (a) $((A+B)\\times C)\\div (D-(E\\div F))$ (b) $(A+B)\\div (C-D)+(E-F) \\div G$\n逆ポーランド記法とは、演算子を後ろに置く記法である。例えば、$A+B$は$AB+$と表される。括弧や乗算除算の順序に注意する。\n(a): $A B + C \\times D E F \\div - \\div$ (b): $A B + C D - \\div E F - G \\div +$ 問2 逆ポーランド記法で書かれた四則演算の算術式を計算することを考える。スタックを用いる方法を説明しなさい。\nスタックを用いる方法は、以下の通りである。\n前から順に、処理をしていく。 被演算子(数値)が現れたら、スタックに積む。 演算子が現れたら、スタックから2つ取り出し、演算子に関する計算を行い、結果をスタックに積む。 問3 次の手続きを実行したとき、手続きが終了するまでに、比較「x \u0026lt;= 5000」が何回行われるかとその理由とともに答えなさい。\n1 2 3 4 5 6 x = 0; y = 0; while(x\u0026lt;=5000){ x = x+y; y = y+1; } 具体的な処理をみていく。\n初期値はx=y=0 x\u0026lt;=5000であり、xにyが加算され、yに1が加算される。x=0,y=1 x\u0026lt;=5000であり、xにyが加算され、yに1が加算される。x=1,y=2 x\u0026lt;=5000であり、xにyが加算され、yに1が加算される。x=3,y=3 x\u0026lt;=5000であり、xにyが加算され、yに1が加算される。x=6,y=4 このコードはxが5000以下の間、xに0,1,2,3,...を加算し続けるプログラムである。 y=101まで足されたときに、x=5050となり、x\u0026lt;=5000がfalseとなる。よって、比較は103回行われる(0から加算を始めていること、5000を超えたときにも比較が一度行われることに注意)。\n問4 双方向リスト構造に関する問題(詳細は省略)。\n1 2 3 4 5 6 7 8 9 10 11 12 if (root = p){ /*削除対象のセルがリストの先頭のとき*/ (1) root = root.next; if (root != nil) //リストに要素があるとき (2) p.next.prev = nil; }else if (tail = p){ /*削除対象のセルがリストの末尾のとき*/ tail = tail.prev; if ( (3) tail != nil) //リストに要素があるとき (4) p.prev.next = nil; }else{ (5) p.prev.next = p.next; (6) p.next.prev = p.prev; } 問5 根付き木に関する問題(詳細は省略)。\n1 2 3 4 5 v = (1) FirstChild[Parent[v]]; while( v != nil ){ write Info[v]; v = (2) NextBrother[v]; } vが親の第1子であるとは限らないため、一度親を参照し、その第1子を参照する必要がある。\n問6 次の主手続きを実行した後の変数$x$と$y$のの値をその理由とともに答えなさい。ただし、手続きaddsub(x,y)の仮引数xは値呼び出し、仮引数yは参照呼び出しを家庭留守。\n1 2 3 4 //主手続き x = 10; y = 5; addsub(y,x); 1 2 3 //手続き addsub(x,y) x = x+y; y = x-y; 引数(x,y)が逆になっていてややこしいので、addsub(a,b)を考える。\n1 2 3 //手続き addsub(a,b) aはコピー、bは参照 a = a+b; b = a-b; a=5,b=10だから、a=15,b=5となる。aはコピーなので、yには影響しない。bは参照なので、xに影響する。 よて、x=5,y=5となる。\n問7 オブジェクト指向設計における、継承とポリモルフィズムの考え方を説明し、それらを利用する利点を述べなさい。\n継承とは、特定のオブジェクトの機能を引き継いで使用することであrう。同じ機能を持つオブジェクトが複数ある場合、それらの機能を共通化することで、プログラムの見通しを良くすることができる。\nポリモーフィズムとは、目的が同じ機能だが、処理内容が異なる場合に、同じ名前をつけて処理を行うことである。ポリモーフィズムにより操作方法を統一することで、プログラムの見通しを良くすることができる。\n情報数学 問1 (a) $p,q$を命題とする、$p\\rightarrow q$が真であることを証明するための、直接法、対偶法、背理法を説明しなさい。\n直接法：$p$を真と仮定して、$q$が真であることを示す。 対偶法：$\\lnot q$を仮定して、$\\lnot p$が真であることを示す。 背理法：$p \\land \\lnot q$を仮定して、矛盾が生じる(偽となる)ことを示す。 (b) 命題関数$P(n)$を「最初の$n$個の正の奇数の和は$n^2$である」とする。全ての正の奇数$n$に対して$P(n)$が真であることを数学的帰納法を用いて証明しなさい。\nなぜか正の奇数$n$に限定されているが、$n$が正の偶数の場合も成り立つので、$n$が正の整数のときに成り立つことを示せば良い。\n$n=1$のとき、始めの1個の正の奇数の和は$1$であり、$1^2=1$であるから、$P(1)$は真である。 $n=k$のとき、最初の$k$個の正の奇数$1,3,5,\u0026hellip;,2k-1$の和は$k^2$であると仮定する。$n=k+1$のとき、最初の$k+1$個の正の奇数$1,3,5,\u0026hellip;,2k-1,2k+1$の和は、$k^2+2k+1=(k+1)^2$であるから、$P(k+1)$は真である。 以上より、数学的帰納法より全ての正の整数$n$に対して$P(n)$が真であることが示された。よって全ての正の奇数$n$に対して$P(n)$が真であることが示された。 問2 行列に関する問題(詳細は省略)。\n$$ A = \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 2 \\\\ 1 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 2 \u0026amp; 0 \\end{pmatrix} $$\n$|A|=2$\n$$ A^2 = \\begin{pmatrix} 2 \u0026amp; 3 \u0026amp; 6 \u0026amp; 2 \\\\ 2 \u0026amp; 1 \u0026amp; 1 \u0026amp; 2 \\\\ 3 \u0026amp; 2 \u0026amp; 2 \u0026amp; 2 \\\\ 3 \u0026amp; 3 \u0026amp; 2 \u0026amp; 0 \\end{pmatrix} $$\nv1からv3への長さ3のパスの本数は、$A^3$の1行3列目の要素と等しい。よって、12本である。\n問3 2つの箱A,Bがあって、箱Aには赤玉1個と白玉5個、箱Bには赤玉5個と白玉1個がある。\n(a) 任意に箱を選んで1個の玉を取り出したとき、その玉が赤色である確率を求めなさい。\n$$\\frac{1}{2}\\times\\frac{1}{6}+\\frac{1}{2}\\times\\frac{5}{6}=\\frac{1}{2}$$\n(b) 任意に箱を選んで1個玉を取り出し元の箱に戻し、もう一度同じ箱から取り出す、二回連続で取り出した玉が赤色である確率を求めなさい。\n$$\\frac{1}{2}\\times\\frac{1}{6}\\times\\frac{1}{6} + \\frac{1}{2}\\times\\frac{5}{6}\\times\\frac{5}{6}=\\frac{13}{36}$$\n(c) 任意に箱を選んで1個取り出したら赤玉であった。その玉を元の箱に戻し、もう一度同じ箱から取り出して赤玉である確率を求めなさい。\n赤→白の順で取り出す場合 $\\frac{1}{2}\\times\\frac{1}{6}\\times\\frac{5}{6}+\\frac{1}{2}\\times\\frac{5}{6}\\times\\frac{1}{6}=\\frac{5}{36}$ 赤→赤の順で取り出す場合 $\\frac{1}{2}\\times\\frac{1}{6}\\times\\frac{1}{6}+\\frac{1}{2}\\times\\frac{5}{6}\\times\\frac{5}{6}=\\frac{13}{36}$ よって、ベイズの定理より $$ \\frac{\\frac{5}{36}}{\\frac{5}{36}+\\frac{13}{36}}=\\frac{5}{18} $$\n平成29年度 プログラミング 問1 (a) ホワイトボックステストについて答えなさい。\n命令網羅：全ての命令(条件分岐を除く)を最低1回は通すようにするテスト。 判定条件網羅(分岐網羅)：それぞれの判定条件の結果が真となるケース、負となるケースを作成し、全ての分岐を最低1回は通すようにするテスト。 複数条件網羅：全ての判定条件の組み合わせにおける全ての可能な組み合わせを網羅し、かつ全ての命令を一度は実行する。 (b) 次の２つを用意すればいい。命令網羅であるため、命令がない②を通る必要はない。\n1 -\u0026gt; 3 -\u0026gt; 5 -\u0026gt; 6 -\u0026gt; 8 1 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 8 問2 オブジェクト指向プログラミング言語に関する説明文を埋めなさい。\nクラスは階層構造をもってそのｎ属性や操作を継承できる。継承して新たに定義されたクラスを元のクラスの下位クラス(サブクラス)とよび、その元のクラスを上位クラス(スーパークラス)とよぶ。このような階層構造をもつクラスの間の県警には、「自動車-トラック」のような「is-a」関係と、「自動車-タイヤ」のような「has-a」関係がある。\n問3 以下のCで書かれた関数f_a,f_b,f_cのそれぞれについて、引数にN=6が渡されたとときの戻り値を求めよ。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int f_a(int N){ int count = 1; for(int i = 3; i \u0026lt;= N; i+=2){ for (int j = 3; j\u0026lt;=i; j+=2){ if(i==j)++count; if(i%j==0)break; } } } int f_b(int N){ if(N\u0026lt;=1)return N; else return f_b(N-1)+f_b(N-2); } int f_c(int N){ return (N+7)\u0026gt;\u0026gt;3\u0026lt;\u0026lt;3; } f_a(6)：関数の目的がよくわからないが、i=3,5のときにi==jになるので、戻り値は3となる。 f_b(6)：フィボナッチ数列を計算している。f_b(0),f_b(1),...と順番に計算していくとわかりやすい。戻り値は8。 f_c(6)：6+7=13を2進数にすると1101であり、右に3ビットシフトすると1で、左に3ビットシフトすると1000である。戻り値は8。 問4 (a)initList(\u0026amp;list, N, data)によって作成されるリスト構造、(b)func1()とfunc2()のそれぞれの時間計算量について説明しなさい。 (a) Node構造体は次のNodeを指すnextとprevのポインタと要素valueを持っている。先頭と末尾が連結している双方向リストを生成するinitList(\u0026amp;list, N, data)により、listのnextがdata[0]をvalueに持つノード、その次がdata[1]をvalueに持つノード、\u0026hellip;と続き、最後のノードのnextがlistを指すようになる。また、prevは前の要素を指し、最初のノードのprevは最後のノードを指すようになる。(図は省略)。\n(b) func1()はlistの先頭から末尾まで順番に要素を取り出し、vと等しい要素があればnに加算している。これは、リストに含まれるvの個数をカウントする関数であり、計算量はノードの長さをNとすると$O(N)$。func2()はlistが空ではない場合に、listの一つ前の要素を削除する関数である。計算量は$O(1)$。(図は省略)。\n情報数学 問1 (a) 3変数$x,y,z$からなる方程式$x+y+z=10$を考える。。$x,y,z$が非負整数とすると、この方程式の解である$(x,y,z)$の組の個数はいくつか。\n$10$個のボールと$2$個の仕切りを一列に並べる場合の数と等しい。よって、$_{10+2}\\mathrm{C}_{2}=66$通り。\n(b) 2変数$x,y$と実定数$\\alpha,\\beta$に関した、$x+y=1$と$\\alpha,\\beta\u0026gt;0$が成り立っている。\n(1) $x,y$が実数であるとき、$\\alpha x + \\beta xy$の最大値とそのときの$x$を求めなさい。\n(2) $x,y\\in \\lbrace 0,1 \\rbrace$であるとき、$\\alpha x + \\beta xy$の最大値とそのときの$x$を求めなさい。\n(1) $y=1-x$を代入し、平方完成すれば良い。 $$ \\begin{align} \\alpha x + \\beta xy \u0026amp;= \\alpha x + \\beta x(1-x) \\\\ \u0026amp;= \\alpha x + \\beta x - \\beta x^2 \\\\ \u0026amp;= -\\beta x^2 + (\\alpha + \\beta)x \\\\ \u0026amp;= -\\beta \\left(x^2 - \\frac{\\alpha + \\beta}{\\beta}x + \\frac{(\\alpha + \\beta)^2}{4\\beta^2} \\right) + \\frac{\\beta(\\alpha + \\beta)^2}{4\\beta^2} \\\\ \u0026amp;= -\\beta \\left(x - \\frac{\\alpha + \\beta}{2\\beta} \\right)^2 + \\frac{(\\alpha + \\beta)^2}{4\\beta} \\\\ \\end{align} $$ よって、$\\beta\u0026gt;0$より、$x=\\frac{\\alpha + \\beta}{2\\beta}$のとき、$\\alpha x + \\beta xy$は最大値$\\frac{(\\alpha + \\beta)^2}{4\\beta}$をとる。\n(2) 場合分けする。\n$x=0,y=0$のとき、$\\alpha x + \\beta xy=0$ $x=0,y=1$のとき、$\\alpha x + \\beta xy=0$ $x=1,y=0$のとき、$\\alpha x + \\beta xy=\\alpha$ $x=1,y=1$のとき、$\\alpha x + \\beta xy=\\alpha + \\beta$ よって、$\\alpha x + \\beta xy$の最大値は$\\alpha + \\beta$であり、そのときの$x$は$1$である。\n問2 無向グラフ$G=(V,E)$で、$2$頂点$u,v\\in V$を結ぶパスが存在することを$uRv$で表す。このとき、$R$は同値関係であることを示しなさい。\n反射律：明らかにパス$[u]$が存在するので、$uRu$が成り立つ。 対称律：$uRv$が成り立つとき、$u$から$v$へのパス$[u,a_1,a_2,\u0026hellip;,a_n,v]$が存在する。このとき、$v$から$u$へのパス$[v,a_n,a_{n-1},\u0026hellip;,a_1,u]$が存在するので、$vRu$が成り立つ。 推移律：$uRv$かつ$vRw$が成り立つとき、$u$から$v$へのパス$[u,a_1,a_2,\u0026hellip;,a_n,v]$と$v$から$w$へのパス$[v,b_1,b_2,\u0026hellip;,b_m,w]$が存在する。このとき、$u$から$w$へのパス$[u,a_1,a_2,\u0026hellip;,a_n,v,b_1,b_2,\u0026hellip;,b_m,w]$が存在するので、$uRw$が成り立つ。 よって、$R$は同値関係である。 問3 次のようなテストを受験し、合格する必要がある。\n無限の数の問題が用意されており、一問ずつ出題され、解答を行う。 各問に正解すると得点1を得て、不正解すると得点-1を得る。 得点の合計が3になるとテストに合格となり、受験が終了する。\n各問に正解する確率が$2/3$とするとき、次の設問に答えなさい。\n(a) 5問に解答した時点で、テストに合格する確率はいくらか。\n(b) 6問に解答した時点で、得点の合計が2である確率を求めなさい。\n(c) テストに合格するまでに8問以上に解答する必要がある確率を求めてください。 $i$問目を解いたときに$j$点を獲得している場合の数を求める。\n得点 1問 2問 3問 4問 5問 6問 7問 3 1 3 9 2 1 3 9 1 1 3 9 28 0 2 6 19 -1 1 3 10 34 -2 1 4 15 -3 1 5 21 -4 1 6 -5 1 7 -6 1 -7 1 $i$問目まで解いたときに$j$点を獲得している場合の数$A_{ij}$は、次の漸化式で計算できる。\n$A_{0j}=0 \\quad (全てのj)$ $A_{i2} = A_{i-1,1} \\quad (全てのi)$ $A_{ij}=A_{i-1,j-1}+A_{i-1,j+1} \\quad (その他の場合)$ (a) 表より、$A_{5,3}=3$である。また、4問正解して1問不正解だから、 $$ \\left( \\frac{2}{3} \\right)^4 \\times \\left( \\frac{1}{3} \\right)^1 \\times 3 = \\frac{16}{81} $$\n(b) 表より、$A_{6,2}=9$である。また、6問正解して2問不正解だから、 $$ \\left( \\frac{2}{3} \\right)^4 \\times \\left( \\frac{1}{3} \\right)^2 \\times 9 = \\frac{16}{81} $$\n(c) 余事象は、$7$問目までに合格する確率であり、その確率は、表を見ながら、 $$ \\left( \\frac{2}{3} \\right)^3 \\times \\left( \\frac{1}{3} \\right) ^0 \\times 1 + \\left( \\frac{2}{3} \\right)^4 \\times \\left( \\frac{1}{3} \\right) ^1 \\times 3 \\\\ + \\left( \\frac{2}{3} \\right)^5 \\times \\left( \\frac{1}{3} \\right) ^2 \\times 9 = \\frac{152}{243} $$ よって、答えは $$ 1 - \\frac{152}{243} = \\frac{91}{243} $$\n平成28年度 問題が見つかりませんでした！\n平成27年度 プログラミング 問1 浮動小数点で表現された多くの数を加算する。加算結果に含まれる誤差をもっとも小さくなるようにするには、以下のいずれの方法が良いかを、その理由とともに100～150字程度で述べなさい。\n数を絶対値の小さい順に整列し、絶対値の小さい数から始めて順に絶対値の大きい数へと加算してゆく。 絶対値の大きい数から始めて順に絶対値の小さい数へと加算してゆく。 2の絶対値を大きい数から順に加算する方法が良い。\\\n浮動小数点型は、絶対値の大きな数と小さな数を加算したときに、下の方の桁の精度が崩れ、誤差が生じる情報落ちが起こる。絶対値の大きな数から順に加算しておくと、符号が異なり絶対値が近い数同士の加算が行われる可能性があり、その結果が絶対値の小さな数であれば情報落ちの度合いが小さくなる。\n以下のコードを試してみるとよくわかる。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; main() { float a, b, c, d, s, t; a = 0.1111; b = 0.1111; c = 123456.0; d = -123456.0; s = 0.0; t = 0.0; s += a; s += b; s += c; s += d; t += d; t += c; t += b; t += a; printf(\u0026#34;%f\\n\u0026#34;, s); printf(\u0026#34;%f\\n\u0026#34;, t); // s = 0.218750 // t = 0.222200 } 問2 N=10としたとき、次の関数fa(),fb(),fc(),fd()の実行結果を求めなさい。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 int fa(int N){ int i,j,kcount; count = 0; for(i=1;i\u0026lt;=N;i++){ for(j=1;j\u0026lt;=N;j++){ for(k=1;k\u0026lt;=N;k++){ count=count+1; } } } return count; } int fb(int N){ int count; if(N==0)return 1; else{ count = fb(N-1) + fb(N-1); return count; } } int fc(int N){ int i,j,count; count = 0; for(i=1;i\u0026lt;=N;i++){ for(j=1;j\u0026lt;=N;j++){ count=count+1; } if(i%2==1){ count=count+1; } } return count; } int fd(int N){ int i,j,count; count=0; i=1; while(i\u0026lt;=N){ count = count +1; j = 1; while(j\u0026lt;=N){ count=count+1; j=j*2; } i++; } return count; } fa()：$N^3 = 1000$ fb()：$2^N = 1024$ fc()：if文を無視すれば、$N^2$であり、$i=1,3,5,7,9$のときにそれぞれ$10$回加算されるので、$100+5\\times 10=150$ fd()：$j$は$2,4,8,16$と変化していき、$16$になったときにwhileを抜ける。これを$N$回繰り返しているため、$4\\times 10+10=50$ 問3 以下のような完全二分木$T$を考える。(問題文省略)\n1 2 3 4 5 3 / \\ 4 6 / \\ 7 5 (a)\n根：3 節点6の親：3 節点4の兄弟：6 木の高さ：2 木の大きさ：5 (b)\ninoder：7-\u0026gt;4-\u0026gt;5-\u0026gt;3-\u0026gt;6 (preorder：3-\u0026gt;4-\u0026gt;7-\u0026gt;5-\u0026gt;6) (postorder：7-\u0026gt;5-\u0026gt;4-\u0026gt;6-\u0026gt;3) (c)\n根のみからなる木$T$はヒープ木である。 ヒープ木$T$の「$T$の根以外を、根とする部分木」はまたヒープ木である。 ヒープ木$t$の根の数値は、その全ての「$T$の根以外を、根とする部分木」の根の数値よりも「小さい」。 (d)\n1 2 3 4 5 2 / \\ 4 3 / \\ / 7 5 6 (e)\n$N\\log N$回\n(f)\n節点は、その節点の持つ値、子の節点へのポインタが2つ、親へのポインタが1つ、計4つのデータを持つ。よって、16byte。\n(g)\n配列を用いて、$i$番目の要素の親は$\\lfloor i/2 \\rfloor$番目の要素、左の子は$2i$番目の要素、右の子は$2i+1$番目の要素と表現することで、4byteで済む。\n問4 $N=10^9$個の数からなる一次元配列が与えられる。その中から、$p$個の数をその値の小さいものから順に取り出すとき、どのようなアルゴリズムを用いると、最も効率よく$p$個の数を取り出すことができるか。\n(a)$p=1$のとき (b)$p=10^8$のとき\n(a)\n配列をAとする。m=A[0]とおき、for文でAを走査し、mより小さい値があればmをその値に置き換える。これをAの最後まで繰り返す。このとき、mにはAの最小値が格納されている。計算量は$O(N)$。\n(b)\n昇順にソート(マージソートやヒープソートなどの最悪計算量が$O(N\\log N)$のソート)を行い、Aの最初の$p$個の要素を取り出す。計算量は$O(N\\log N)$。 (a)のように、最小値を求める方法を用いると、計算量は$O(Np)$とり、$\\log N \u0026lt; p$であるから、前者の方が効率的である。\n情報数学 問1 集合$A$上の二項関係$R$を直積集合$A\\times A$の部分集合として定義する。また、$x,y\\in A$に対して、$(x,y)\\in R$であるとき$xRy$と表記する。いま、自然数全体の集合を$A=\\mathbb{N}$とし、次の$\\mathbb{N}$上の二項関係$D={(x,y)|x,y\\in \\mathbb{N},xはyの約数}$を考える。\n(a) $xDy$を満たす$(x,y)$の組を具体的に3つあげなさい。\n$(1,1),(1,2),(1,3)$ (b) 順序$R$とは、$A$の任意の要素$x,y,z$に対して反射律、推移律、反対称律を満たす二項関係のことである。$D$が順序であることを示しなさい。\n反射律：明らかに$x$は$x$の約数であるから、$xDx$である。 推移律：$xDy$かつ$yDz$であるとき、整数$a,b$を用いて$ax=y,by=z$と表せる。このとき、$abx=z$であるから、$x$は$z$の約数である。よって、$xDz$である。 反対称律：$xDy$かつ$yDx$であるとき、整数$a,b$を用いて$ax=y,by=x$と表せる。このとき、$abx=x$であるから、$ab=1$である。よって、$x=y$である。 集合$A$と$A$上の順序$\\preceq$ の対を順序集合と呼び、$\\left\u0026lt;A,\\preceq\\right\u0026gt;$と表記する。$A$のある要素$a$と、$A$の任意の要素$x,y,z$に対して、以下の条件が成り立つとき、$x$を$a$の直後の要素という。\n(1) $a\\preceq x$\n(2) $a\\prec z \\preceq x$ならば$z=x$\nただし、$x \\preceq y$かつ$x\\ne y$であるとき$x\\prec y$と表記する。 順序集合$\\left\u0026lt;N,D\\right\u0026gt;$では、任意の$k\\in \\mathbb{N}$に対して、$k$の直後の要素が無限に存在することが知られている。$k$の値を具体的に定め、その直後の要素の例を$3$つあげなさい。\n$k=1$のとき、$2,3,5$は$k$の直後の要素である。\n問2 包除原理を使えば良い。英語、中国語、ドイツ語をそれぞれ履修している人の集合を$A,B,C$とする。\n$$ |A\\cup B\\cup C|=|A|+|B|+|C|-|A\\cap B|-|B\\cap C|-|C\\cap A|+|A\\cap B\\cap C| $$ わかっている情報を代入すると、\n$$ |A\\cup B\\cup C|=50+35+25-15-15-10+|A\\cap B\\cap C| = 70+|A\\cap B\\cap C| $$\nどれも履修していない人数が$5$人だから、$|A\\cup B\\cup C|=75$である。よって、$|A\\cap B\\cap C|=5$である。\nあとは、適当に足し算引き算していけば良い。\n英語のみ：$30$ 中国語のみ：$10$ ドイツ語のみ：$5$ 中国語とドイツ語を両方登録しているが、英語は登録していない：$10$ 全部登録している人：$5$ 問3 (a) $B_4$\n(b)図のようになる。 $B_1$：$8$ $B_2$：$12$ $B_3$：$12$ $B_4$：$18$ (c) $B_6$ (d) 区切られたグリットを挟んだところに最も近い基地局があると、この探索方法だとその基地局が選ばれないことがある。\n平成26年度 プログラミング 問1 選択ソートのプログラムの穴埋め\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void selectSort(void){ int i,j,min; for(i=0;i\u0026lt;N-1;i++){ min=i; for(j=i+1;j\u0026lt;N;j++){ if( data[min] \u0026gt; data[j] ){ min=j; } } swap(i,min); } } void swap(int x,int y){ int tmp; tmp=data[x]; data[x]=data[y]; data[y]=tmp; } (b)計算量を求めなさい。\n$O(N^2)$\n(c) N=8,data[N]={5,8,7,3,6,1,4,2}であった場合を考える。プログラムの実行時、変数iの値がインクリメントされ、i=2となった直後のdataの値を求めなさい。\ni=0のとき：{1,8,7,3,6,5,4,2} i=1のとき：{1,2,7,3,6,5,4,8} i=2のとき：{1,2,3,7,6,5,4,8} 問2 異なる$n$個の候補から$r$個を選択する組み合わせの総数を求める、次の条件を満たす関数を作成しなさい。\n$n,r$を引数とする。 再帰呼び出しを用いる。 $n,r$の大小関係に関するエラー処理はしなくてよい。 また、次の性質を利用して良い\n$_n\\mathrm{C}_0 = _n\\mathrm{C}_n = 1$ $_n\\mathrm{C}_r = _{n-1}\\mathrm{C}_{r-1} + _{n-1}\\mathrm{C}_r$ 1 2 3 4 5 6 7 int combination(int n,int r){ if(r==0 || r==n){ return 1; }else{ return combination(n-1,r-1)+combination(n-1,r); } } 問3 関数の引数における値渡しと参照渡しの違いを説明しなさい。\n値渡しは、関数に渡す引数の値をコピーして渡す方法である。関数内で引数の値を変更しても、呼び出し元の変数の値は変わらない。参照渡しは、関数内で引数の値を変更すると、呼び出し元の変数の値も変わる。参照渡しは、値渡しに対して、メモリの使用量が少ない。\n問4 情報数学 問1 （a) $aRb$ならば、$Ca=Cb$であることを示しなさい。\n$aRb$より、$Ca={a,b,x_1,x_2,\\cdots,x_n}$と表すことができる。対称律の定義より、$Cb={b,a,x_1,x_2,\\cdots,x_n}$である。よって、$Ca=Cb$である。\n(b) $aRb$でなければ、$Ca \\cap Cb = \\emptyset$であることを示しなさい。\n背理法で示す。$Ca$と$Cb$に共通の要素$x$があったとする。$aRx$と$bRx$の関係が成り立つので、推移律より$aRb$が成り立つ。これは$aRb$でないことに矛盾する。よって、$aRb$ではないとき、$Ca \\cap Cb = \\emptyset$である。\n(c) $2$つの整数$a,b$に対して、$a-b$が$3$の倍数であるとき、$a=_3b$とする。このとき、関係$=_3$は同値関係であることを示しなさい。\n反射律：$a-a=0$は$3$の倍数であるので、$a=_3a$である。 対称律：$a-b=3k$ならば、$b-a=-3k$である。$-3k$は$3$の倍数なので、$b=_3a$である。 推移律：$a-b=3k$かつ$b-c=3l$ならば、$a-c=a-b+b-c=3k+3l=3(k+l)$である。$k+l$は整数なので、$a-c$は$3$の倍数である。よって、$a=_3c$である。 以上より、$=_3$は同値関係である。 問2 二分木の木の高さは以下のように定義できる。\n空の二分木の高さは$0$である。 ノードが1つ以上ある二分木には根ノードがあり、その高さは以下で定義する。$\\max(根ノードの左につながる部分木の高さ, 根ノードの右につながる部分木の高さ)+1$\nさらに、全てのノードをみて、左右のノードにつながる部分木の高さの差が$1$以下である二分木を「近似的平衡二分木」と定義する。 (a) 高さが3の近似的平衡二分木に含まれるノード数の最小値を答えなさい。さらに、高さが4の場合についても同様に答えなさい。\n高さが3の場合、ノード数の最小値は$4$である。\n1 2 3 4 5 o / \\ o o / o 高さが4の場合、ノード数の最小値は$7$である。\n1 2 3 4 5 6 7 o / \\ o o / \\ \\ o o o \\ o (b)高さ$h$の木について、ノード数の最小値を$a_n$とする。漸化式で$a_n$を示しなさい。ただし、$a_0=0,a_1=1$とする。\n$n\\geq 2$のとき、$a_n=a_{n-1}+n-1$\n$18$個ののーどが含まれる近似平衡二分木の高さの最大値を答え、その理由を説明しなさい。\n$a_n \\leq 18$を満たす最大の$n$を求める。$a$を列挙すると、$a_1=1,a_2=2,a_3=4,a_4=7,a_5=11,a_6=16,a_7=22$であるので、高さは$6$である。\n問3 (a)\n故障率を$p$と置く。\n$$ p^4 + 4\\cdot p^3(1-p) + 2\\cdot p^2(1-p)^2 = p^2(-p^2+2) = 0.00019999 = 2 \\times 10^{-4} $$\n(b)\n$$ 1 - ((1-p)^4 + 4\\cdot p(1-p)^3 + 2\\cdot p^2(1-p)^2) = p^2(p-2)^2 = 0.00039601 = 4 \\times 10^{-4} $$\n","date":"2023-05-25T12:08:30+09:00","permalink":"https://shibaken28.github.io/my-blog-4/contents/yamanashi_univ/","title":"山梨大学コンピュータ理工科過去問を解く"},{"content":"分母の$840$は正の得点を取ったチーム数を表しています．\nEZDORSA_Lv1 (529/840) 問題 $p=3,q=5,n=pq,e=65535$のとき， $$ m^e = 10 \\pmod n $$ を満たす最小の$m$はいくつか．\n解法 $m=1,2,3,\\cdots$と順番に試していけばよいです． Pythonでは，mのe乗をnで割った余りはpow関数を使ってpow(m,e,n)で求められます．\n1 2 3 4 5 6 7 8 9 p = 3 q = 5 n = p*q e = 65535 for m in range(n): if pow(m,e,n) == 10: print(m) break 結果は$10$です．\nコメント $(p,q)=(3,5)$より$\\phi(n)=(p-1)(q-1)=8$です． $e=65535=2^{16}+1$なので，$e$を$\\phi(n)$で割った余りは$1$です． オイラーの定理より，$m^e=m \\mod n$が成り立つことがわかります．\nEZDORSA_Lv2 (251/840) 問題 $n,e,c$が与えられます．$c$は$m,e,n$によって計算されます． $$ c = 5^{100} m^e \\pmod n $$\n1 2 3 n = 25465155563758206895066841861765043433123515683929678836771513150236561026403556218533356199716126886534636140138011492220383199259698843686404371838391552265338889731646514381163372557117810929108511770402714925176885202763093259342499269455170147345039944516036024012941454077732406677284099700251496952610206410882558915139338028865987662513205888226312662854651278789627761068396974718364971326708407660719074895819282719926846208152543027213930660768288888225218585766787196064375064791353928495547610416240104448796600658154887110324794829898687050358437213471256328628898047810990674288648843902560125175884381 e = 7 c = 25698620825203955726406636922651025698352297732240406264195352419509234001004314759538513429877629840120788601561708588875481322614217122171252931383755532418804613411060596533561164202974971066750469395973334342059753025595923003869173026000225212644208274792300263293810627008900461621613776905408937385021630685411263655118479604274100095236252655616342234938221521847275384288728127863512191256713582669212904042760962348375314008470370142418921777238693948675063438713550567626953125 解法 $c$と$n$を眺めると$n \\gg c$という特徴から，$5^{100}m^e\u0026lt;n$ではないかと予想をします． $m$を$5^{100}$で割って$e$乗根を取れば$m$が求められます．\n1 2 3 4 5 6 7 8 9 10 11 from Crypto.Util.number import bytes_to_long, getPrime, long_to_bytes, isPrime from gmpy2 import iroot n = 25465155563758206895066841861765043433123515683929678836771513150236561026403556218533356199716126886534636140138011492220383199259698843686404371838391552265338889731646514381163372557117810929108511770402714925176885202763093259342499269455170147345039944516036024012941454077732406677284099700251496952610206410882558915139338028865987662513205888226312662854651278789627761068396974718364971326708407660719074895819282719926846208152543027213930660768288888225218585766787196064375064791353928495547610416240104448796600658154887110324794829898687050358437213471256328628898047810990674288648843902560125175884381 e = 7 c = 25698620825203955726406636922651025698352297732240406264195352419509234001004314759538513429877629840120788601561708588875481322614217122171252931383755532418804613411060596533561164202974971066750469395973334342059753025595923003869173026000225212644208274792300263293810627008900461621613776905408937385021630685411263655118479604274100095236252655616342234938221521847275384288728127863512191256713582669212904042760962348375314008470370142418921777238693948675063438713550567626953125 c//=pow(5,100,n) c = iroot(c,e)[0] print(long_to_bytes(c)) コメント 5**100=7888609052210118054117285652827862296732064351090230047702789306640625です．かなり小さいですね．\nEZDORSA_Lv3 (233/840) 問題 RSA暗号です．ただし，$n=p_1p_2p_3p_4\\cdots p_{100}$と$100$個の相異なる素数の積です．また，各素数$p_i$は$25$ビットである．\n解答 $p_i$が小さいので素因数分解ができます．あとは，オイラーの定理を使って$\\phi(n)$を求めればよいです．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from Crypto.Util.number import bytes_to_long, getPrime, long_to_bytes, isPrime from gmpy2 import iroot n = 22853745492099501680331664851090320356693194409008912025285744113835548896248217185831291330674631560895489397035632880512495471869393924928607517703027867997952256338572057344701745432226462452353867866296639971341288543996228186264749237402695216818617849365772782382922244491233481888238637900175603398017437566222189935795252157020184127789181937056800379848056404436489263973129205961926308919968863129747209990332443435222720181603813970833927388815341855668346125633604430285047377051152115484994149044131179539756676817864797135547696579371951953180363238381472700874666975466580602256195404619923451450273257882787750175913048168063212919624027302498230648845775927955852432398205465850252125246910345918941770675939776107116419037 e = 65537 c = 1357660325421905236173040941411359338802736250800006453031581109522066541737601274287649030380468751950238635436299480021037135774086215029644430055129816920963535754048879496768378328297643616038615858752932646595502076461279037451286883763676521826626519164192498162380913887982222099942381717597401448235443261041226997589294010823575492744373719750855298498634721551685392041038543683791451582869246173665336693939707987213605159100603271763053357945861234455083292258819529224561475560233877987367901524658639475366193596173475396592940122909195266605662802525380504108772561699333131036953048249731269239187358174358868432968163122096583278089556057323541680931742580937874598712243278738519121974022211539212142588629508573342020495 n2 = n # Factorize n ps = [] i = 1\u0026lt;\u0026lt;24 while n2 != 1: if n2 % i == 0: print(i) ps.append(i) n2 //= i else: i += 1 # Calculate phi(n) phi = 1 for a in ps: phi *= a-1 # Calculate d d = pow(e,-1,phi) # Decrypt m = pow(c,d,n) print(m) print(long_to_bytes(m)) pqqp (156/840) 問題 RSA暗号で，$e,n,c$の他に，$s=p^q+q^p \\bmod n$が与えられる．\n解答 実は，$s=p+q$であるので，$\\phi(n)=(p-1)(q-1)=pq-(p+q)+1=n-s+1$となります．\nなぜ成り立つのかというと(フェルマーの小定理$a^p \\mod p = a$であることに注意)，$x = p^q+q^p$とすると，\n$x \\bmod p=q$である． $x \\bmod q=p$である． これを満たす数は，整数$k$を用いて$x = p + q + kpq$と表される． よって，$s=p+q$である．\n1 2 3 4 5 6 7 8 9 10 11 12 from Crypto.Util.number import bytes_to_long, getPrime, long_to_bytes, isPrime from gmpy2 import iroot n = 31091873146151684702346697466440613735531637654275447575291598179592628060572504006592135492973043411815280891993199034777719870850799089897168085047048378272819058803065113379019008507510986769455940142811531136852870338791250795366205893855348781371512284111378891370478371411301254489215000780458922500687478483283322613251724695102723186321742517119591901360757969517310504966575430365399690954997486594218980759733095291730584373437650522970915694757258900454543353223174171853107240771137143529755378972874283257666907453865488035224546093536708315002894545985583989999371144395769770808331516837626499129978673 e = 65537 c = 8684906481438508573968896111659984335865272165432265041057101157430256966786557751789191602935468100847192376663008622284826181320172683198164506759845864516469802014329598451852239038384416618987741292207766327548154266633297700915040296215377667970132408099403332011754465837054374292852328207923589678536677872566937644721634580238023851454550310188983635594839900790613037364784226067124711011860626624755116537552485825032787844602819348195953433376940798931002512240466327027245293290482539610349984475078766298749218537656506613924572126356742596543967759702604297374075452829941316449560673537151923549844071 s = 352657755607663100038622776859029499529417617019439696287530095700910959137402713559381875825340037254723667371717152486958935653311880986170756144651263966436545612682410692937049160751729509952242950101025748701560375826993882594934424780117827552101647884709187711590428804826054603956840883672204048820926 phi = n - s + 1 d = pow(e, -1, phi) m = pow(c, d, n) print(long_to_bytes(m)) fusion (67/840) 問題 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from Crypto.PublicKey import RSA RSAkeys = RSA.generate(2048) p = RSAkeys.p q = RSAkeys.q n = RSAkeys.n e = RSAkeys.e m = b\u0026#34;FAKE{\u0026lt;REDACTED\u0026gt;}\u0026#34; c = pow(int.from_bytes(m, \u0026#34;big\u0026#34;), e, n) mask = int(\u0026#34;55\u0026#34; * 128, 16) r = p \u0026amp; mask mask = mask \u0026lt;\u0026lt; 1 r += q \u0026amp; mask print(f\u0026#34;n = {n}\u0026#34;) print(f\u0026#34;e = {e}\u0026#34;) print(f\u0026#34;c = {c}\u0026#34;) print(f\u0026#34;r = {r}\u0026#34;) 解答 まず，0x55...55という数を考えます．これは，0b01010101...01010101という2進数で表されます．これを左に1ビットシフトすると，0b10101010...10101010となります．すなわち，$r$が表しているのは，\n$p$の下から奇数ビット目だけを抜き出した数 $q$の下から偶数ビット目だけを抜き出した数 を足し算したものです．逆に言えば，$r$の下から奇数ビット目は$p$の下から奇数ビット目と一致し，$r$の下から偶数ビット目は$q$の下から偶数ビット目と一致します．\nこの問題は，次の性質を使います．\n「$p$の下位$x$ビットと$q$の下位$x$ビットの積」の下位$x$ビットは，$n$の下位$x$ビットと一致する． これを$x=1,2,3,\\dots$と繰り返すことで，$p,q$を求めることができます．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from Crypto.Util.number import bytes_to_long, getPrime, long_to_bytes, isPrime from gmpy2 import iroot n = 27827431791848080510562137781647062324705519074578573542080709104213290885384138112622589204213039784586739531100900121818773231746353628701496871262808779177634066307811340728596967443136248066021733132197733950698309054408992256119278475934840426097782450035074949407003770020982281271016621089217842433829236239812065860591373247969334485969558679735740571326071758317172261557282013095697983483074361658192130930535327572516432407351968014347094777815311598324897654188279810868213771660240365442631965923595072542164009330360016248531635617943805455233362064406931834698027641363345541747316319322362708173430359 e = 65537 c = 887926220667968890879323993322751057453505329282464121192166661668652988472392200833617263356802400786530829198630338132461040854817240045862231163192066406864853778440878582265466417227185832620254137042793856626244988925048088111119004607890025763414508753895225492623193311559922084796417413460281461365304057774060057555727153509262542834065135887011058656162069317322056106544821682305831737729496650051318517028889255487115139500943568231274002663378391765162497239270806776752479703679390618212766047550742574483461059727193901578391568568448774297557525118817107928003001667639915132073895805521242644001132 r = 163104269992791295067767008325597264071947458742400688173529362951284000168497975807685789656545622164680196654779928766806798485048740155505566331845589263626813345997348999250857394231703013905659296268991584448212774337704919390397516784976219511463415022562211148136000912563325229529692182027300627232945 mask = int(\u0026#34;55\u0026#34; * 128, 16) pm = r \u0026amp; mask qm = r \u0026amp; (mask \u0026lt;\u0026lt; 1) # 下の桁から，掛け算した結果がnの下位ビットと一致するかを確認する for i in range(1024): s = i+1 if i%2==0: # pがわかっている，qがわからない q2 = qm | (1 \u0026lt;\u0026lt; i) n2 = pm * q2 if bin(n2)[-s:] == bin(n)[-s:]: qm |= (1 \u0026lt;\u0026lt; i) else: # pがわからない，qがわかっている p2 = pm | (1 \u0026lt;\u0026lt; i) n2 = p2 * qm if bin(n2)[-s:] == bin(n)[-s:]: pm |= (1 \u0026lt;\u0026lt; i) #print(i, bin(pm*qm)[-s:], bin(n)[-s:]) assert pm*qm == n d = pow(e, -1, (pm-1)*(qm-1)) m = pow(c, d, n) print(long_to_bytes(m)) DSA? (36/840) 問題 色々計算しているが，必要なのは次の情報． $$ \\begin{aligned} y \u0026amp;= g^x \\mod p \\\\ k \u0026amp;= m^{-1} \\mod q \\\\ s \u0026amp;= k^{-1}(h+xr) \\mod q \\end{aligned} $$ サーバーに接続すると，ランダムな$x$が生成され，$p,q,g,y,h,r,s$が得られる． ここで，$p,q,g,h,r$は固定である．\n解答 $k$の値も固定だから， $$ \\begin{aligned} s \u0026amp;= k^{-1}(h+xr) \\mod q \\\\ \u0026amp;= (m^{-1})^{-1}(h+xr) \\mod q \\\\ \u0026amp;= m(h+xr) \\mod q \\\\ \u0026amp;= mh + mxr \\mod q \\end{aligned} $$ 異なる$x_1,x_2,x_3$に対する値を$s_1,s_2,s_3$とすると， $$ \\begin{aligned} s_1 \u0026amp;= mh + mx_1r \\mod q \\\\ s_2 \u0026amp;= mh + mx_2r \\mod q \\\\ s_3 \u0026amp;= mh + mx_3r \\mod q \\\\ s_1 - s_2 \u0026amp;= m(x_1 - x_2)r \\mod q \\\\ s_2 - s_3 \u0026amp;= m(x_2 - x_3)r \\mod q \\\\ (s_1 - s_2)r^{-1} \u0026amp;= m(x_1 - x_2) \\mod q \\\\ (s_2 - s_3)r^{-1} \u0026amp;= m(x_2 - x_3) \\mod q \\end{aligned} $$\n$\\rm{GCD}((s_1 - s_2)r^{-1}, (s_2 - s_3)r^{-1})$を計算すると，$m$が求まります．求まらないこともあります．\nGuess (59/840) 問題 数列$(1,2,3,\\cdots,10^4)$の順列$(P_1,P_2,\\cdots,P_{10^4})$が用意されていて，サーバーに接続して数列$(a_1,a_2,\\cdots,a_{n})$を入力すると，$P_{a_1},P_{a_2},\\cdots,P_{a_{n}}$をランダムに並べ替えたものが返ってくる．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import os import random ANSWER = list(range(10**4)) random.shuffle(ANSWER) CHANCE = 15 def peep(): global CHANCE if CHANCE \u0026lt;= 0: print(\u0026#34;You ran out of CHANCE. Bye!\u0026#34;) exit(1) CHANCE -= 1 index = map(int, input(\u0026#34;Index (space-separated)\u0026gt; \u0026#34;).split(\u0026#34; \u0026#34;)) result = [ANSWER[i] for i in index] random.shuffle(result) return result def guess(): guess = input(\u0026#34;Guess the numbers\u0026gt; \u0026#34;).split(\u0026#34; \u0026#34;) guess = list(map(int, guess)) if guess == ANSWER: flag = os.getenv(\u0026#34;FLAG\u0026#34;, \u0026#34;FAKE{REDACTED}\u0026#34;) print(flag) else: print(\u0026#34;Incorrect\u0026#34;) def main(): menu = \u0026#34;\u0026#34;\u0026#34; 1: peep 2: guess\u0026#34;\u0026#34;\u0026#34;.strip() while True: choice = int(input(\u0026#34;\u0026gt; \u0026#34;)) if choice == 1: result = peep() print(result) elif choice == 2: guess() else: print(\u0026#34;Invalid choice\u0026#34;) break 解答 入力を，$(0,1,1,2,2,2)$のように異なる個数にすれば，並べ替えられたものを返されても元の数列がわかる．これを複数回に分けて行えば良い．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from pwn import * io = remote(\u0026#39;guess-mis.wanictf.org\u0026#39;, 50018)#, level=\u0026#39;debug\u0026#39;) A= [0]*(10**4) N = 1000 for i in range(0,10000,N): print(i) io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(b\u0026#39;1\u0026#39;) io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) s = \u0026#34;\u0026#34; for j in range(0,N): for _ in range(j+1): s += (str(i+j)+\u0026#34; \u0026#34;) io.sendline(s.encode()) p = io.recvline().decode() # pから`[,]`を取り除く p = p[1:-2] p = p.replace(\u0026#34;,\u0026#34;,\u0026#34;\u0026#34;) q = list(map(int,p.split())) # j+1個あったものをi+jに格納する d = dict() for a in q: d [a] = d.get(a,0) + 1 for k,v in d.items(): A[i+v-1] = k io.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) io.sendline(b\u0026#39;2\u0026#39;) s = \u0026#34;\u0026#34; for a in A: s += (str(a)+\u0026#34; \u0026#34;) io.sendline(s.encode()) io.interactive() range_xor (40/840) 問題 整数列Aの任意の要素$a_i(0\\leq a_i\\leq 1000,i=1,2\u0026hellip;N)$に対して操作$f$を次のように定める\n$i$番目の要素を$\\text{min}(a_i, 1000-a_i)$に置き換える 操作$f$を好きな回数行った後の整数列$B={b_1,b_2\u0026hellip;b_N}$に対して $X = b_1 \\oplus b_2 \\oplus \u0026hellip; \\oplus b_N$ とするとき、$X$を最小にするような整数列$B$の種類数を $10^9+7$で割った余りをFLAGとする。\n解答 $X$としてありうる数は，せいぜい$2^{10}=1024$個しかないため，\n$\\text{dp}[i][j] \\coloneqq$ $i$番目までの数に操作を行ってそれらのXORが$j$である通り数 という動的計画法を考えることができる．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # include \u0026lt;iostream\u0026gt; # include \u0026lt;map\u0026gt; # include \u0026lt;vector\u0026gt; using namespace std; int main(){ int N = 1000; vector\u0026lt;int\u0026gt; A; for(int i = 0; i \u0026lt; N; i++){ int tmp; cin \u0026gt;\u0026gt; tmp; A.push_back(tmp); } vector\u0026lt;vector\u0026lt;long\u0026gt;\u0026gt; dp(N+1, vector\u0026lt;long\u0026gt;(1024, 0)); constexpr long mod = 1000000007L; dp[0][0] = 1; for(int i = 0; i \u0026lt; N; i++){ for(int j = 0; j \u0026lt; 1024; j++){ dp[i+1][j^A[i]] += dp[i][j]; dp[i+1][j^A[i]] %= mod; if(A[i] != min(1000-A[i],A[i])){ dp[i+1][j^(1000-A[i])] += dp[i][j]; dp[i+1][j^(1000-A[i])] %= mod; } } } long ans = 0; for(int i = 0; i \u0026lt; 1024; i++){ if(dp[N][i] != 0){ ans = dp[N][i]; break; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } 感想 EZDORSA_Lv1 1:59 5位 EZDORSA_Lv2 5:38 2位 EZDORSA_Lv3 9:41 2位 pqqp 29:48 7位 fusion 52:07 2位 DSA? 1:59:26 2位 Crypto全完 1:59:26 2位 Crypto全完でしたが，first bloodは一つもありませんでした．こういうチャンスは滅多にないと思うので悔しいです．\n数学チックな問題が多くて楽しかったです．\n","date":"2023-05-05T15:01:00+09:00","permalink":"https://shibaken28.github.io/my-blog-4/contents/wani2023/","title":"WaniCTF2023 writeup"},{"content":"Revolving Letters 問題 問題ファイル\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 LOWER_ALPHABET = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; def encrypt(secret, key): assert len(secret) \u0026lt;= len(key) result = \u0026#34;\u0026#34; for i in range(len(secret)): if secret[i] not in LOWER_ALPHABET: # Don\u0026#39;t encode symbols and capital letters (e.g. \u0026#34;A\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;!\u0026#34;, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;) result += secret[i] else: result += LOWER_ALPHABET[(LOWER_ALPHABET.index(secret[i]) + LOWER_ALPHABET.index(key[i])) % 26] return result flag = input() key = \u0026#34;thequickbrownfoxjumpsoverthelazydog\u0026#34; example = \u0026#34;lorem ipsum dolor sit amet\u0026#34; example_encrypted = encrypt(example, key) flag_encrypted = encrypt(flag, key) print(f\u0026#34;{key=}\u0026#34;) print(f\u0026#34;{example=}\u0026#34;) print(f\u0026#34;encrypt(example, key): {example_encrypted}\u0026#34;) print(f\u0026#34;encrypt(flag, key): {flag_encrypted}\u0026#34;) 出力\n1 2 3 4 key=\u0026#39;thequickbrownfoxjumpsoverthelazydog\u0026#39; example=\u0026#39;lorem ipsum dolor sit amet\u0026#39; encrypt(example, key): evvug kztla qtzla exl vqvm encrypt(flag, key): RpgSyk{qsvop_dcr_wmc_rj_rgfxsime!} 解答 シーザー暗号の亜種みたいな感じで，「アルファベットの何文字目(ただしaが$0$文字目)か」文字分だけずらしたものを出力している． 復元するには逆方向にずらせば良い．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 LOWER_ALPHABET = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; def decrypt(secret, key): assert len(secret) \u0026lt;= len(key) result = \u0026#34;\u0026#34; for i in range(len(secret)): if secret[i] not in LOWER_ALPHABET: # Don\u0026#39;t encode symbols and capital letters (e.g. \u0026#34;A\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;!\u0026#34;, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;) result += secret[i] else: result += LOWER_ALPHABET[(LOWER_ALPHABET.index(secret[i]) - LOWER_ALPHABET.index(key[i])) % 26] return result ct = \u0026#34;RpgSyk{qsvop_dcr_wmc_rj_rgfxsime!}\u0026#34; key =\u0026#34;thequickbrownfoxjumpsoverthelazydog\u0026#34; print(decrypt(ct, key)) 余談 こういうタイプの問題でdecrypt関数を作るときは，encrypt関数を流用して少し書き換えると楽に作れることが多い． また，各文字ごとに暗号化の処理が独立しているので，わざわざ逆変換を考えずに，各1文字について「encryptしてこの文字になる」ような文字をブルートフォースしても良い．\nちなみに，exampleのlorem ipsum\u0026hellip;の文章は，Filler textとかDummy textと呼ばれるもので，文章の埋め込みやデザインの確認などに使われるもの．\nRotated Secret Analysis 問題 $1024$bitの素数$p$と，$p$の上位$512$bitと下位$512$bitを入れ替えた値と等しい素数$q$でRSA暗号を構成している．$e,n,c$が与えられるので，$m$を復号する．\n解答 $p$の上位$512$bitと下位$512$bitをそれぞれ$x,y$と置く．すると，$p$と$q$は以下のように表せる． $$ \\begin{align} p \u0026amp;= 2^{512}x + y \\\\ q \u0026amp;= 2^{512}y + x \\end{align} $$ よって，$n$は以下のように表せる． $$ \\begin{align} n \u0026amp;= pq \\\\ \u0026amp;= (2^{512}x + y)(2^{512}y + x) \\\\ \u0026amp;= 2^{1024}xy + 2^{512}(x^2+y^2) + xy \\end{align} $$ $x$と$y$が$512$bitであることに注意すると，\n$n$の下位$512$bitは$xy$の下位$512$bitと等しい 上位$512$bitは，$xy$の上位$512$bit，または$xy$の上位$512$bitに$1$を足したもの1と等しい ということがわかる．図(?)にすると以下のような構造になっている．\n1 2 3 4 5 6 7 8 9 10 11 |-----------------------------------| | 512bit | 512bit | 512bit | 512bit | |-----------------------------------| | xy | 0 | |-----------------------------------| | 0 | x^2+y^2 | 0 | |-----------------------------------| | 0 | xy | |===================================| | n | |-----------------------------------| $xy$が求まれば，$x^2+y^2$も得られ，$2$つの変数$x,y$に関する$2$つの式が得られ，連立方程式として解ける．\nあるいは，$\\phi(n)$は次のように計算できるので， $$ \\begin{align} \\phi(n) \u0026amp;= (p-1)(q-1) \\\\ \u0026amp;= (2^{512}x + y - 1)(2^{512}y + x - 1) \\\\ \u0026amp;= 2^{1024}xy + 2^{512}(x^2+y^2) + xy - 2^{512}x - 2^{512}y - x - y + 1 \\\\ \u0026amp;= n - 2^{512}(x+y) - (x+y) + 1 \\\\ \\end{align} $$ $x+y=\\sqrt{x^2+y^2+2xy}$より$\\phi(n)$を直接求めることもできる．ソルバはこちらの方法で実装した．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from Crypto.Util.number import bytes_to_long, getPrime, long_to_bytes, isPrime from gmpy2 import iroot n=24456513668907101359271796518022987404822072050667823923658615869713366383971188719969649435049035576669472727127263581903194099017975695864947929128367925596885753443249213201464273639499012909424736149608651744371555837721791748016889531637876303898022555235081004895411069645304985372521003721010862125442095042882100526577024974456438653686633405126923109918116756381929718438800103893677616376097141956262119327549521930637736951686117614349172207432863248304206515910202829219635801301165048124304406561437145821967710958494879876995451567574220240353599402105475654480414974342875582148522218019743166820077511 e=65537 c=18597341961729093099197297749831937867867316311655201999082918827905805371478429928112783157010654738161403312986940377995349388331953112844242407426040120302839420903486499187443737383169223520050969011318937950864196985991944523897440559547618789750180738003138383081085865616976666352985134179471231798760776607911573149993314296253654585181164097972479570867395976653829684069633563438561147707530130563531572708010593487686521808574459865586551335422619675302973576174518308347087901889923892503468385483111040271271572302540992212613766789315482719811321158322571666641755809592299352653626100918299699982602448 a = 1\u0026lt;\u0026lt;512 s = bin(n)[2::] for i in range(0,2): up = int(s[0:512],2) - i # xyの上位512bit low = int(s[512*3::],2) # xyの下位512bit A = (up\u0026lt;\u0026lt;512) + low # xy print(len(bin(A))-2) B = n-(A\u0026lt;\u0026lt;1024)-A # x^2+y^2 B = B\u0026gt;\u0026gt;512 C = B + 2*A # x^2+y^2 + 2xy = (x+y)^2 r,T = iroot(C,2) if T: phi = n + int(r)*(-a-1)+1 d = pow(e,-1,phi) m = pow(c,d,n) print(long_to_bytes(m)) 余談 ビットを回転させるネタは作問で考えたことがあった．\nRSALCG 問題 次のように線形合同法($z \\% n$は$z$を$n$で割ったあまりを表す)で乱数を生成し，それを$e$乗して$n$で割ったあまりを使って暗号化をしている． $$ \\begin{align} x_2 \u0026amp;= ax_1 + b \\pmod n \\\\ x_3 \u0026amp;= ax_2 + b \\pmod n \\\\ r_i \u0026amp;= x_{i}^e \\pmod n \\quad (i=1,2,3) \\\\ \\end{align} $$ $r_1$と$r_3$が得られるので$r_2$を求める問題．$a,b,n,e$も既知．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from Crypto.Util.number import getPrime, getRandomNBitInteger import os FLAG = os.getenv(\u0026#34;FLAG\u0026#34;, \u0026#34;RicSec{*** REDACTED ***}\u0026#34;).encode() def RSALCG(a, b, n): e = 65537 s = getRandomNBitInteger(1024) % n while True: s = (a * s + b) % n yield pow(s, e, n) def encrypt(rand, msg): assert len(msg) \u0026lt; 128 m = int.from_bytes(msg, \u0026#39;big\u0026#39;) return int.to_bytes(m ^ next(rand), 128, \u0026#39;big\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: n = getPrime(512) * getPrime(512) a = getRandomNBitInteger(1024) b = getRandomNBitInteger(1024) rand = RSALCG(a, b, n) print(f\u0026#34;{a = }\u0026#34;) print(f\u0026#34;{b = }\u0026#34;) print(f\u0026#34;{n = }\u0026#34;) print(encrypt(rand, b\u0026#34;The quick brown fox jumps over the lazy dog\u0026#34;).hex()) print(encrypt(rand, FLAG).hex()) print(encrypt(rand, b\u0026#34;https://translate.google.com/?sl=it\u0026amp;tl=en\u0026amp;text=ricerca\u0026#34;).hex()) 解法 $x_1$と$x_3$は線形な関係であるので $$ \\begin{align} x_3 \u0026amp;= ax_2 + b \\\\ \u0026amp;= a(ax_1 + b) + b \\\\ \u0026amp;= a^2x_1 + ab + b \\\\ \\end{align} $$ 次のような同じ根を持つ多項式が得られ，Franklin-Reiter\u0026rsquo;s Related Message Attackが使える(コードはネットからコピペ)．\n$$ \\begin{align} ax_1 + b - r_1 \u0026amp;= 0 \\pmod n \\\\ a^2x_1 + ab + b - r_3 \u0026amp;= 0 \\pmod n \\\\ \\end{align} $$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from Crypto.Util.number import bytes_to_long, getPrime, long_to_bytes, isPrime from gmpy2 import iroot def GCD(a,b): while b != 0: a, b = b, a % b return a e = 65537 a = 104932596701958568145159429432079350581741243925294416012169671604384908382893445168447905864839450402111868722373005467040643335329799448356719960809485814400987619457043584576651627652936429829564657705560266433066823589229257859375942917575729874731586891094997845427952093627170472382405528285663530612106 b = 146908709759837063143862302770110984437045635655026319928249954800644806528614554086681623417268963974691959251767647958752898163761641238519061717835899588252518767306816402052353874469376243689011218283173950163484015487529897260943257598915903245695362042234335492571429369281809958738989439275152307290506 n = 68915438454431862553872087841423255330382510660515857448975005472053459609178709434028465492773792706094321524334359097372292237742328589766664933832084854448986045922250239618283612819975877218019020936022572963433202427817150998352120028655478359887600473211365524707624162292808256010583620102295206287739 c1 = 0x05d7913ff5cd9b6a706249ac05779f2501013ecc05caec697d9270a8a1d3bdaabf898d73410aa0ffbd361a6032adbbfa35386b2e19ec812e9f6bd52e6a2ca1b3760b3076a86ffc94dd6007d74a272e0e3d5326d9e5b01b9211a803338f5899ad6cc29877cc02ca2ff923db79e3ad477bf3820e73596088f54a8cfb187f812201 c2 = 0x1913ba387e6f847dce455dc47092bf83571c34914b7df5875da536f11e68c8a39c78dfe69517ef4b389ea51434e071ce033854fd27c831996aa214cdc02225747a517d44408fbd0232672679bc189f26f6e9b6852a1e68e93ac14e2ce5afc1e050a44733094fe68b0477d4c4b609043e4da4e58390c4f9cf372005653c7f2529 c3 = 0x45054a08d594bd8af1d0fac759ccc799214d0ccce8ae9c5183ef4fba296819bcdf6306f72ee34dcd5d85967fae314d6d3d65a7693b4187adce1d5375dd00c472c0310393cd5bb114602e24d481e276a4926e8886bdcfed96bb8bf9c5812d594f66e46b1737849e8e2f2c3f7b6a45e284c754cf6caf71df34efe143636b5e9079 m1 = bytes_to_long(b\u0026#34;The quick brown fox jumps over the lazy dog\u0026#34;) m3 = bytes_to_long(b\u0026#34;https://translate.google.com/?sl=it\u0026amp;tl=en\u0026amp;text=ricerca\u0026#34;) r1 = c1 ^^ m1 r3 = c3 ^^ m3 # https://crypto.stackexchange.com/questions/30884/help-understanding-basic-franklin-reiter-related-message-attack s1 = (r1 * pow(a,e,n)) % n R.\u0026lt;X\u0026gt; = Zmod(n)[] f1 = (X - b)^e - s1 f2 = (a*X + b)^e - r3 # GCD is not implemented for rings over composite modulus in Sage # so we\u0026#39;ll do it ourselves. Might fail in rare cases, but we # don\u0026#39;t care. def my_gcd(a, b): return a.monic() if b == 0 else my_gcd(b, a % b) x1 = int(- my_gcd(f1, f2).coefficients()[0]) print (x1) r2 = pow((a*x1+b)%n,e,n) m2 = c2 ^^ r2 print(long_to_bytes(m2)) 余談 $e = 65537$に対して計算量が$O(e^2)$らしく，私のパソコンでは実行に30分くらいかかった．HalfGCDというテクニックを使うことでより高速になるらしい． あと，私はFranklin-Reiter\u0026rsquo;s Related Message Attackの中身は全く理解していない！\n繰り上がりを考慮するため\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-04-23T01:08:30+09:00","permalink":"https://shibaken28.github.io/my-blog-4/contents/ricercactf/","title":"RicercaCTF 2023 Writeup"},{"content":"TOEIC受けてきた TOEIC(2回目)を受けてきて，830点でした．前回比+160点でした． 700超えはマスト，できれば800超えたいと思っていたので良かったです．\n回 日付 L R 合計 1回目 2022/3/20 355 315 670 2回目 2023/1/29 455 375 830 各パートの手応え part1: わからん\npart2: わからなかったやつがいくつかあった\npart3: まあまあ\npart4: まあまあ\npart5: 品詞以外なんもわからん\npart6: まあまあ\npart7: わからん，基本的に全文読むようにしているが，最後の問題だけ全部読めなかった\nLは8割行ったかなーくらいの気持ちでした．Rは塗り絵はしなかったが別にわかったわけではないので6割，よくても7割くらいの気持ちでした． 直前に行った公式模試でもほぼ同じ感触でした．\n学習 1回目のTOEICと2回目のTOEICは1年くらい離れていますが，初めてTOEICを受験したときからずーっと英語の勉強をしていたわけではないです． 一方で，趣味の方(ゲームとか競プロ)でよく英語を見ているので潜在的には英語の知識は増えていたのかもしれません．意識して勉強し始めたのは2回目のTOEICの2,3週間前くらいです．\n以下，本の紹介です．\n公式TOEIC® Listening \u0026amp; Reading 問題集 8 TOEICの公式問題集です．2回分収録されていて，どちらもやりました．1回分は直前用に残しておくのがいいと思います．\nTOEIC®テスト 新形式精選模試 リーディングとTOEIC®テスト 新形式精選模試 リスニング 2冊です．1冊あたり5回分(100×5)の問題が収録されています． 問題は実際のTOEICよりも難しいと思います．リスニングをやってみましたが，公式問題集だと8割取れるのに，こちらだと6割しか取れませんでした． 2回分くらいしか使ってないです(もったいない)．\nリスニングに関しては，模試を何度もやって問題の形式に慣れるのが一番だと思います．\nTOEIC L \u0026amp; R TEST 出る単特急 金のフレーズ 非常に強力な単語帳だと感じます．一回目で670が取れたのもこれのおかげだと思います．私は少なくとも，600点レベルの単語は全ておさえています．\n私の単語の勉強方法です．writingはTOEICにないのと，時間がかかるのでやっていません．\n(例えば金フレだったら，)適当に勉強したい2～6ページくらいを選ぶ 選んだページを一気に読む，発音もする．最後まで読んだら，3.へ 赤シートで単語や例文の意味を隠しながら，単語や例文の意味を答えていく(英→和) 答えられなかった単語はチェックしておき，答えを確認して次の単語に移る 最後まで到達したら，チェックした単語のみで3.から5.を行う 一連の流れは割と短時間で終わると思います．これをひたすら繰り返します．\nあと，言い換え表現は要チェックです．\nTOEIC L\u0026amp;R TEST 出る問特急 金の文法 読んでみたら既に実践していることが割と書いてあったのであんまり読んでないです．文法問題は，フィーリングではなく，理屈で解いています．\nTOEIC L\u0026amp;R TEST 出る単特急 金のセンテンス 時間がなくてあんまり読んでないです(もったいない)．\n自分なりの傾向と対策 ここからは私の持論です．\nTOEICは「英語の地力」+「TOEIC対策力」でスコアが決まると思います． 「TOEIC対策力」というのは，TOEICへの向き合い方というか，自分なりの解き方のことで，これを確立させておくことで，TOEICのスコアが上がると思います．私自身，1回目と2回目の間でボキャブラが増えたとは思えないので，TOEIC対策力がスコアの向上につながったと思います．\n以下，私の解き方です．\n全体 ビジネス系の英語は，学校ではあまり扱われませんが，TOEICでは頻出です． supervisor, representative, conference room, confirm the contractみたいなやつです．これらは強めに押さえておきます．\n英文はスラッシュ読みをしています．\npart 1 わかりません．難しいです．捨てます．強いて言うのなら，聞こえない文章があったとしても，他に答えっぽい文章が聞こえたら，わざわざ聞こえなかった方を選ぶ必要はないと思います．\npart 2 疑問詞に全集中します．一番初めに聞こえる単語で，ボーっとしていると聞き逃してしまうので注意です． たまに，\u0026ldquo;Where ~?\u0026ldquo;の質問に対して\u0026quot;I don\u0026rsquo;t remember\u0026quot;とか，\u0026ldquo;Could you ~?\u0026ldquo;に\u0026quot;Sure\u0026quot;みたいに，非自明なものが答えな場合もありますが，これはフィーリングで補います．\npart 3, 4 質問，選択肢を先読みします．音声が始まったら，選択肢を凝視し，そこに含まれている単語が読まれないかを確認します．読まれたら，その選択肢を選びます．part3とpart4は，答えの単語を直接言っている場合が多いです．part2では，ひっかけが存在しますが，part3, 4ではひっかけをあまり見たことがないので，素直に聞こえたものを選ぶでいいと思います(もちろん，この方法だと，\u0026ldquo;some of drinks\u0026quot;という単語を言い換えて，\u0026ldquo;beverages\u0026quot;を選ぶような問題は解けませんが，これだけでもかなり点数が取れます)．\npart 4では，\u0026ldquo;Questions 71 through 73 refer to the following 〇〇\u0026quot;のように，〇〇の部分(telephone massageとか，boardcastなどが入る)で今から何の音声メッセージを聞かされるかがわかります．これをしっかり聞いて，状況の想像をします．\npart 5 品詞問題は，単語の意味を知らなくても解けることが多いのでしっかり取ります． 他の語彙問題は考えても無駄なのでランダムに選んでさっさと飛ばします．\npart 6 part6の文章は全て読んでいます．語彙はわからなければすぐにスキップします．\npart 7 part7の文章も全て読んでいます．part6,7で全文読むかどうかで派閥がありそうです．私は，部分的に読んでしまうと，わからない場合に周辺の文章を行ったり来たりして結局たくさん読むことになってしまうので，始めから全文読むようにしています．\n問題文の\u0026quot;Questions 176-180 refer to the following advertisement and e-mail.\u0026ldquo;からは，今から何を読まされるかがわかります．これをヒントにして，状況の想像をしやすくなります．e-mailであれば，送り主や宛先，件名にも目を通します．\nよくある質問 リスニングってどんくらい聞こえてるの？ あんまり聞こえてません．part1は結構何いってんの？ってなります．part2は疑問詞以外も聞こうとしていますがあんまり聞き取れません． part3,4は選択肢と聞こえる単語とのマッチングの作業をしているので，聞いても流している単語が多いです． 全部聞いて理解するのは無理だと割り切っています．\n全体的に英語の意味ってどんくらいわかってる？ 質問文に登場する単語は固定化されているので全てわかります(\u0026ldquo;Which is most likely ~?\u0026ldquo;みたいなやつ)．しかし，それ以外の場所では結構意味のわからない単語が出てきます．しかも，それが話の中心になっていることが多いので頭を悩ませます．想像力で補います．特に，part5の単語はほとんどわかりません．\n余談ですが，単語がわからないと思ったら人名とか地名だった，ということがあります．文頭や大文字には要注意です．\n日常で英語に触れている？ 趣味でプログラミングをしているときに，英語の公式レファレンスとかstackoverflowとかを見ることがあります． また，ゲームが好きなので，海外のインディーゲームのコミュニティや，海外の人の初見プレイ動画はよく観ます． 他には英語の歌も聴いています．\n感想 オンラインでの点数発表は受験日から17日後の正午とアナウンスされていますが，16日後の正午に発表されていました．これは今回だけではなく，毎回そうなっているらしいです．どちらにせよ，待ち時間が長くてしんどいです．\n","date":"2023-02-14T12:00:36+09:00","permalink":"https://shibaken28.github.io/my-blog-4/contents/toeic/","title":"TOEIC受けてきた"},{"content":"はじめに 強化学習(Reinforcement learning)の勉強をするにあたり，オイラリー・ジャパンから出版されているゼロから作るDeep Learning ❹を読んだ．理解を深めるため，勉強メモを書いた．\n目次 各見出しがそのまま記事へのリンクになっている1．番号が振られているが，本の章番号と対応しているわけではない．\n用語確認 ベルマン方程式 動的計画法 モンテカルロ法 TD法 ニューラルネットワーク(基本編) ニューラルネットワーク(実装編) (WIP) DQN 方策勾配法 (WIP) タイトル未定(ケーススタディ的なやつを書く) Extra Material (付録) 最後のExtra Materialには，記号や慣習のまとめや，数学に関する知識などが書いてある．\nその他 OpenAI Spinning Upの内容も参考にしている． このサイトは，ゼロから作るDeep Learning ❹の参考文献にもなっている．英語に強い抵抗がないのであれば，とても参考になる． ゼロから作るDeep Learning ❹はわかりやすかった． 「○○である」とか「○○してほしい」のように，おまえは何様なんだよという文体で書いてあるので，不快に感じたらごめんなさい． 「である」調にした深い理由はない． 参考文献 ゼロから作るDeep Learning ❹ OpenAI Spinning Up 感想 理論を理解する必要性 私自身，習うより慣れ派なので，さっさと実装して結果を見て，コード見て何をやっているか理解したいという気持ちが強かった．しかし，強化学習に関しては，理論を先に理解する必要があると感じた．ある問題を解くプログラムをあって，別の問題を解くプログラムへと応用したい場合に，理屈を理解していないと何をどう変えればいいのかが全くわからない．分野の性質上，正しく実装できたとしても良い結果が得られるとは限らない．また，変えられる場所が多かったり，そもそも手法が使えなかったり，手探りで動かしていくのはかなり難しい(完全に理解してからじゃないと実装できないというわけではない．なんとなく理解した時点で実装するのがじぶんに合っていた，ここら辺は個人差がありそう)．\nブログがこれ関連の記事で埋め尽くされるのを回避するため，記事一覧にはこのページしか表示されない\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-01-15T16:00:36+09:00","permalink":"https://shibaken28.github.io/my-blog-4/contents/rl-0/","title":"強化学習勉強メモ (目次)"},{"content":"フェルマーの小定理やオイラーの定理を使った問題は，CTFのCrypto問題でよく出ます(当社調べ)(そしてこのタイプの問題が一番楽しい)． それらを使った解いた問題の列挙です．難易度は独断と偏見でつけました．\n基本 フェルマーの小定理(Fermat\u0026rsquo;s little theorem)は素数$p$，整数$a$で $$ a^p \\equiv a \\pmod p \\quad (pは素数) $$ が成り立つことを言います． $a$が$p$と互いに素なことを条件に加えると，両辺を$a$で割った $$ a^{p-1} \\equiv 1 \\pmod p \\quad (pは素数，aはpと互いに素) $$ が成り立ちます．さらに両辺を$a$で割ると $$ a^{p-2} \\equiv a^{-1} \\pmod p \\quad (pは素数，aはpと互いに素) $$ となり，逆元になります．どの形もよく使います．\nオイラーの定理(Euler\u0026rsquo;s theorem)は先程の$p$を合成数$n$に拡張したもので，\n$$ a^{\\phi(n)} \\equiv 1 \\pmod n \\quad (nは合成数，aとnは互いに素) $$\nただし，$\\phi(n)$はオイラーのトーシェント関数(Euler\u0026rsquo;s totient function)と呼ばれる関数で，$1$以上$n$以下の数のうち$n$と互いに素な個数を表します． 式で表すと，合成数$n$の素因数分解が $$ n = \\prod_{i=1}^k p_i^{e_i} \\\\ $$ のとき $$ \\phi(n) = \\prod_{i=1}^k (p_{i}^{e_{i}} - p_{i}^{e_{i}-1}) $$ で定義されます．\nなお，注意として，フェルマーの小定理の指数$p-1$やオイラーの定理の$\\phi(n)$は$a$を$1$にする最小の数とは限りません．最小の数についてのカーマイケルの定理というものが存在します．\nちなみに，フェルマーの小定理ですが，フェルマーさんではなくゴットフリート・ライプニッツさんによって証明されたらしいです． また，フェルマーの最終定理と区別するために，「小」ついています．\nCakeCTF2022 frozen cake 難易度★★ 問題 問題ファイル\n素数$p,q$と平文$m$，$n=pq$から次の$a,b,c$の値が与えられる．$n$の値も与えられる． $$ \\begin{align} a \u0026amp;\\equiv m^p \\mod n \\\\ b \u0026amp;\\equiv m^q \\mod n \\\\ c \u0026amp;\\equiv m^n \\mod n \\end{align} $$\n解法 $px+qy=1 \\pmod{\\phi(n)}$となるような$x,y$が存在すれば，$m$を復元することができるが， $p$と$q$は$\\phi(n)$と互いに素ではないため，この手法は使えない．\n$c$を変形してみる．\n$$ n = (p-1)(q-1) + p+q-1 = \\phi(n) + p+q-1 \\\\ c \\equiv m^n \\equiv m^{\\phi(n) +p+q-1} \\equiv m^{p+q-1} \\equiv m^p m^q m^{-1}\\pmod n $$\nここで，$m^p,m^q\\pmod n$の値はわかっているので， $$ c a^{-1} b^{-1} \\equiv m^{-1} \\pmod n $$ これで$m^{-1}\\mod n$が求まり，これの逆数がフラグである．\n1 2 3 4 5 6 7 8 9 10 11 from Crypto.Util.number import inverse , long_to_bytes n = 101205131618457490641888226172378900782027938652382007193297646066245321085334424928920128567827889452079884571045344711457176257019858157287424646000972526730522884040459357134430948940886663606586037466289300864147185085616790054121654786459639161527509024925015109654917697542322418538800304501255357308131 a = 38686943509950033726712042913718602015746270494794620817845630744834821038141855935687477445507431250618882887343417719366326751444481151632966047740583539454488232216388308299503129892656814962238386222995387787074530151173515835774172341113153924268653274210010830431617266231895651198976989796620254642528 b = 83977895709438322981595417453453058400465353471362634652936475655371158094363869813512319678334779139681172477729044378942906546785697439730712057649619691929500952253818768414839548038664187232924265128952392200845425064991075296143440829148415481807496095010301335416711112897000382336725454278461965303477 c = 21459707600930866066419234194792759634183685313775248277484460333960658047171300820279668556014320938220170794027117386852057041210320434076253459389230704653466300429747719579911728990434338588576613885658479123772761552010662234507298817973164062457755456249314287213795660922615911433075228241429771610549 ainv = inverse(a,n) binv = inverse(b,n) minv = (c * ainv * binv)%n print(long_to_bytes(inverse(minv,n))) 1 CakeCTF{oh_you_got_a_tepid_cake_sorry} CakeCTF2021 together as one 難易度★★★ 問題概要 問題リンクファイル\n素数$p,q,r$があり，$e\\equiv65537$，フラグを$m$とし，次の値が与えられる． $$ n \\equiv pqr \\\\ c \\equiv m^e \\\\ x \\equiv (p+q)^r \\mod n \\\\ y \\equiv (p+qr)^r \\mod n $$\n解法 二項定理により，$x$の値について次の計算ができる． $n=pqr$であり，$0\u0026lt;x\u0026lt;r$のとき${}_r\\textrm{C}_x$が$r$の倍数であることを使っている． $$ \\begin{align} x \u0026amp;\\equiv (p+q)^r \\mod n \\\\ \u0026amp;\\equiv {}_r\\textrm{C}_0 p^rq^0 + {}_r\\textrm{C}_1 p^{r-1}q^1 + {}_r \\textrm{C}_2 p^{r-2}q^2 + \\cdots + {}_r\\textrm{C}_{r-1} p^1q^{r-1} + {}_r\\textrm{C}_{r} p^0q^{r-1} \\mod n \\\\ \u0026amp;\\equiv p^r + q^r \\mod n \\end{align} $$ $y$も同様に，展開をして$n$の倍数になる項を削除する． $$ \\begin{align} y \u0026amp;\\equiv (p+qr)^r \\mod n \\\\ \u0026amp;\\equiv p^r + q^rr^r \\mod n \\end{align} $$ 法$q$の世界で考える．すると， $$ \\begin{align} x \u0026amp;\\equiv p^r \\mod q\\\\ y \u0026amp;\\equiv p^r \\mod q \\end{align} $$ よって，整数$k$を用いると次が成り立つ $$ \\begin{align} x \u0026amp;\\equiv y \\mod q\\\\ x \u0026amp;\\equiv y + kq \\\\ x - y \u0026amp;\\equiv kq \\end{align} $$\n$x-y$は$q$の倍数であり，$n$も素因数$q$を持っているため，$q\\equiv\\textrm{GCD}(x-y,n)$である．\n次に，$x$と$y$を法$r$で考える．フェルマーの小定理により，$p^r \\mod r\\equiv p$が成り立つ(他の変数も同様)．\n$$ \\begin{align} x \\equiv p + q \\mod r\\\\ y \\equiv p \\mod r \\end{align} $$ $q$が邪魔だが既知であるため，$r$について合同な式ができる． $$ \\begin{align} x - q \\equiv y \\mod r\\\\ \\end{align} $$ よって，$r\\equiv\\textrm{GCD}(x-q-y,n/q)$である．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from Crypto.Util.number import long_to_bytes,inverse def GCD(a,b): if a%b==0: return b return GCD(b,a%b) def LCM(a,b): return a//GCD(a,b)*b n = # 長いので省略 c = x = y = e = 0x10001 q = GCD((x-y)%n,n) r = GCD((x-y-q)%n,n)//q p = n//r//q print(f\u0026#39;{p = :#}\u0026#39;) print(f\u0026#39;{q = :#}\u0026#39;) print(f\u0026#39;{r = :#}\u0026#39;) assert p*q*r == n phi = (p-1)*(q-1)*(r-1) d = pow(e,-1,phi) m = pow(c,d,n) print(long_to_bytes(m)) 1 CakeCTF{This_chall_is_inspired_by_this_music__Check_out!__https://www.youtube.com/watch?v=vLadkYLi8YE_cf49dcb6a31f} ImaginaryCTF October 2022 More pale 難易度★★ 問題 $N$と互いに素な$g,r$とフラグ$f$を使って$c$が計算される． $$ c = g^f\\times r^N \\pmod{N^2} $$\nただし，$N$は$32$ビット程度の素数を$32$個掛け算したものである(簡単のため，それぞれの素数は異なると考える)．\n$$ N = \\prod^{32}_{i=1} p_i \\quad (p_iは素数) $$\n解答 $r^N$が邪魔なのでどうにかして消したい． $\\pmod{N^2}$で$1$にするには，$\\phi(N^2)$乗する必要がある．$\\phi(N^2)$を計算してみると，$N$が出てくる．\n$$ \\begin{align} \\phi(N^2) \u0026amp;= \\prod^{32}_{i=1} (p_i^2 - p_i) \\\\ \u0026amp;= \\prod^{32}_{i=1} p_i(p_i-1) \\\\ \u0026amp;= \\prod^{32}_{i=1} p_i \\prod^{32}_{i=1} (p_i -1) \\\\ \u0026amp;= N \\cdot \\phi(N) \\end{align} $$ そのまま$c$を$\\phi(N^2)$乗すると$1$になってしまうが，既に$r$の$N$乗がかかっていることに注目すると，\n$$ \\begin{align} c^{\\phi(N)} \u0026amp;\\equiv g^{f\\phi(N)} r^{N\\phi(N)} \\pmod {N^2} \\\\ \u0026amp;\\equiv g^{f\\phi(N)} r^{\\phi(N^2)} \\pmod {N^2} \\\\ \u0026amp;\\equiv g^{f\\phi(N)} \\pmod {N^2} \\end{align} $$\nこれで，あとは$f\\phi(N)$が求められれば良いが，これは$N^2$が小さな素数の積であることから，Pohlig–Hellman法が使える．\n以下sageでの実装\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from Crypto.Util.number import * from math import prod, gcd N = 11426418812422762280036571700606763567947231773425157536629183225870745966201878199993626829615844927248091186921905998387334803393170756953004161976126607998422555566085789763646344981574364094148009230033109930017512774396115010409334288433850791978891238028784308896039614097042863945347168542666985383 g = 102370043738570361147512561430113690669375642568113520628837722692535092928991996894608072640673225251693957175347411184948751047776938223584014537703671208333116611432564769157326548350590167502807755716922970968951558696873031064519102939250266955847456094728415069300661910400192469539174495731756070447257875542560705682612568014282820199452851866020583046932239921789544226454615507571093721529079064029065323857243515917042869595396534609090834939823155439780919449771486541020286445222568415793241204876414692960607993360820654693596638939971884431900128125455066876042896836557800131056640691313737106 c = 103068079671149839873789585083110486503075572741609832823748309905209629934629965848822090939508870383106139073177857845426077799194203506965719179522047046491489575280275678232439148170329359273033661524521427411191787421596981639709353868254044119073231599736765796677163779301047698718070665219409437641669086148533724636988276093326307749151410207387960521848243363050042170628112380019384839142543642612905997234757798225958950399201463485580893790906185150849471016251892565658403504413779544907210377992966457602587448233119477078937422459927927859270682518316711143908453374720529830188577849652582868 ps = factor(N) phi = 1 phi2 = 1 for p,e in ps: phi *= p - 1 phi2 *= p**2 - p gf = pow(c,phi,N*N) print(gf) f = discrete_log(gf,Mod(g,N*N)) f = f//phi print(long_to_bytes(f)) 続く 良い問題を見つけ次第追加していきます．\n","date":"2022-12-19T00:00:00Z","permalink":"https://shibaken28.github.io/my-blog-4/contents/fermat/","title":"フェルマーの小定理に関する暗号の問題まとめ"},{"content":"順番は関係ないです．みんな知ってそうな曲は省いています．\nみたらしプラトニック (feat. nicamoq) この曲が気に入った方は，yunomiさんの他の曲もぜひ聴いてみてください． yunomiさんはK-pop(?)を連想させるエレクトロなサウンドと，ボーカルを組み合わせた曲が多いです．ボルテとの相性が最高なのでもっと収録されてほしい．\nアオアラシ チップチューン$\\times$スイングという全人類が好きなジャンルの曲です． サビの後にもう1フレーズ挟まったり，2回目のサビ前で音が籠もり静かになったり，「お前らこういうのが好きなんだろ」が詰まっています．\nFly Like You 三拍子のワルツ曲です．似たテイストのWith It This Heaven?という曲もあります．どちらも解禁曲です．\nConcertino in Blue プログレッシブなギタドラ曲です．ドラムでこれ出来たら楽しいんだろうな．\nTheme of Ricerca ノスタルジアの曲です．異世界の言語を使ったファンタジーな雰囲気のボーカル曲です． この作曲者のHuΣeR氏とボーカルのゆきまめ氏のペアの曲は他にも3曲あります\nPetite Queen (ノスタルジア) HEARTACHE (IIDX) Liar×Girl (jubeat) もっとたくさんくれ\nぱあ 教育NHKのEテレで放送されて話題になった曲です．嘘です．\nキミヱゴサーチ ひなビタ♪に出てくるここなつの曲です．DNAまで届く美しいハモリが最高です． なんと作曲者はsasakure.UKさんです．すげぇ． ここなつ曲ですが，他だと\nメモリーズ ムラサキグルマ コンフェイト＊コンチェルト (こういう感じのエロゲソングありそう) あたりがおすすめです．どれもボルテに収録されています．\nAIM HIGHER 不協和音感を感じそうになる不安定なボーカル曲です．アルティメットの課題曲です．\nAfterimage d\u0026rsquo;automne ノスタルジアの曲です．ネコを片手で撫でながらティーカップに注がれた紅茶を飲み，秋の夕暮れを眺めるような雰囲気の曲です．作曲者の猫又Master氏は似たテイストのFly far bounceという曲も作っています．ノスタルジアではもちろん，ギタドラでも楽しい曲です．\nフリコドウル かっこいいHIMEHINAの曲に，最上位レベルのクオリティの譜面がついています．\n","date":"2022-12-17T00:00:00Z","permalink":"https://shibaken28.github.io/my-blog-4/contents/sdvx-fav/","title":"Sound Voltex お気に入り曲"},{"content":"この記事はZennに投稿したものと同じです．\nはじめに 2Dの画面に3Dを描画することにロマンを感じませんか．私は感じます．描きましょう． なお，「なんちゃって3D」とタイトルにあるのは，遠くのものが小さく見えるような処理がないからです．ガチガチの3Dモデルを描きたい！という方が求めるようなものはない可能性が高いですし，厳密性には欠けるかもしれません．そういうものを求めている方にはごめんなさい．\nまた，この記事は長野高専アドベントカレンダー2022の8日目の記事です．\n環境 ジェネラティブアートの作品にしばしば使われるProcessingを使います．ProcessingはJavaベースの記法で簡単に図形を描画することができます．ダウンロードしてついてくるexeファイルを実行すればIDEが立ち上がり，すぐにコードを実行できます．\n余談ですが，長野高専の情報技術研究部ではProcessingを用いてプログラミング入門しています．\n原理 座標系 今回は，processingの$xy$平面に奥行き$z$を追加した座標系を考えます．すなわち，\n$x$軸の正の方向は右 $y$軸の正の方向は下 $z$軸の正の方向は奥 の座標系の世界で考えます．\n正面から見る 画面上で，手前から奥が$z$軸の方向になるわけですが，画面はもちろん平面であり，$z$座標の違いを表現しなければ手前と奥がわかりません．今回はこの違いを表現することを諦めます． 今回の手法は点$(1,2,3)$を描画したいときは$(1,2)$に点を打ちます．$(1,2,5)$を描画する場合も$(1,2)$に点を打ちます．つまり，$z$座標は完全に無視をします． もちろん，この方法で描画すると現実ではあり得ないような立体の見え方になってしまいます．$z$座標が全く違う場所に同じ形の立体を置いても，大きさの差が全く現れません．遠近法とかそんなものはありません．なんちゃって3Dだからいいのです1．\n別の角度から見る 各辺が各座標軸と平行な立方体を先程の手法で描画すると，ただの正方形が描かれます．「これは真正面から見た立方体です！3Dです！」と主張するのは無理がありますね．しかし，斜めから見た場合を描画するのは簡単ではないです．そこで，別の角度から見た場合の処理は諦めます．代わりに，立体自身が回転してもらいます．視点が動くのではなく，見えてる物体が動き，実質視点が動いているように見える，という状態です．自分が動いているのではない，世界が動いているんだ．\nz軸周りの回転 では，ここから回転をさせる方法を考えていきます．いきなり立方体を回転させるのは難しいので，点を回転させることを考えます．立体図形は点の集まりだと考えれば良いです．立方体であれば，$8$つの頂点があります．これらのそれぞれの点について回転させて，それらの点をつなげることで，回転した立方体が完成します．\nまず，$z$軸中心に点を回転したときの様子を数式で表します． $z$軸中心に点を回転させても，その$z$座標が変わらないので，これは$xy$平面の世界の回転だと考えることができます． $z$軸周りで$\\gamma$だけ回転されると座標$(x_0,y_0)$は次のような座標$(x,y)$に移動します．\n$$ x = x_0\\cos \\gamma - y_0\\sin \\gamma \\\\\\\\ y = x_0\\sin \\gamma + y_0\\cos \\gamma $$\nなぜこうなるかは，ベクトルの$(x_0,0)$と$(0,y_0)$を回転させることを考えるとわかります．$(x_0,0)$は$\\gamma$回転すると$(x_0\\cos \\gamma,x_0\\sin \\gamma)$に，$(0,y_0)$は$(-y_0\\sin \\gamma,y_0\\cos \\gamma)$に移動します．$(x_0,0)$と$(0,y_0)$を足したベクトル$(x_0,y_0)$を$\\gamma$回転させた結果は，$(x_0,0)$と$(0,y_0)$をそれぞれ$\\gamma$回転させてから足したものと等しいです．よって上記の式が示せます．\nx,y軸周りの回転 $z$軸周りのときの$x,y$を$y,z$とか$z,x$に置き換えれば良いです2． $x$軸周りに$\\alpha$回転したときは\n$$ y = y_0\\cos \\alpha - z_0\\sin \\alpha \\\\\\\\ z = y_0\\sin \\alpha + z_0\\cos \\alpha $$\n$y$軸周りに$\\beta$回転したときは\n$$ z = z_0\\cos \\beta - x_0\\sin \\beta \\\\\\\\ x = z_0\\sin \\beta + x_0\\cos \\beta $$\nで表されます．\n行列での表現 行列で表現しておくと，行列の積によって回転の組み合わせが行えるため，便利です．このような行列を回転行列と呼びます．\n$$ A_x(\\alpha) = \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; \\cos \\alpha \u0026amp; - \\sin \\alpha \\\\ 0 \u0026amp; \\sin \\alpha \u0026amp; \\cos \\alpha \\end{pmatrix} \\\\\\\\ A_y(\\beta) = \\begin{pmatrix} \\cos \\beta \u0026amp; 0 \u0026amp; \\sin \\beta \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ -\\sin \\beta \u0026amp; 0 \u0026amp; \\cos \\beta \\end{pmatrix} \\\\\\\\ A_z(\\gamma) = \\begin{pmatrix} \\cos \\gamma \u0026amp; - \\sin \\gamma \u0026amp; 0 \\\\ \\sin \\gamma \u0026amp; \\cos \\gamma \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{pmatrix} $$\n座標$X=^t(1,2,3)$を$z$軸周りに$90^\\circ$回転させたい場合，$A_z(90^\\circ)$を$X$の左から掛け算します．具体的には次の計算をします．\n$$ A_z(90^\\circ)X = \\begin{pmatrix} \\cos 90^\\circ \u0026amp; - \\sin 90^\\circ \u0026amp; 0 \\\\ \\sin 90^\\circ \u0026amp; \\cos 90^\\circ \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\\\ \\end{pmatrix} = \\begin{pmatrix} 0 \u0026amp; -1 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 2 \\\\ 3 \\\\ \\end{pmatrix} = \\begin{pmatrix} -2 \\\\ 1 \\\\ 3 \\\\ \\end{pmatrix} $$\n$z$軸周りに$90^\\circ$回転させて，さらに$x$軸周りに$30^\\circ$回転させた座標は，$A_x(30^\\circ)A_z(90^\\circ)X$で表されます．左から掛け算されていることに注意です3．\n平行移動 原点から離れた場所に立体を置いてから回転させると，回転の軸が原点を通っているため立体の場所が移動します．これは，その場で回転させたい場合に不便です．その場合は，\n原点中心に立体を配置 欲しい角度に回転させる 平行移動させる のステップが必要です．面倒ですね．スッキリさせたいです． 行列の次元数を$1$増やして定数を足すテクニックを使い，次のように平行移動も行列で表現します．\n$$ \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; d_x \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; d_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; d_z \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{pmatrix} \\begin{pmatrix} x_0 \\\\ y_0 \\\\ z_0 \\\\ 1 \\\\ \\end{pmatrix} = \\begin{pmatrix} x_0 + d_x \\\\ y_0 + d_y \\\\ z_0 + d_z \\\\ 1 \\\\ \\end{pmatrix} $$\n$x$軸周りに$\\alpha$回転させて$(d_x,d_y,d_z)$だけ平行移動させた座標は次のようになります．\n$$ \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; d_x \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; d_y \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; d_z \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{pmatrix} \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; \\cos \\alpha \u0026amp; - \\sin \\alpha \u0026amp; 0 \\\\ 0 \u0026amp; \\sin \\alpha \u0026amp; \\cos \\alpha \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{pmatrix} \\begin{pmatrix} x_0 \\\\ y_0 \\\\ z_0 \\\\ 1 \\\\ \\end{pmatrix} $$ 左の$2$つの行列の積を事前に計算しておくことで，$\\alpha$回転させて$(d_x,d_y,d_z)$平行移動させるような行列が得られるため，あとはこれを掛け算するだけで一連の移動が可能になります．頂点が複数ある立体を移動させるときに便利です．\nこのように行列の積を扱うことで，平行移動させて回転させて平行移動させて回転させて\u0026hellip;みたいな複雑な座標変換も可能です．複数のオブジェクトを配置したあとに，視点を移動させるためにさらに平行移動と回転を加える，といったことができます．\nこのように座標を表すベクトルに行列を掛け算させるて座標を移動させることを座標変換といい，その行列のことを変換行列と呼びます．また，この掛け算をベクトルに変換行列を作用させる，といいます．\n行列の積は交換法則が成り立ちません．行列の掛け算の順序には注意が必要です．\n平行移動をしたあとに回転させた場合と 回転させたあとに平行移動した場合の結果は異なります． 実装 $4$次の正方行列に関する次の機能を作ります．行列は$4\\times 4$のfloat型の配列で作ります．\n行列の積 単位行列の生成 各軸周りの回転行列の生成 平行移動するための変換行列の生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 float[][] MatrixMul(float A[][], float B[][]) { float [][] Mat = new float [4][4]; for (int i=0; i\u0026lt;4; i++) { for (int j=0; j\u0026lt;4; j++) { for (int k=0; k\u0026lt;4; k++) { Mat[i][j] += A[i][k]*B[k][j]; } } } return Mat; } float[][] MatrixI() { float [][] Mat = new float [4][4]; Mat[0][0] = 1; Mat[1][1] = 1; Mat[2][2] = 1; Mat[3][3] = 1; return Mat; } float[][] MatrixRotateX(float a) { float [][] Mat = new float [4][4]; Mat[0][0] = 1; Mat[1][1] = cos(a); Mat[1][2] = -sin(a); Mat[2][1] = sin(a); Mat[2][2] = cos(a); Mat[3][3] = 1; return Mat; } float[][] MatrixRotateY(float a) { float [][] Mat = new float [4][4]; Mat[0][0] = cos(a); Mat[0][2] = sin(a); Mat[1][1] = 1; Mat[2][0] = -sin(a); Mat[2][2] = cos(a); Mat[3][3] = 1; return Mat; } float[][] MatrixRotateZ(float a) { float [][] Mat = new float [4][4]; Mat[0][0] = cos(a); Mat[0][1] = -sin(a); Mat[1][0] = sin(a); Mat[1][1] = cos(a); Mat[2][2] = 1; Mat[3][3] = 1; return Mat; } float[][] MatrixMove(Vector3D v) { float [][] Mat = new float [4][4]; Mat[0][0] = 1; Mat[1][1] = 1; Mat[2][2] = 1; Mat[3][3] = 1; Mat[0][3] = v.x; Mat[1][3] = v.y; Mat[2][3] = v.z; return Mat; } void printMatrix(float[][] mat) { for (int i=0; i\u0026lt;4; i++) { for (int j=0; j\u0026lt;4; j++) { print(mat[i][j]); print(\u0026#34;, \u0026#34;); } print(\u0026#34;\\n\u0026#34;); } } また，$3$次元の点が扱えるようにVector3Dクラスを作ります．行列を作用させた点を返すactMatrixメソッドも作っておきます．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Vector3D { float x, y, z; Vector3D(float _x, float _y, float _z) { this.x = _x; this.y = _y; this.z = _z; } Vector3D actMatrix(float Mat[][]) { Vector3D p = new Vector3D(0, 0, 0); p.x = this.x * Mat[0][0] + this.y * Mat[0][1] + this.z * Mat[0][2] + Mat[0][3]; p.y = this.x * Mat[1][0] + this.y * Mat[1][1] + this.z * Mat[1][2] + Mat[1][3]; p.z = this.x * Mat[2][0] + this.y * Mat[2][1] + this.z * Mat[2][2] + Mat[2][3]; return p; } } グローバル変数として，transformMatrixを用意してます．各描画関数では$3$次元の点を受け取り，この行列transformMatrixを作用させて得られる点を使って描画するようにします．次の例ではline3D関数を実装しています．また，時間tもグローバル変数として用意しておきます．\n1 2 3 4 5 6 7 8 9 10 float transformMatrix[][] = new float [4][4]; float t = 0; void line3D(Vector3D p1, Vector3D p2) { Vector3D a1 = p1.actMatrix(transformMatrix); Vector3D a2 = p2.actMatrix(transformMatrix); //ellipse(a1.x, a1.y, 10, 10); 頂点 //ellipse(a2.x, a2.y, 10, 10); line(a1.x, a1.y, a2.x, a2.y); } あとはdraw関数に適当な内容を書いて完成です．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void draw(){; t += 1; background(0); translate(width/2, height/2); int s = 50; transformMatrix = MatrixI(); float mat1[][] = MatrixRotateX(t*0.1); float mat2[][] = MatrixRotateY(t*0.1); transformMatrix = MatrixMul(mat2, transformMatrix); transformMatrix = MatrixMul(mat1, transformMatrix); Vector3D p1 = new Vector3D(-s, -s, s); Vector3D p2 = new Vector3D(-s, s, s); Vector3D p3 = new Vector3D(s, s, s); Vector3D p4 = new Vector3D(s, -s, s); Vector3D p5 = new Vector3D(-s, -s, -s); Vector3D p6 = new Vector3D(-s, s, -s); Vector3D p7 = new Vector3D(s, s, -s); Vector3D p8 = new Vector3D(s, -s, -s); stroke(255); strokeWeight(3); line3D(p1, p2); line3D(p2, p3); line3D(p3, p4); line3D(p4, p1); line3D(p5, p6); line3D(p6, p7); line3D(p7, p8); line3D(p8, p5); line3D(p1, p5); line3D(p2, p6); line3D(p3, p7); line3D(p4, p8); } 遊ぶ キーボード(WASD)を押すと正八面体を回転させることができるサンプルです． コピペで動きます．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 float t = 0; float transformMatrix[][] = new float [4][4]; float alpha=0, beta=0, gamma=0; float[][] MatrixMul(float A[][], float B[][]) { float [][] Mat = new float [4][4]; for (int i=0; i\u0026lt;4; i++) { for (int j=0; j\u0026lt;4; j++) { for (int k=0; k\u0026lt;4; k++) { Mat[i][j] += A[i][k]*B[k][j]; } } } return Mat; } float[][] MatrixI() { float [][] Mat = new float [4][4]; Mat[0][0] = 1; Mat[1][1] = 1; Mat[2][2] = 1; Mat[3][3] = 1; return Mat; } float[][] MatrixRotateX(float a) { float [][] Mat = new float [4][4]; Mat[0][0] = 1; Mat[1][1] = cos(a); Mat[1][2] = -sin(a); Mat[2][1] = sin(a); Mat[2][2] = cos(a); Mat[3][3] = 1; return Mat; } float[][] MatrixRotateY(float a) { float [][] Mat = new float [4][4]; Mat[0][0] = cos(a); Mat[0][2] = sin(a); Mat[1][1] = 1; Mat[2][0] = -sin(a); Mat[2][2] = cos(a); Mat[3][3] = 1; return Mat; } float[][] MatrixRotateZ(float a) { float [][] Mat = new float [4][4]; Mat[0][0] = cos(a); Mat[0][1] = -sin(a); Mat[1][0] = sin(a); Mat[1][1] = cos(a); Mat[2][2] = 1; Mat[3][3] = 1; return Mat; } float[][] MatrixMove(Vector3D v) { float [][] Mat = new float [4][4]; Mat[0][0] = 1; Mat[1][1] = 1; Mat[2][2] = 1; Mat[3][3] = 1; Mat[0][3] = v.x; Mat[1][3] = v.y; Mat[2][3] = v.z; return Mat; } void printMatrix(float[][] mat) { for (int i=0; i\u0026lt;4; i++) { for (int j=0; j\u0026lt;4; j++) { print(mat[i][j]); print(\u0026#34;, \u0026#34;); } print(\u0026#34;\\n\u0026#34;); } } class Vector3D { float x, y, z; Vector3D(float _x, float _y, float _z) { this.x = _x; this.y = _y; this.z = _z; } Vector3D actMatrix(float Mat[][]) { Vector3D p = new Vector3D(0, 0, 0); p.x = this.x * Mat[0][0] + this.y * Mat[0][1] + this.z * Mat[0][2] + Mat[0][3]; p.y = this.x * Mat[1][0] + this.y * Mat[1][1] + this.z * Mat[1][2] + Mat[1][3]; p.z = this.x * Mat[2][0] + this.y * Mat[2][1] + this.z * Mat[2][2] + Mat[2][3]; return p; } } void line3D(Vector3D p1, Vector3D p2) { Vector3D a1 = p1.actMatrix(transformMatrix); Vector3D a2 = p2.actMatrix(transformMatrix); ellipse(a1.x, a1.y, 10, 10); ellipse(a2.x, a2.y, 10, 10); line(a1.x, a1.y, a2.x, a2.y); } void ellipse3D(Vector3D p,float r){ Vector3D a = p.actMatrix(transformMatrix); ellipse(a.x, a.y, r , r); } void setup() { size(500, 500); frameRate(50); // 50fpsでアニメーションする } void draw() { t += 0.1; background(0); translate(width/2, height/2); for(int i=1;i\u0026lt;=1;i++){ int s = 70 + i*50; transformMatrix = MatrixI(); float mat1[][] = MatrixRotateY(i*PI/2+alpha); float mat2[][] = MatrixRotateX(beta); float mat3[][] = MatrixRotateZ(gamma); transformMatrix = MatrixMul(mat1, transformMatrix); transformMatrix = MatrixMul(mat2, transformMatrix); transformMatrix = MatrixMul(mat3, transformMatrix); stroke(255); Vector3D p1 = new Vector3D (s,s,0); Vector3D p2 = new Vector3D (s,-s,0); Vector3D p3 = new Vector3D (-s,-s,0); Vector3D p4 = new Vector3D (-s,s,0); Vector3D p5 = new Vector3D (0,0,sqrt(2)*s); Vector3D p6 = new Vector3D (0,0,-sqrt(2)*s); line3D(p1,p2); line3D(p2,p3); line3D(p3,p4); line3D(p4,p1); line3D(p1,p5); line3D(p2,p5); line3D(p3,p5); line3D(p4,p5); line3D(p1,p6); line3D(p2,p6); line3D(p3,p6); line3D(p4,p6); } } void keyPressed(){ if(key == \u0026#39;d\u0026#39;){ alpha += 0.1; } if(key == \u0026#39;a\u0026#39;){ alpha -= 0.1; } if(key == \u0026#39;w\u0026#39;){ beta += 0.1; } if(key == \u0026#39;s\u0026#39;){ beta -= 0.1; } } 余談 こちらのつぶやきProcessingは回転行列を作用させるような計算をして作りました． https://twitter.com/Shibak33333333n/status/1418192071987400713\nあとがき 3Dで描画できる環境を使えばいい話なのですが，ロマンがありますね．\nなんちゃって3Dとか書いてしまいましたが，製図の分野などで，キャビネット図や等角図という名前で使われます．\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n厳密には，どちらが正の方向の回転であるかをよく考える必要がありますが，今回は無視します\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n$X$を列ベクトルではなく行ベクトルとして用意することで右から行列を掛け算する流派(この場合は回転行列が転置します)も存在します．\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-12-06T02:00:00Z","permalink":"https://shibaken28.github.io/my-blog-4/contents/processing/","title":"2D画面になんちゃって3Dを書く"},{"content":"この記事はZennに投稿したものと同じです．\nこれはなに 行列累乗と呼ばれる競プロのテクニックの概要と，それを用いる例をひたすら挙げていきます．競プロチックな話題ではありますが，行列が役立つ場面の例の紹介として，非競プロerでも楽しめると思います．ただし，数列と行列に関する用語がある程度わかっている人向けです．\nなお，この記事は長野高専 Advent Calender 2022の2日目の記事です。\n原理(フィボナッチ数列の例) 次の式で表される数列を考えます．\n$$ \\begin{align} F_1 \u0026amp;= 1 \\\\ F_2 \u0026amp;= 1 \\\\ F_n \u0026amp;= F_{n-1} + F_{n-2} \\quad　(n \\geq 3) \\end{align} $$\nこれはフィボナッチ数列という名で知られている，$F=(1,1,2,3,5,8,13,21,34,\\cdots)$という前の$2$項の和が次の項になる数列です．これの第$n$項目をプログラミングで求めることにします．第$1$項目から第$n$項目までを求めるのではなく，第$n$項目のみ求めれば良いことに注意です．それっぽいコードを次に示します．\n1 2 3 4 5 6 //F[i]:=フィボナッチ数列のi項目 F[1] = 1; F[2] = 1; for(int i=3;i\u0026lt;=n;i++){ F[i] = F[i-1] + F[i-2]; } for文を$n$回くらい回すので計算量は$O(n)$です(計算量についてこちら1を参照してください)．\nでは，$n=10^{15}$項目を求めたい場合はどうでしょうか．このコードでは，実行が終わりません．\n行列で表現する ここで，行列です．フィボナッチ数列の定義より，次の式は成り立ちます．\n$$ \\begin{pmatrix} F_{n} \\\\ F_{n-1} \\end{pmatrix} = \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} \\begin{pmatrix} F_{n-1} \\\\ F_{n-2} \\end{pmatrix} $$\n具体的に計算してみます．\n$$ \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} $$\n$$ \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} $$\n$$ \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix} $$\n前の$2$項から次の項が生成されていることがわかりますね． これらの結果を使って次のような変形を考えます．\n$$ \\begin{align} \\begin{pmatrix} 5 \\\\ 3 \\end{pmatrix} \u0026amp;= \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} \\begin{pmatrix} 3 \\\\ 2 \\end{pmatrix} \\\\ \u0026amp;= \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix} \\\\ \u0026amp;= \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\\\ \u0026amp;= \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} ^3 \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\end{align} $$\n始めの$2$項に同じ行列を$3$回掛け算することで3つ後の項が出てきました．これを繰り返すと次が成り立つことがわかります．\n$$ \\begin{align} \\begin{pmatrix} F_n \\\\ F_{n-1} \\end{pmatrix} \u0026amp;= \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} ^{n-2} \\begin{pmatrix} F_2 \\\\ F_1 \\end{pmatrix} \\end{align} $$\n第$10$項目を求めたいときは次のように計算できます．\n$$ \\begin{align} \\begin{pmatrix} F_{10} \\\\ F_{9} \\end{pmatrix} \u0026amp;= \\begin{pmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{pmatrix} ^{8} \\begin{pmatrix} F_2 \\\\ F_1 \\end{pmatrix} \\\\ \u0026amp;= \\begin{pmatrix} 89 \u0026amp; 55 \\\\ 55 \u0026amp; 34 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\\\ \u0026amp;= \\begin{pmatrix} 144 \\\\ 89 \\end{pmatrix} \\end{align} $$\nフィボナッチ数列は$1,1,2,3,5,8,13,21,34,55,89,144,\\cdots$であるため，確かにあっています． 便利そうな式が行列によって完成しました．漸化式の悪いところは前の項の値がわかっていないと次の項が計算できないことですが，この式は特定の項をダイレクトに表すことに成功しています．行列の$n$乗が高速に計算できればフィボナッチ数列の第$n$項が高速に計算できそうです．\n累乗の高速計算 行列$A$の$n$乗である$A^n$を計算するのに，ナイーブな方法だと$n-1$回の行列同士の掛け算が発生します．この行列同士の掛け算の回数が少なくなることを高速化と呼ぶことにします． $A^{128}$を考えてみましょう．\n$A$に$A$をかけて$A^2$ $A^2$に$A$をかけて$A^3$ $\\cdots$ $A^{127}$に$A$をかけて$A^{128}$ 全部で$127$回の掛け算が必要ですね．では，$128$という特徴的な数に注目して次のように計算したらどうでしょうか．\n$A$に$A$をかけて$A^2$ $A^2$に$A^2$をかけて$A^4$ $A^4$に$A^4$をかけて$A^8$ $A^{8}$に$A^{8}$をかけて$A^{16}$ $A^{16}$に$A^{16}$をかけて$A^{32}$ $A^{32}$に$A^{32}$をかけて$A^{64}$ $A^{64}$に$A^{64}$をかけて$A^{128}$ 全部で，$7$回の掛け算で$A^{128}$が計算できました．$127$回から$7$回という驚異の回数削減です． 実は，これは$128$のような$2$の冪数に限った話ではありません．先程，$A^1,A^2,A^4,A^8,A^{16},\\cdots$を求めましたが，これらを掛け合わせることで任意の$A^n$が計算できます(指数法則$A^aA^b=A^{a+b}$が成り立つことに注意)．\n$A^{12} = A^{8} A^{4}$ $A^{39} = A^{32} A^{4} A^{2} A^{1}$ $A^{127} = A^{64}A^{32}A^{16}A^{8}A^{4}A^{2}A^{1}$ これらは，$Aの(2進数表記したとき，1である位)乗$を掛け算したものになっています． 上の例では，$12_{(10)}=1100_{(2)}$であり，$1$である位は$4$の位と$8$の位なので$12=8+4$と$12$を$2$の冪数の和で表すことができます． このような手法をダブリングや繰り返し二乗法と呼びます．\nそれっぽいコードを次に示します．計算量は$O(\\log N)$です．$O(N)$に比べて非常に高速です2．\n1 2 3 4 5 6 7 8 9 10 // AのB乗の計算結果をCの格納 C = I //Iは単位行列 tmp = A while(B\u0026gt;0){ if(B%2==1){ C = C * tmp } B/=2; tmp = tmp * tmp } Pythonでの汚い実装例も示します．\n愚直パターン 1 2 3 4 5 6 7 8 n = 10000 f = [0]*(n+1) f[1] = 1 f[2] = 1 for i in range(3, n+1): f[i] = f[i-1] + f[i-2] print(f\u0026#34;第{n}項目は{f[n]}です\u0026#34;) 高速化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def mat_mul(a, b) : I, J, K = len(a), len(b[0]), len(b) c = [[0] * J for _ in range(I)] for i in range(I) : for j in range(J) : for k in range(K) : c[i][j] += a[i][k] * b[k][j] return c def mat_pow(x, n): y = [[0] * len(x) for _ in range(len(x))] for i in range(len(x)): y[i][i] = 1 while n \u0026gt; 0: if n \u0026amp; 1: y = mat_mul(x, y) x = mat_mul(x, x) n //= 2 return y ret = [[1],[1]] mat = [[1,1],[1,0]] n = 10000 ret = mat_mul(mat_pow(mat, n-2), ret) print(f\u0026#34;第{n}項目は{ret[0][0]}です\u0026#34;) 線形漸化式 フィボナッチ数列は$2$項間の漸化式でしたが，$k$項間の線形漸化式でも可能です．\n3項の場合 次で定義される数列$a$の$n$項目を求めよ．\n$$ \\begin{align} a_1 \u0026amp;= a_2 = a_3 = 1 \\\\ a_n \u0026amp;= 2a_{n-1} - 4a_{n-2} + 3a_{n-3}\\quad　(n \\geq 4) \\end{align} $$\nこの漸化式は次のような行列で表されます．\n$$ \\begin{align} \\begin{pmatrix} a_n \\\\ a_{n-1} \\\\ a_{n-2} \\end{pmatrix} \u0026amp;= \\begin{pmatrix} 2 \u0026amp; -4 \u0026amp; 3\\\\ 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\end{pmatrix} ^{n-3} \\begin{pmatrix} a_3 \\\\ a_2 \\\\ a_1 \\end{pmatrix} \\end{align} $$\n実際に行列を計算すると確かに成立していることがわかります．\n一般に，$k+1$項間の漸化式は$k\\times k$の行列を使って表され，$k\\times k$の行列同士の掛け算は$k^3$回の掛け算が必要であるため，第$n$項を求めるのに$O(k^3\\log n)$かかります．\nなお，$k+1$項間の線形漸化式の第$n$項はkitamasa法と呼ばれる手法で$(k^2\\log n)$で求めることが可能です．こちらもダブリングを使った手法です．\n定数項がある場合 $a,b,m,x_0$を使って線形合同法で乱数を生成する．このときの$n$番目の乱数$x_n$を求めよ ただし，線形合同法とは，\n$$ x_{i+1} = ax_i + b \\pmod m $$\nの漸化式で疑似乱数を生成する手法である．\n定数項がある場合は$1$の行を付け足して次のように作ることができます．\n$$ \\begin{align} \\begin{pmatrix} x_n \\\\ 1 \\\\ \\end{pmatrix} \u0026amp;= \\begin{pmatrix} a \u0026amp; b\\\\ 0 \u0026amp; 1 \\end{pmatrix} ^{n} \\begin{pmatrix} x_0 \\\\ 1 \\end{pmatrix} \\end{align} $$\n複数変数の線形漸化式 複数の変数で表される漸化式にも応用できます\n平方根を含む数の累乗 次の問題を考えます．\n$(2+\\sqrt{3})^n$はいくつか？$a+b\\sqrt{3}$の形式になるので$a,b$を求めよ．\n$n$が大きいと展開が厄介になりそうなことが想像できますね． とりあえず，$2+\\sqrt{3}$の累乗を次のように文字で置きます．\n$$ X_n = (a_n + b_n\\sqrt{3}) $$\n$X_n$から$X_{n+1}$を計算してみます．\n$$ \\begin{align} X_{n+1} \u0026amp;= X_n (2 + \\sqrt{3}) \\\\ \u0026amp;= (a_n + b_n \\sqrt{3})(2 + \\sqrt{3}) \\\\ \u0026amp;= 2a_n + a_n \\sqrt{3} + 2b_n \\sqrt{3} + 3b_n \\\\ \u0026amp;= (2a_n + 3b_n) + (a_n + 2b_n)\\sqrt{3} \\\\ \u0026amp;= a_{n+1} + b_{n+1} \\sqrt{3} \\end{align} $$\n最後の二行の係数を比較して，次の漸化式が立ちます．\n$$\n\\begin{align} a_1\u0026amp;=b_1=1 \\\\ a_{n+1} \u0026amp;= 2a_{n} + 3b_n \\\\ b_{n+1} \u0026amp;= a_n + 2b_n \\end{align}\n$$\nこれを行列にすると次のようになります．\n$$ \\begin{align} \\begin{pmatrix} a_n \\\\ b_n \\end{pmatrix} \u0026amp;= \\begin{pmatrix} 2 \u0026amp; 3\\\\ 1 \u0026amp; 2 \\end{pmatrix} ^{n-1} \\begin{pmatrix} a_1 \\\\ b_1 \\end{pmatrix} \\end{align} $$\n確率 次の問題を考えます．\nエアコンのスイッチの状態は$OFF$である．遠隔操作を1回行うと確率$p$でエアコンの$ON$と$OFF$が入れ替わる．$n$回遠隔操作をしたときエアコンが$ON$である確率を求めよ．($N\\leq 10^{18}$)　出典 CODE FESTIVAL 2014 Middle C - eject\n次のように変数を設定します． $a_i = i$回目の遠隔操作をしたときにエアコンが$ON$である確率 $b_i = i$回目の遠隔操作をしたときにエアコンが$OFF$である確率 漸化式は次のように立ちます．\n$$ a_i = p b_{i-1} + (1-p)a_{i-1} \\\\ b_i = p a_{i-1} + (1-p)b_{i-1} \\\\ $$\n行列にします．ただし，$a_0=0,b_0=1$です．\n$$ \\begin{align} \\begin{pmatrix} a_n \\\\ b_n \\end{pmatrix} \u0026amp;= \\begin{pmatrix} 1-p \u0026amp; p\\\\ p \u0026amp; 1-p \\end{pmatrix} ^{n} \\begin{pmatrix} a_0 \\\\ b_0 \\end{pmatrix} \\end{align} $$\n今までのものは全て，小さな問題の答えから大きな問題の答えを導くdp(dynamic programming:動的計画法)に分類されます．dpの漸化式が立ったときに，それが線形であり，同じ遷移をする場合に行列累乗が有効なことが多いです．\nグラフのパス数 EDPC R - Walk\n$N$頂点の単調有効グラフ$G$で，長さ$1$の有向辺が長さ$K$のパスは何通りありますか．ただし同じ頂点を複数回通っても良い\n$N$次の正方行列で，頂点$i$から頂点$j$までの有向辺があれば$A_{ij}=1$，なければ$A_{ij}=0$となるような隣接行列を考えます．\n例えば，次の$4$頂点のグラフを隣接行列にすると次のようになります．\n$$ A = \\begin{align} \\begin{pmatrix} 0 \u0026amp;1 \u0026amp;0 \u0026amp;1 \\\\ 0 \u0026amp;0 \u0026amp;1 \u0026amp;0 \\\\ 0 \u0026amp;1 \u0026amp;0 \u0026amp;0 \\\\ 0 \u0026amp;0 \u0026amp;0 \u0026amp;1 \\end{pmatrix} \\end{align} $$\nこのとき，頂点$i$から頂点$j$へのパス数は次のように計算できます．\n$$ (頂点iから頂点jへのパス数) = \\sum {k=1}^4 A{ik} A_{kj} $$\nこれは，行列の積の定義とよく似ていて，$A^2$の$(i,j)$成分は，頂点$i$から頂点$j$への長さ$2$のパス数を表します．よって，$A^n$の$i,j$成分から頂点$i$から$j$までの長さ$n$のパス数を求めることができます．\nなお，無向グラフの場合は双方向に有向辺が張っていると考え，$A_{ij}=A_{ji}$とすることで同様に処理できます．\n行列の級数 正方行列$A$がある．$A+A^2+A^3+A^4+A^5+\\cdots+A^N$を求めよ．\n次のように$X_n$を定義します．\n$$ X_n = A^1 + A^2 + A^3 + \\cdots + A^n $$\n漸化式は次のように作れます．\n$$ \\begin{align} X_1 \u0026amp;= A\\\\ X_n \u0026amp;= A+AX_{n-1} \\quad (n\\geq 2) \\end{align} $$\nよって，\n$$ \\begin{align} \\begin{pmatrix} X_n \\\\ \\hline I \\end{pmatrix} \u0026amp;= \\begin{pmatrix} \\begin{array}{c|c} A \u0026amp; A\\\\ \\hline O \u0026amp; I \\end{array} \\end{pmatrix} ^{n-1} \\begin{pmatrix} A \\\\ \\hline I \\end{pmatrix} \\end{align} $$\nです．\n半環 普通，行列の掛け算は次のように定義されています．\n$$ A = \\begin{align} \\begin{pmatrix} a_{11} \u0026amp; a_{12} \\\\ a_{21} \u0026amp; a_{22} \\end{pmatrix} \\begin{pmatrix} b_{11} \u0026amp; b_{12} \\\\ b_{21} \u0026amp; b_{22} \\end{pmatrix} = \\begin{pmatrix} a_{11}\\cdot b_{11}+a_{12}\\cdot b_{21} \u0026amp; a_{11}\\cdot b_{12}+a_{12}\\cdot b_{22} \\\\ a_{21}\\cdot b_{11}+a_{22}\\cdot b_{21} \u0026amp; a_{21}\\cdot b_{12}+a_{22}\\cdot b_{22} \\end{pmatrix} \\end{align} $$\nそれぞれ要素の積を計算し，和を計算しています．ここで，「和」と「積」を別のものに置き換えることを考えます．例えば次のように$\\max$と$+$に変えるとどうなるでしょうか．ここで，$\\max(a_1,a_2,a_3,\\cdots)$は，$a_1,a_2,a_3,\\cdots$のうちの最大値を表します．\n$$ A = \\begin{align} \\begin{pmatrix} a_{11} \u0026amp; a_{12} \\\\ a_{21} \u0026amp; a_{22} \\end{pmatrix} \\begin{pmatrix} b_{11} \u0026amp; b_{12} \\\\ b_{21} \u0026amp; b_{22} \\end{pmatrix} = \\begin{pmatrix} \\max(a_{11}+b_{11},a_{12}+b_{21}) \u0026amp; \\max(a_{11}+b_{12},a_{12}+b_{22}) \\\\ \\max(a_{21}+b_{11},a_{22}+b_{21}) \u0026amp; \\max(a_{21}+b_{12},a_{22}+b_{22}) \\end{pmatrix} \\end{align} $$\nこの$\\max,+$で計算される行列ですが，実はこの行列においても高速な行列累乗の計算が可能です．こんな変な演算の世界で行列累乗をしてどうするんだと思いますが，例は後述します．もちろん，演算子を好き勝手変えていいわけではありません．いくつか条件があります．次に示す条件を満たす，集合と加法$+$と乗法 $\\cdot$ の$2$つの二項演算，である必要があります．この性質を満たす集合と$+$と$\\cdot$の組を半環と言います．また，集合の要素を元と言います．\n加法において，結合法則が成り立ち，可換であり，単位元$0$を持つ． $(a + b) + c = a + (b + c)$ $a+b = b+a$ $0 + a = a + 0 = 0$ 乗法において，結合法則が成り立ち，単位元$1$を持つ． $(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$ $1 \\cdot a = a \\cdot 1 = a$ 分配法則が成り立つ． $a \\cdot (b+c) = (a\\cdot b) + (a\\cdot c)$ $(a+b)\\cdot c = (a\\cdot c) + (b\\cdot c)$ 乗法で，$0$(加法の単位元)と任意の元の積は$0$になる． $0\\cdot a = a\\cdot 0 = 0$ 例えば，有理数の集合を$\\mathbb{R}$とすると，$(\\mathbb{R},+,\\cdot)$は半環をなす，という言い方をします．\nでは，先程の$\\max$と$+$の例は本当に半環をなしているかを確認してみましょう．この場合の集合も$\\mathbb{R}$(有理数全体)としておきます．先述した半環の定義だと，加法が$\\max$で，乗法が$+$に対応しています． まずは加法$\\max$について見ていきます．\n$\\max(\\max(a,b),c) = \\max(a,\\max(b,c))$ $\\max(a,b) = \\max(b,a)$ $\\max(\\infty,a) = \\max(a,\\infty) = \\infty$ $\\max$は単位元を$\\infty$にすることで成立します．次に乗法$+$です．\n$(a + b) + c = a + ( b+c)$ $0 + a = a + 0 = a$ $+$の単位元は$0$です． 次に分配法則の確認です．ややこしいですが，次の式が成り立つことがわかります．\n$a+\\max(b,c) = \\max(a+b,a+c)$ $\\max(a,b)+c = \\max(a+c,b+c)$ 最後に加法$\\max$の単位元$\\infty$を乗算$+$すると$\\infty$になることを確認します．\n$\\infty +a = a + \\infty = \\infty$ 以上，厳密性には欠けますが$(\\mathbb{R},\\max,+)$が半環をなしていることがわかりました．さて，次の節からは，いつもと違う半環の世界での行列累乗の例を見ていきます．\nANDとXOR ABC009 D - 漸化式\n定数$C_1,C_2,C_3,\\cdots,C_K$があり，$K$項間の漸化式が次のように定まる $A_i \\quad (1\\leq i\\leq K)$は与えられる．\n$$ A_{K+1} = (C_1 \\mathrm{AND} A_{K}) \\mathrm{XOR} (C_2 \\mathrm{AND} A_{K-1}) \\mathrm{XOR} \\cdots \\mathrm{XOR} (C_K \\mathrm{AND} A_{1}) $$\nこのとき，$A_N$を求めよ($1\\leq M\\leq 10^{9}$)． なお，$\\mathrm{AND}$はビットごとの論理積，$\\mathrm{XOR}$はビットごとの排他的論理和を表す．\nこの問題は$(\\mathbb{N},\\mathrm{AND},\\mathrm{XOR})$が半環をなすことを利用して，ただの線形漸化式と見ることができます．なお，$\\mathrm{AND}$と$\\mathrm{XOR}$はビットごとで独立した演算であるため，各bitで$\\mod 2$の掛け算とたし算をしていると見ることでも解くことができます．\nワーシャルフロイド法 ワーシャルフロイド法は，$(\\mathbb{R},\\min,+)$の世界での行列累乗だと捉えることができます．\nMojaCoderで類題を見つけました． Dungeon Attack (Hard)\n関連問題 行列累乗がストレートに出ることは珍しく，考察の末に最後の一捻りとして出てくることが多い印象があります．全体的に難しいです．\nフィボナッチ数列の第N項をMで割った余りを求める ABC204 F - Hanjo 2 ABC199 F - Graph Smoothing ABC256 G - Blakc and Whte Stones ABC129 F - Takahashi\u0026rsquo;s Basics in Education and Learning ABC271 G - Access Counter ABC212 H - Nim Counting ARC025 D - コンセント DISCO2020 B - Hawker on Graph APG4b 計算量 https://atcoder.jp/contests/APG4b/tasks/APG4b_w\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n実はこの計算量解析はあまり意味のあるものではありません．なぜなら，フィボナッチ数列は後の項に行けば行くほど桁数が増えるからです．後の項に行くほど，かけ算やたし算の計算コストは上がっていきます．ですので，$O(\\log N)$といっても$N=10^7$の時点で結構時間がかかってしまいます．競プロでは$10^9+7$では割ったあまりを求めなさい，のように桁数を気にせずに計算できる場合が多いため，今回は考えないことにしています(競プロに限った話ではなく，大きな数を求めるときに異なる素数で割ったあまりを求めておいて，中国剰余原理で復元する，等の手法が使われる)．\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-12-06T02:00:00Z","permalink":"https://shibaken28.github.io/my-blog-4/contents/matrix-pow/","title":"行列累乗まとめ"},{"content":"問題 ランダムにフラグのビット数と同じ長さのpubがランダム生成され，フラグのi番目のビットが1だったところに対応するpub[i]が足し算されてcとなる．cとpubが与えられる．要するにナップザック問題．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from Crypto.Util.number import bytes_to_long, getPrime from Crypto.Random.random import getrandbits flag = b\u0026#34;ictf{xxxxxxxxxxxxxxxxxxxxxxx}\u0026#34; flag = bytes_to_long(flag) p = getPrime(512) k = [getrandbits(n*2+3) for n in range(flag.bit_length())] assert all(n \u0026lt; p for n in k) e = getrandbits(1024) pub = [(m * e) % p for m in k] print(pub) c = [] for n in range(flag.bit_length()): c.append((flag % 2) * pub[n]) flag //= 2 print(f\u0026#34;{pub}\u0026#34;) print(f\u0026#34;{sum(c)}\u0026#34;) 解法 ナップザック問題を解くにはLLLを使う．\n格子の作り方は次の通り．\n$$ \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; p_1\\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; p_2 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; p_3 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; p_{n-2} \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; p_{n-1}\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; p_{n}\\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -c\\\\ \\end{pmatrix} $$\n例えば，$p=(102,103,104)$からいくつか選んで$c=206$を作る組み合わせを知りたい場合，\n$$ \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 102 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 103 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 104 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; -206 \\\\ \\end{pmatrix} $$\nをLLLにかける．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 sage: X = Matrix(ZZ,4,4) sage: X[0,0]=1 sage: X[1,1]=1 sage: X[2,2]=1 sage: X[0,3]=102 sage: X[1,3]=103 sage: X[1,3]=104 sage: X[3,3]=-206 sage: X [ 1 0 0 102] [ 0 1 0 103] [ 0 0 1 104] [ 0 0 0 -206] sage: X.LLL() [ 1 0 1 0] [ -1 1 0 1] [ 0 -1 1 1] [ 35 0 -34 34] LLLは各行をそれぞれベクトルと見たとき，それらのベクトルの適当な整数倍したものがゼロベクトルに近いように計算してくれる． LLLにかける前の行列で，一番右の列以外の$1,0$は，どのベクトルがいくつ足し算されたかを表すために用意されている． この場合，結果の$1$行目がもとの行列の$1,3,4$行目のベクトルを足し算したものになっている．すなわち，$102+104-206=0$であることがわかる．\ncが計算されるときにflagの下位ビットから処理されていることに注意して実装する．なお，出力されたベクトルの最終列は無視するべきだが，$0$であるはずなので反転したときに結局関係なくなる(桁の先頭に$0$が入るだけ)ので問題ない．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from Crypto.Util.number import * n = len(pub) X = Matrix(ZZ, n+1, n+1) for i,p in enumerate(pub): X[i,i] = 1 X[i,n] = p X[n,n] = -c out = Matrix(X).LLL() for row in out: if all(n in [0, 1] for n in row): print(row) flag = int(\u0026#34;\u0026#34;.join(str(n) for n in list(row[::-1])), 2) print(long_to_bytes(flag)) #b\u0026#39;ictf{sUpeRinCrEasIng_wH4T???}\u0026#39; コメント LLLの結果の反転を忘れて困惑した．\n","date":"0001-01-01T00:00:00Z","permalink":"https://shibaken28.github.io/my-blog-4/contents/luggage/","title":"LLLを用いてナップザック暗号を解く"},{"content":"LSB Decryption Oracle Attack RSA暗号において，何度も暗号文を復元してくれて，その最も下のビットがわかっている場合，LSB Decryption Oracle Attackが使える． ここでは，入力$x$に対して，$x^d\\mod n$が出力されるものとする． (RSAの各パラメータの説明については省略する．)\n理論 $$(2m)^e = 2^em^e = 2^ec\\mod n$$ が成り立つため，$2^ec\\mod n$を入力として与えると，$(2m)^e\\mod n$を復元することになるため，$2m \\mod n$が返ってくる． この値の偶奇で$m$の範囲がわかる．\nもし，$0\\leq2m\u0026lt;n$の場合，$2m\\mod n$と$2m$は等しいため，$2m \\mod n$は必ず偶数になる． もし，$n\\leq2m\u0026lt;2n$の場合，$2m\\mod n$は$2m-n$と等しいため，$n$が奇数であることから$2m\\mod n$は必ず奇数になる． $0\u0026lt;m\u0026lt;n$であるから，$2m$がこれ以外の値の範囲をとることはない． これにより，$2m\\mod n$が偶数なら$0\\leq m\u0026lt;\\frac{1}{2}n$，奇数なら$\\frac{1}{2}n\\leq m\u0026lt;n$であることがわかる．\n次に，$4^ec\\mod n$を入力に与えることについて考える．同様に，$4^ec = (4m)^c\\mod n$が成り立つから，$4m\\mod n$の値が返ってくる． 例えば，$2m\\mod n$の出力が偶数で，$0\\leq m\u0026lt;\\frac{1}{2}n$であることが，わかっていたとする．このとき，$4m\\mod n$の偶奇は次のように決まっている．\n$0\\leq4m\u0026lt;n$の場合，$4m\\mod n$は$4m$と等しいため，$4m\\mod n$は必ず偶数になる． $n\\leq4m\u0026lt;2n$の場合，$4m\\mod n$は$4m-n$と等しいため，$4m\\mod n$は必ず奇数になる． よって，$2m\\mod n$が偶数で， かつ$4m\\mod n$が偶数のときは，$0\\leq m\u0026lt;\\frac{1}{4}n$，奇数のときは$\\frac{1}{4}n\\leq m\u0026lt;\\frac{1}{2}n$であることがわかる．\n同様に，$2m\\mod n$の出力が奇数で，$\\frac{1}{2}n\\leq m\u0026lt;n$であることが，わかっていたとする．このとき，$4m\\mod n$の偶奇は次のように決まっている．\n$2n\\leq4m\u0026lt;3n$の場合，$4m\\mod n$は$4m-2n$と等しいため，$4m\\mod n$は必ず偶数になる． $3n\\leq4m\u0026lt;4n$の場合，$4m\\mod n$は$4m-3n$と等しいため，$4m\\mod n$は必ず奇数になる． よって，$2m\\mod n$が奇数で， かつ$4m\\mod n$が偶数のときは，$\\frac{1}{2}n\\leq m\u0026lt;\\frac{3}{4}n$，奇数のときは$\\frac{3}{4}n\\leq m\u0026lt;n$であることがわかる．\nこれを繰り返していくと，二分探索の要領でどんどん$m$の取りうる値が半分になっていき，最終的に$m$の値が求まる．\n実装例 整数でl,rを動かすと誤差が出てしまうため，有理数を使っている．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from Crypto.Util.number import * from fractions import Fraction from math import ceil p = getPrime(256) q = getPrime(256) n = p*q m = bytes_to_long(b\u0026#34;flag{this_is_flag}\u0026#34;) e = 0x10001 c = pow(m,e,n) d = pow(e,-1,(p-1)*(q-1)) assert m\u0026lt;n assert pow(c,d,n)==m def dec(x): return pow(x,d,n) l = 0 r = n a = 1 while abs(r-l)\u0026gt;1: b=(c*pow(2,a*e,n))%n de = dec(b) mid = Fraction(l + r, 2) if de%2==0: r = mid else: l = mid a+=1 print(ceil(l)) print(m) 参考サイト plain RSAに対するLSB decryption oracle attackをやってみる LSB Leak Attackを実装した を参考にさせて頂きました．\n","date":"0001-01-01T00:00:00Z","permalink":"https://shibaken28.github.io/my-blog-4/contents/lsb-attack/","title":"LSB Decryption Oracle Attackの実装"},{"content":"これはなに picoCTF2022にチームSUSHi-ST0RMで参加しました．crypto問題(300点以上)のwriteupです．\nwriteup Very Smooth(300pt) 概要 RSA暗号で，$e,n,c$が与えられる．\ngen.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #!/usr/bin/python from binascii import hexlify from gmpy2 import * import math import os import sys if sys.version_info \u0026lt; (3, 9): math.gcd = gcd math.lcm = lcm _DEBUG = False FLAG = open(\u0026#39;flag.txt\u0026#39;).read().strip() FLAG = mpz(hexlify(FLAG.encode()), 16) SEED = mpz(hexlify(os.urandom(32)).decode(), 16) STATE = random_state(SEED) def get_prime(state, bits): return next_prime(mpz_urandomb(state, bits) | (1 \u0026lt;\u0026lt; (bits - 1))) def get_smooth_prime(state, bits, smoothness=16): p = mpz(2) p_factors = [p] while p.bit_length() \u0026lt; bits - 2 * smoothness: factor = get_prime(state, smoothness) p_factors.append(factor) p *= factor bitcnt = (bits - p.bit_length()) // 2 while True: prime1 = get_prime(state, bitcnt) prime2 = get_prime(state, bitcnt) tmpp = p * prime1 * prime2 if tmpp.bit_length() \u0026lt; bits: bitcnt += 1 continue if tmpp.bit_length() \u0026gt; bits: bitcnt -= 1 continue if is_prime(tmpp + 1): p_factors.append(prime1) p_factors.append(prime2) p = tmpp + 1 break p_factors.sort() return (p, p_factors) e = 0x10001 while True: p, p_factors = get_smooth_prime(STATE, 1024, 16) if len(p_factors) != len(set(p_factors)): continue ## Smoothness should be different or some might encounter issues. q, q_factors = get_smooth_prime(STATE, 1024, 17) if len(q_factors) != len(set(q_factors)): continue factors = p_factors + q_factors if e not in factors: break if _DEBUG: import sys sys.stderr.write(f\u0026#39;p = {p.digits(16)}\\n\\n\u0026#39;) sys.stderr.write(f\u0026#39;p_factors = [\\n\u0026#39;) for factor in p_factors: sys.stderr.write(f\u0026#39; {factor.digits(16)},\\n\u0026#39;) sys.stderr.write(f\u0026#39;]\\n\\n\u0026#39;) sys.stderr.write(f\u0026#39;q = {q.digits(16)}\\n\\n\u0026#39;) sys.stderr.write(f\u0026#39;q_factors = [\\n\u0026#39;) for factor in q_factors: sys.stderr.write(f\u0026#39; {factor.digits(16)},\\n\u0026#39;) sys.stderr.write(f\u0026#39;]\\n\\n\u0026#39;) n = p * q m = math.lcm(p - 1, q - 1) d = pow(e, -1, m) c = pow(FLAG, e, n) print(f\u0026#39;n = {n.digits(16)}\u0026#39;) print(f\u0026#39;c = {c.digits(16)}\u0026#39;) output.txt\n1 2 3 e = 0x10001 n = 809fbd8b667d664f01fe1b0387e0b424efe2035e2dec4d249ace30563d0e1a50050020880c2f01bad63b22e21125d780d887cffdb1165268e6be788cd49ad8a9a1d27482f1a8ccbb37adc0deee65d09f312ebaab854782e2411d917181fef63d478b7e25391ac10d0330cafcb5c8d859ee1e403be029ce5dd75f864deabe5a65645b099afb7af4ed84dd75d1e4b966e2a0662ece5409feeacb2a277ddf05b72153ff6f36524f7693cc432269b56bd8ab3d601844aef6a6130eaaec08f92f9816ed0e7781a23a043570364807bef579c1e9175e3fe2b1d8f52356230feea244ce1b88b2342c9e40b25583a1fe558bdfb3a7115a4c71a6f06b706419ce8e21a3e1 c = 74ce97c4712bc3827a9f6021089c093a7540a6280330a9ec7c6f446a88093c33a6b9a0a1fdf2cad96e32344970adbf26601d9baf2c4e9892dde435dc994bde4754fddbac47a475b3907a455c6f671484b473b5481080224406b1d48d48da5ba0d9fccdc5732cb64c0f02c32ddc1413f66bd95b8e5a929e5b1f14843bd8f5d4747a4aabcc64217a187db6913facce48f2019b5524633153ee40a4376960b7f669f331da29227fa9a8c09a58a6f3db7453dd89a6093c062ff95502cc7cca5ee497c8ec6265413f5d05d1b720b4eb620875b6f6d2a7958e2391835497a106f4c280cd1ca8b9605bbef5952b54dffc028c160c1495e5cd2957f6f2bbb2e868823b6a 解法 $p$と$q$の作り方が鍵になってきそうです． gen.pyには親切にもDEGUB機能がついているため，これを使って$p$と$q$の生成過程を観察します．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 p_factors = [ 2, 9277, 16057, 33223, 33961, (中略) 61837, 61961, 62743, 63577, 65407, ] q_factors = [ 2, 33161, 48751, 67391, 67399, (中略) 126227, 127163, 127607, 128047, ] プログラムも合わせて見ると，$p$と$q$は小さな素数の積に$1$を足して作られていることがわかります(もし$1$を足しても素数にならなければ作り直している)．また，$p$と$q$で使われている素数の範囲も異なっています．この状況に対して，$p-1$法という素因数分解の手法が使えます．\n$p-1$法は，互いに素な$a,p$で，フェルマーの小定理$a^{p-1} = 1 \\pmod p$が成り立つことを使います．\n$p-1$の倍数である適当な数$ M $を持ってきて， $ a^{M} $を計算すれば，$ a^{M} = 1 \\pmod p $ が成り立ち，$ a^{M}-1 $ が $ p $ の倍数となります．\nつまり，$ a^{M}-1 $と$ n $の最大公約数が$ p $となります．\n今回は，$p-1$が$10^{5}$未満の素数の積であることから，$ M $を$10^{5}$以下の素数の積1として，$a$は$2$を選びます．\nこの問題を解くにあたって下記の記事を参考にさせていただきました．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from Crypto.Util.number import * n = #省略 c = # e = 0x10001 a = 2 b = 1 for i in range(2,100000): if isPrime(i): b*=i ab =pow(a,b,n) p = GCD(ab-1,n) q=n//p phi=(p-1)*(q-1) d=pow(e,-1,phi) m=pow(c,d,n) print(long_to_bytes(m)) Sum-O-Primes(400pt) 概要 RSA暗号で，$e,n,c$加えて$x=p+q$が与えられる．\n1 2 3 4 e = 65537 x = 1603fc8d929cb31edf62bcce2d06794f3efd095accb163e6f2b78941bd8c646d746369636a582aaac77c16a9486881a9e3db26d742e48c4adcc417ef98f310a0c5433ab077dd872530c3c3c77fe0c080d84154bfdb4c920df9617e986999104d9284516c7babc80dc53718d59032aefdf41b9be53957dea3f00a386b2666d446e n = 75302ba292dc4bf47ffd690b8edc70ef1fcca5e148b2b9c1b60227788afcfe77a0097929ed3789fe51ac66f678c558244890a09ae4af3e7d098fd366a1c859edabbff1c9e164d5354968798107ae8518fcaab3743de58a141ffd26c1e16cb09fed1f6b0d68536ec7fba744ed120fea8c3a7ac1ebfa55d664d2f321fb44e814650147a9031f3bfa8f69d87393c7d88976d28d147398a355020bcb8e5613f0b29028b77db710e163ca1019fd3c3a065465ea457adec45243c385d12d3a1de3178f6ca05964be92e8b5bc24d420956de96ccc9ce39e70705660eb6b2f4e675aac7d6d7ba45c84223fc5819b37aa85beff1382f1c2c3b97603150f30c17f7e674441 c = 562888c70ce9a5c5ed9a0be1b6196f854ba2efcdb6dd0f79319ee9e1142659f90a6bae67481eb0f635f445d3c9889da84639beb84ff7159dcf4d3a389873dc90163270d80dbb9503cbc32992cb592069ba5b3eb2bbe410a3121d658f18e100f7bd878a25c27ab8c6c15b690fce1ca43288163c544bfce344bcd089a5f4733acc7dc4b6160718e3c627e81a58f650281413bb5bf7bad5c15b00c5a2ef7dbe7a44cce85ed5b1becd5273a26453cb84d327aa04ad8783f46d22d61b96c501515913ca88937475603437067ce9dc10d68efc3da282cd64acaf8f1368c1c09800cb51f70f784bd0f94e067af541ae8d20ab7bfc5569e1213ccdf69d8a81c4746e90 解法 連立方程式と見て，$p$と$q$を求めることもできますが，直接$ \\phi = (p-1)(q-1)$を求めるほうが早いです． $$ \\phi = (p-1)(q-1) = pq - p - q + 1 = n - x + 1$$\n1 2 3 4 5 6 from Crypto.Util.number import * phi = n-x+1 d=pow(e,-1,phi) m=pow(c,d,n) print(long_to_bytes(m)) Sequences(400pt) 概要 下の関数で，m_func(20000000)の値の下10000桁を求める問題．\n1 2 3 4 5 6 7 def m_func(i): if i == 0: return 1 if i == 1: return 2 if i == 2: return 3 if i == 3: return 4 return 55692*m_func(i-4) - 9549*m_func(i-3) + 301*m_func(i-2) + 21*m_func(i-1) つまり，\n$$ a_0 = 1, a_1 = 2, a_2 = 3, a_3 = 4 $$\n$$ a_i = 21a_{i-1} + 301a_{i-2} - 9549_{i-3} + 55692 a_{i-4} \\quad (i\u0026gt;4) $$\nのとき，$a_{20000000}$を$10^{10000}$で割った余りを求める．\n解法 線形漸化式であるため，行列を使うテクニックを使って第n項を$O(\\log n)$で計算することができます．\n任意の項は次の行列を使った式によって表されます． この行列を累乗をナイーブに計算すると結局$O(n)$かかってしまいますが， 繰り返し2乗法(ダブリングと呼ぶこともある)，という手法を使うことで$O(\\log n)$で計算することが可能です．\nこの問題を解くにあたって下記の記事を参考にさせていただきました．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import math import hashlib import sys from tqdm import tqdm import functools ITERS = int(2e7) VERIF_KEY = \u0026#34;96cc5f3b460732b442814fd33cf8537c\u0026#34; ENCRYPTED_FLAG = bytes.fromhex(\u0026#34;42cbbce1487b443de1acf4834baed794f4bbd0dfe08b5f3b248ef7c32b\u0026#34;) def mat_mul(a, b) : I, J, K = len(a), len(b[0]), len(b) c = [[0] * J for _ in range(I)] for i in range(I) : for j in range(J) : for k in range(K) : c[i][j] += a[i][k] * b[k][j] c[i][j] %= 10**10000 return c def mat_pow(x, n): y = [[0] * len(x) for _ in range(len(x))] for i in range(len(x)): y[i][i] = 1 while n \u0026gt; 0: if n \u0026amp; 1: y = mat_mul(x, y) x = mat_mul(x, x) n \u0026gt;\u0026gt;= 1 return y d0 = 0 ret = [[4], [3], [2],[1]] mat = [[21,301,-9549,55692], [1, 0, 0, 0], [0, 1, 0, 0],[0,0,1,0]] #ret = mat_mul(mat_pow(mat, ITERS), ret) #ret = [[1],[1]] #mat = [[1,1], [1,0]] ret = mat_mul(mat_pow(mat, ITRES), ret) print(ret) ## Decrypt the flag def decrypt_flag(sol): sol = sol % (10**10000) sol = str(sol) sol_md5 = hashlib.md5(sol.encode()).hexdigest() if sol_md5 != VERIF_KEY: print(\u0026#34;Incorrect solution\u0026#34;) sys.exit(1) key = hashlib.sha256(sol.encode()).digest() flag = bytearray([char ^ key[i] for i, char in enumerate(ENCRYPTED_FLAG)]).decode() print(flag) if __name__ == \u0026#34;__main__\u0026#34;: sol = A decrypt_flag(sol) NSA-backdoor(500pt) 概要 離散対数問題\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #!/usr/bin/python from binascii import hexlify from gmpy2 import * import math import os import sys if sys.version_info \u0026lt; (3, 9): math.gcd = gcd math.lcm = lcm _DEBUG = False FLAG = open(\u0026#39;flag.txt\u0026#39;).read().strip() FLAG = mpz(hexlify(FLAG.encode()), 16) SEED = mpz(hexlify(os.urandom(32)).decode(), 16) STATE = random_state(SEED) def get_prime(state, bits): return next_prime(mpz_urandomb(state, bits) | (1 \u0026lt;\u0026lt; (bits - 1))) def get_smooth_prime(state, bits, smoothness=16): p = mpz(2) p_factors = [p] while p.bit_length() \u0026lt; bits - 2 * smoothness: factor = get_prime(state, smoothness) p_factors.append(factor) p *= factor bitcnt = (bits - p.bit_length()) // 2 while True: prime1 = get_prime(state, bitcnt) prime2 = get_prime(state, bitcnt) tmpp = p * prime1 * prime2 if tmpp.bit_length() \u0026lt; bits: bitcnt += 1 continue if tmpp.bit_length() \u0026gt; bits: bitcnt -= 1 continue if is_prime(tmpp + 1): p_factors.append(prime1) p_factors.append(prime2) p = tmpp + 1 break p_factors.sort() return (p, p_factors) while True: p, p_factors = get_smooth_prime(STATE, 1024, 16) if len(p_factors) != len(set(p_factors)): continue ## Smoothness should be different or some might encounter issues. q, q_factors = get_smooth_prime(STATE, 1024, 17) if len(q_factors) == len(set(q_factors)): factors = p_factors + q_factors break if _DEBUG: import sys sys.stderr.write(f\u0026#39;p = {p.digits(16)}\\n\\n\u0026#39;) sys.stderr.write(f\u0026#39;p_factors = [\\n\u0026#39;) for factor in p_factors: sys.stderr.write(f\u0026#39; {factor.digits(16)},\\n\u0026#39;) sys.stderr.write(f\u0026#39;]\\n\\n\u0026#39;) sys.stderr.write(f\u0026#39;q = {q.digits(16)}\\n\\n\u0026#39;) sys.stderr.write(f\u0026#39;q_factors = [\\n\u0026#39;) for factor in q_factors: sys.stderr.write(f\u0026#39; {factor.digits(16)},\\n\u0026#39;) sys.stderr.write(f\u0026#39;]\\n\\n\u0026#39;) n = p * q c = pow(3, FLAG, n) print(f\u0026#39;n = {n.digits(16)}\u0026#39;) print(f\u0026#39;c = {c.digits(16)}\u0026#39;) 解法 と はどちらも小さな素数の積であるため， も小さな素数の積に分解できます． つまり，Pohlig–Hellman algorithm が使えます． Pohlig–Hellman algorithm は，現実的な時間で解くことのできる小さな離散対数問題に分割し，中国剰余定理で結果をもとの問題の答えとして復元する，という手法です．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 from Crypto.Util.number import * n = 0x71c27455f38b75f08868b5965d7afba3d81bff38f3b63271ad9250b9d7dc8c909d3555593c2eff9c27a3c259f8e95da41d55544a362494476141c8ccb93fc7d9019d965a20e16d55daf57b5663ede8d5ad97b7be239ecacb2636621ef997854f18f6da1394101dfb8229a2253dbc3ffc995cc6197bd85455f6178c14dbb9a611b3b42530fcdc5c36c5f63fd3796efdfc440a76cf966ff8c56e7e55872a57aa3a335c2b10a82421bcd1cd0d238496f2830d6524f6ba8e9890e30c4e6ad11df8948f4b428d8089a5d9455baca34cee61cb238042bcf8293aab13595aeb90fedabf23b1d0e82c6882824aa0f78c2208de641d9592a170ed839728f6c7e6b6bdf831 y = 0x2560971fdf742d398ae3e677082ab950e99edde5577abcc4d704d65577ec287169d209f2033c82e7574f7e6c27540bb07416cd12b5fca1bb5c7ae23e80bb00b81a5c49116fa3cca6ab72f4a56b2bf0d51c58eedb918faa1e88d6fddb7dd358c1cdaa6e61964284014919662f75adaad5065a3633067b2297cd4657d39c8e2cdb02fd80ba33447abb8bfcd4dd68166f487094108afe5b4378f5f6eb9209f503b718dec9c841089551db648f5b5a84357b2319eb1b27935c3bc47c645f732d36cfffcb0e7f1c8ec5859413e6d62f7ed9af27f4712ca91bbdb9526ea19414c82090a52a78e6bbc2a756b5756017ee08326cd7b1d5dd9fff6afb12bcb93fb541a542 print(f\u0026#39;n = {n}\u0026#39;) print(f\u0026#39;c = {y}\u0026#39;) ## get p and q with using p-1 method p=133120514134071565184901374403906104857402594315193452979400334844456988039351029748429497538981454221984106135005043996378098395846705709422658663585864970394230279241392567216599860405945469882804839379543093459226432299183847151658790842646530907008354991523758458009950957111989465047584759069188272154703 q=107878320716069936845347261730222923402619282584236808136469656719645067255143372538361375857163594280233925663413568686520703251291382637679919197208920902793419007945364505474185442005931731898039583502138819092649272834779913753377381462765827012568092442233669634217190652686190269458879367972776287369087 assert p*q==n ## factors of phi = (p-1)(q-1) phi=[2, 2, 10369, 11437, 11969, 12491, 33343, 34369, 34687, 34939, 35969, 36467, 36709, 36919, 36973, 36997, 37361, 37379, 37561, 38867, 40897, 41203, 41593, 41801, 42221, 43189, 43481, 43951, 44029, 44953, 45161, 45751, 46649, 46703, 47017, 47221, 49409, 49499, 49783, 50321, 50539, 52081, 53077, 53299, 54367, 54601, 54829, 55147, 55399, 55457, 55661, 56039, 56237, 56267, 56299, 57089, 57373, 57637, 57731, 58897, 59753, 60223, 60733, 61673, 61781, 62459, 62969, 63781, 63901, 64399, 65551, 67651, 68207, 68947, 72287, 74653, 74857, 75011, 77081, 77153, 77239, 78467, 78691, 78877, 81343, 83701, 85009, 88037, 88117, 88397, 89269, 89363, 89477, 90403, 90901, 91009, 94057, 95701, 98387, 100853, 104161, 105097, 106657, 107021, 109121, 109807, 110681, 111599, 112901, 113797, 114883, 115163, 115727, 116009, 117037, 117413, 118799, 120413, 123229, 123973, 124067, 124427, 125863, 125887, 126631, 127481, 128311, 129671, 129793, 130589] m=1 for i in phi: m*=i assert m==(p-1)*(q-1) g=3 def extgcd(a, b): if b: d, y, x = extgcd(b, a % b) y -= (a // b) * x return d, x, y return a, 1, 0 ## V = [(X_i, Y_i), ...]: X_i (mod Y_i) def remainder(V,W): x = 0; d = 1 for i in range(len(V)): X=V[i] Y=W[i] g, a, b = extgcd(d, Y) x, d = (Y*b*x + d*a*X) // g, d*(Y // g) x %= d return x, d ## Baby-step giant-step def baby_step_giant_step(g, y, p, q): m = int(q**0.5 + 1) ## Baby-step baby = {} b = 1 for j in range(m): baby[b] = j b = (b * g) % p ## Giant-step gm = pow(inverse(g, p), m, p) giant = y for i in range(m): if giant in baby: x = i*m + baby[giant] print(\u0026#34;Found:\u0026#34;, x) return x else: giant = (giant * gm) % p print (\u0026#34;not found\u0026#34;) return -1 ## Pohlig-Hellman algorithm def pohlig_hellman(p1,p2, g, y, Q): print (\u0026#34;[+] Q:\u0026#34;, Q) X = [] for q in Q: x = baby_step_giant_step(pow(g,((p1-1)*(p2-1))//q,p1*p2), pow(y,((p1-1)*(p2-1))//q,p1*p2), p1*p2, q) X.append(x) print (\u0026#34;[+] X:\u0026#34;, X) x ,d= remainder(X,Q) return x,d x,d = pohlig_hellman(p,q, g, y, phi) print(long_to_bytes(x)) print(long_to_bytes(d)) 感想 400点のSum-O-Primesよりも300点のVery-Smoothの方が難しいと感じました．あと，全完できたので嬉しいです．\n$ M $の値は小さな素数の積であれば何でもいいわけではなく，もし$ M $を$1.5\\times 10^{5}$程度までの素数の積にしてしまうと，$ M $が$(p-1)(q-1)$の倍数になってしまい，$ a^{(p-1)(q-1)} =a^{M} = 1 \\pmod n$が成り立つため，$n$と$a^{M}-1$の最大公約数が$n$になってしまいます．また，この問題は素数生成の際に同じ素数が2度以上使われていないことがわかっているので，ソルバでは各素数を1度しか掛け算していませんが，わかっていない場合は$p-1$が$2^{4}$や$3^{2}$のような約数を持っている可能性があるので，同じ素数も何度か掛けておくべきです．\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"0001-01-01T00:00:00Z","permalink":"https://shibaken28.github.io/my-blog-4/contents/picoctf/","title":"picoCTF2022 crypto writeup"},{"content":"問題 線形合同法によって乱数列が生成される． 生成に使われるパラメータの$a,b,m$の和を求める問題． ただし，線形合同法とは，次の漸化式と$x_0$によって計算される値である．\n$$ x_{i+1} = ax_i + b \\pmod m $$\nただし，rand関数にはちょっと小細工が仕込まれていて，$x_i$の次に$x_{i+1}$が生成されるとは限らずに，ランダムに$1$個から$256$個の値がスキップされることがある．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from Crypto.Util.number import getPrime from secrets import randbelow from hashlib import sha256 m = getPrime(20) a = randbelow(m) b = randbelow(m) x = randbelow(m) def rand(): def rand(): global a, b, m, x x = (a*x + b) % m return x while 1: for _ in range(rand() \u0026amp; 0xFF): rand() for _ in range(rand() \u0026amp; 0x8): yield rand() def xor(x, y): return bytes(a ^ b for a, b in zip(x, y)) rand = rand() rand = [next(rand) for _ in range(20)] print(\u0026#39;rand =\u0026#39;, rand) print(\u0026#39;ct =\u0026#39;, xor(b\u0026#39;ictf{REDACTED}\u0026#39;, sha256((m + a + b).to_bytes(6, \u0026#39;big\u0026#39;)).digest())) 解説 線形合同法は，連続した乱数列から各パラメータを求めることができる． 次のような連続した乱数列が与えられたとする． $$ \\begin{align} x_1 \u0026amp;= ax_0 + b \\pmod m \\\\ x_2 \u0026amp;= ax_1 + b \\pmod m \\\\ x_3 \u0026amp;= ax_2 + b \\pmod m \\\\ x_4 \u0026amp;= ax_3 + b \\pmod m \\\\ x_5 \u0026amp;= ax_4 + b \\pmod m \\\\ x_6 \u0026amp;= ax_5 + b \\pmod m \\end{align} $$ $b$のみがわからない場合は，次のようにして求めることができる． $$ \\begin{align} x_1 \u0026amp;= ax_0 + b \\pmod m \\\\ b \u0026amp;= x_1 - ax_0 \\pmod m \\end{align} $$ $a,b$がわからない場合は，次のように逆数を用いてまず$a$を求めることができる． $$ \\begin{align} x_2 - x_1 \u0026amp;= ax_1 - ax_0 \\pmod m \\\\ x_2 - x_1 \u0026amp;= a(x_1 - x_0) \\pmod m \\\\ a \u0026amp;= (x_2 - x_1)(x_1 - x_0)^{-1} \\pmod m \\end{align} $$\n$a,b,m$全てわからない場合，次のような$T_0,T_1,T_2,\\cdots$を用意する．\n$$ \\begin{align} T_0 \u0026amp;= x_1 - x_0 \\\\ T_1 \u0026amp;= x_2 - x_1 = A(x_1-x_0) = A T_0 \\pmod m \\\\ T_2 \u0026amp;= x_3 - x_2 = A(x_2-x_1) = A T_1 \\pmod m \\\\ T_0T_2 - T_1^2 \u0026amp;= A^2T_0^2 - A^2T_0^2 = 0 \\pmod m \\\\ \\end{align} $$\nここで，$T_0T_2 - T_1^2 = 0 \\pmod m$であることから，添字をずらすと次が成り立つ．\n$$ \\begin{align} T_1T_3 - T_2^2 \u0026amp;= 0 \\pmod m \\\\ T_2T_4 - T_3^2 \u0026amp;= 0 \\pmod m \\\\ T_3T_5 - T_4^2 \u0026amp;= 0 \\pmod m \\\\ \\vdots \\\\ T_{n-1}T_{n+1} - T_n^2 \u0026amp;= 0 \\pmod m \\end{align} $$ こられの数は全て$m$で割ったあまりが$0$であるため，これらの数の最大公約数を求めることができれば，それが$m$である可能性1がある．\n以上のことにより，次のスクリプトによって$a,b,m$を求めることができる．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from Crypto.Util.number import * from hashlib import sha256 def linear_random_crack(rands): t = [rands[i+1]-rands[i] for i in range(len(rands)-1) ] s = [(t[i+2]*t[i]-t[i+1]*t[i+1]) for i in range(len(t)-2) ] m = 0 for a in s: m = GCD(m,a) a = ((t[2]-t[1]) * inverse(t[1]-t[0],m))%m b = (rands[1] - a*rands[0])%m return a,b,m def xor(x, y): return bytes(a ^ b for a, b in zip(x, y)) ct = b\u0026#39;\\x1b\\xc3\\xc1O\\x7f]q\\xb98\\x8d\\xb8\\xf5\\xec\\x82\\x8cg\\xd0\\xed\\xbb\\t\u0026lt;G\\xe6\\xde\\xf7\\xb3\\x81\\xe05\u0026#39; r = [830740, 252348, 146586, 407799, 782171, 349709, 751088, 904092, 390201, 909918, 347514, 89924, 7112, 751221, 26415, 299902, 438982, 787802, 1081, 814607] l = 8 # 必要に応じて小さくする for i in range(len(r)-l): a,b,m = linear_random_crack(r[i:i+l]) print(a,b,m) print(xor(ct,sha256((a+b+m).to_bytes(6, \u0026#39;big\u0026#39;)).digest())) 出力は次のようになる．\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 963459 253883 977407 b\u0026#39;ictf{n07_50_r4nd0m_4ft3r_4ll}\u0026#39; 0 0 1 b\u0026#39;\\x03\\xa2\\xe9\\xf0\\xf5\\x10\\x11Rs\\xdc\\xa8\\xdf\\x0e G\\r\\xdbm\\xba\\x10K\\x1f\\xc2^\\xce\\xe9\\xc4\\xa4a\u0026#39; 0 0 1 b\u0026#39;\\x03\\xa2\\xe9\\xf0\\xf5\\x10\\x11Rs\\xdc\\xa8\\xdf\\x0e G\\r\\xdbm\\xba\\x10K\\x1f\\xc2^\\xce\\xe9\\xc4\\xa4a\u0026#39; 0 0 1 b\u0026#39;\\x03\\xa2\\xe9\\xf0\\xf5\\x10\\x11Rs\\xdc\\xa8\\xdf\\x0e G\\r\\xdbm\\xba\\x10K\\x1f\\xc2^\\xce\\xe9\\xc4\\xa4a\u0026#39; 0 0 1 b\u0026#39;\\x03\\xa2\\xe9\\xf0\\xf5\\x10\\x11Rs\\xdc\\xa8\\xdf\\x0e G\\r\\xdbm\\xba\\x10K\\x1f\\xc2^\\xce\\xe9\\xc4\\xa4a\u0026#39; 0 0 1 b\u0026#39;\\x03\\xa2\\xe9\\xf0\\xf5\\x10\\x11Rs\\xdc\\xa8\\xdf\\x0e G\\r\\xdbm\\xba\\x10K\\x1f\\xc2^\\xce\\xe9\\xc4\\xa4a\u0026#39; 0 0 1 b\u0026#39;\\x03\\xa2\\xe9\\xf0\\xf5\\x10\\x11Rs\\xdc\\xa8\\xdf\\x0e G\\r\\xdbm\\xba\\x10K\\x1f\\xc2^\\xce\\xe9\\xc4\\xa4a\u0026#39; 0 0 1 b\u0026#39;\\x03\\xa2\\xe9\\xf0\\xf5\\x10\\x11Rs\\xdc\\xa8\\xdf\\x0e G\\r\\xdbm\\xba\\x10K\\x1f\\xc2^\\xce\\xe9\\xc4\\xa4a\u0026#39; 963459 253883 977407 b\u0026#39;ictf{n07_50_r4nd0m_4ft3r_4ll}\u0026#39; 0 0 1 b\u0026#39;\\x03\\xa2\\xe9\\xf0\\xf5\\x10\\x11Rs\\xdc\\xa8\\xdf\\x0e G\\r\\xdbm\\xba\\x10K\\x1f\\xc2^\\xce\\xe9\\xc4\\xa4a\u0026#39; 0 0 1 b\u0026#39;\\x03\\xa2\\xe9\\xf0\\xf5\\x10\\x11Rs\\xdc\\xa8\\xdf\\x0e G\\r\\xdbm\\xba\\x10K\\x1f\\xc2^\\xce\\xe9\\xc4\\xa4a\u0026#39; 0 0 1 b\u0026#39;\\x03\\xa2\\xe9\\xf0\\xf5\\x10\\x11Rs\\xdc\\xa8\\xdf\\x0e G\\r\\xdbm\\xba\\x10K\\x1f\\xc2^\\xce\\xe9\\xc4\\xa4a\u0026#39; $a=963459,b=253883,m=977407$だとわかり，フラグictf{n07_50_r4nd0m_4ft3r_4ll}が得られる．\nコメント yieldを知らなかった．\nあくまで可能性であり，いずれも同じ数になってしまうことや，最大公約数が$m$の倍数になってしまうことがある．最大公約数を取るときに使う数が多いければ多いほど$m$が求められる確率が高くなる．\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"0001-01-01T00:00:00Z","permalink":"https://shibaken28.github.io/my-blog-4/contents/randomness/","title":"線形合同法のパラメータ推測"},{"content":"これはなに 長野高専から競技部門に「高専の応用呪術IIB」 というチーム名で参加しました．それの参戦記です．\n内容は，アルゴリズムの簡単な説明，当日の様子，感想，お茶の順番です．気になるところだけ読んでください．\n結果や出題された問題は公式サイトから見ることができます．\n結果 予選(2組目)1位\n準決勝(2組目)1位\n決勝4位でした．総合では特別賞を頂きました．ありがとうございます．コードが汚いことこの上ないので選ばれないと思っていた．\n上位3校に圧倒的に差をつけられて完敗でした．3位入賞はかなり技術力を上げないとまず届きそうにないですね\u0026hellip;\u0026hellip;．\nほぼ1人参戦については，そもそもチーム戦なのに人を集めなかったのが(実際は集まらなかったのですが，主張が足りなかったのかも)悪いのです．\nアルゴリズムの説明 本番で使用したプログラムは全て私が作りました．第25回のプログラムを参考にしてあり明らかに独創性がありません．様々な解法のソルバを作ったら良かったのですが技量と時間とやる気が足りませんでした．要精進．\nプログラム自体8月中旬から作りはじめ，9月の中旬頃にはほとんど完成し，あとはパラメータをチューニングするだけの状態でした．\n画像復元 貪欲に，ある断片画像の周りに一番くっつきそうな断片画像を繋げていきます．\n具体的には，\n適当な断片画像一つを「確定」させて配置し，その画像の4辺を集合$S$に追加する $S$の各々について，最も親和度が高い断片画像の辺を「候補」として，親和度の値と一緒に集合$E$に追加する． Eのうち最も親和度が高いものを「確定」した断片画像として配置して，追加した断片画像の辺を「候補として」$S$に追加する．2に戻る． $E$はプライオリティキューで実装しているので追加，検索が高速$\\mathrm{O}(\\log N)$です．\n親和度は辺の各ピクセルのRGB値を並べたベクトル同士のcos類似度で計算しました．cos類似度は，ベクトルの内積の等式に出てくる$\\cos \\theta$の値です(2つのベクトルのなす角)． また，事前に全ての辺同士の親和度を計算しておき，いい感じにソートしておくことで高速化します．\n回転可能という条件が予想以上に厄介で，向きや辺の番号の管理がややこしかったです．結局，向きとか辺を{0,1,2,3}で表して，剰余演算でごにょごにょしました．\nGUI上では，次の断片画像の確定，任意の確定断片画像の削除，上端下端などの設定，強制的に任意の断片画像を候補から削除する，といった操作が可能です． ちなみに，サイズの大きいppmファイルの中身を全てchar型の配列に突っ込んでいるので，読み込みが一番時間かかります．\nスライドパズル 端がつながっているルールをうまく使う方法が，案外思いつかないんですこれが． だんだん小さな正方形の問題にしていく戦法と迷ったのですが，結局端っこから1列ずつ揃える→3×nのサイズになったら3×(n-1)にしていく戦法になりました．具体的な様子は youtube をご覧ください(再生開始場所が埋め込んであります)．\nプログラムは至ってシンプルで，断片画像の揃える順番を決めて，一つの移動させる断片画像を決定したらあとはその断片画像を使って一つずつ断片画像を持って正しい場所へ持って行きます．ここで重要なのは移動経路です． 移動される断片画像の経路探索は，最短経路のうちのいくつかをランダムで選びました．選ばれた経路それぞれについて次に書いてある経路探索を行い，その中で評価が高いものを採用すしました． 移動させる断片画像の経路探索はダイクストラ法を使いました．具体的には，各断片画像をノード，交換可能な画像同士にエッジを張りとし，入れ替えたときに正しい位置に近づくか遠ざかるかでコストをつけます．ここのコストのチューニングが難しい．\n盤面の評価は単純に正しい場所へのマンハッタン距離の総和になっています．本当は2乗した値のほうがいいことに割と最近気づいたんですが，なんかうまくできませんでした．\nまた，端っこの処理のプログラムが不十分で今でもたまに止まります．その場合は手動で揃えています．\n結構効果的だったのは乱数要素を入れたことです．もちろんコストが上振れ(コストは低いほうがいい)することがありますが，下振れもします．1回回答を出力するまでに1分もかからないので，何度も探索することで，下振れスコアが出ることを願う作戦です．実は，この下振れがなければ負けてました．\nこの一連のプログラムはどれもSiv3dで作成しました．\n余談ですがパンフレット見たときにGUIの画像が掲載されている高専が結構あって驚きました．以下GUIのスクショです． 内輪向けの話になるのですが，Siv3dで，配布されたppmファイルを読み込もうとするとエラーになってハマりました．自前で用意したppmファイルは正常に読み込むのになんでかなとバイナリを比較すると，0A(改行)の次の0D(復帰)の有無の違いがあり，0Dを削除したら読み込めるようになりました．0Dは改行として扱われることがあるらしくておそらくそれが原因な気がしますが，真相は不明．僕が使用したppmビュアーでは正常に表示できていたので原因を突き止めるのに1e9+7年はかかりました．\n追記(10/11) 結構前にissueが出されていてv0.6で修正されたらしいです．\nその他 課題部門のメンバー(@shun_shobon)が問題自動生成ツールを作ってくれました．公式で配布される問題が少ないのでめっちゃ役立ちました．ありがとう．\n本番の様子 緊張で吐きそうでした．お腹痛い．緊張に弱いのどうにかならんの．\n1日目朝 テストを回してたところ早速バグが発見されました．死にものぐるいで修正しますが一部は修正しきれず．\n1日目1回戦 模擬試合で早速ビビりました． なんだこれは．\n復元後の画像 画像の周囲の背景色同士でくっついてしまいました． しかも，ほぼ水色一色みたいな断片画像もあります． 用意していた修正機能を駆使してなんとか時間内に提出できましたが，16x16でやられたらまずいと思い，後で新機能を追加することになります．\n本番の問題は全く問題なくすんなり揃いました．8x8の経路は20秒くらいで求まるので，何度も回すことで乱数ガチャをします．動画を観るとわかりますが1位通過でめちゃくちゃ喜んでます．gif画像にされそう．\n1日目夜 新機能を追加します．バグ修正する元気がないのと疲れたので素直に寝ました．\n2日目朝 #procon32のハッシュタグのついたツイートを見ると，「完徹ww」とか「50%削減」などのワードが飛び交っています．うっそだろwwwと思いながら自分のプログラムも改善しなきゃと思い，試行錯誤しますが全くスコアが伸びずちょっと絶望してました．一応準決勝の組の中で，1回戦の成績はトップですが，そんな情報はあてにならなくなります．またもやバグが見つかったので，アドホックな修正をしていきます．そういえば朝ごはん食べてねぇ．\n2日目準決勝 問題がこちらです． 面食らいます．けれどすんなり揃いました．正しく揃っていても間違ってるように見える箇所があり疑心暗鬼になりながらもaccepted 0 0(完全一致)の表示を見て一安心．乱数ガチャをし，1回目のコスト5081から，4477まで下げることができました．1位通過です．\n2日目決勝 決勝に来れて満足！4位取れたら嬉しい！の気持ちで臨みました．画像復元に急遽実装した新機能が役立ち，4位を取ることができました．\n後で試したら決勝の花火と模擬試合の画像は人の手を加えずに揃いました．画像が復元できないとその先がどうしよもないシステム，本当に怖いです．\n本音と感想 正直，もともと競技部門にあまり乗り気ではありませんでした． 理由としては，\nアルゴリコンではなくマラソン系であること 1つの問題だけで勝敗が決まってしまうのでたまたま相性が悪い問題が出ると悲しくなること 制約が緩いので難しいこと まだなんも決まっていないアルゴリズムを書いた予選資料を提出をしなければならないこと が挙げられます．そんな中，夏休み中になんとなく画像復元プログラムを作りはじめたや否や，そのままコーディングにハマり，数日後に16x16のアジサイが揃ったときの脳汁をエンジンに熱が入り，入賞するぞー！の気持ちになりました．一度書き始めるとノリノリにカタカタするんだけど，書き始めるまでが長い．\nマラソンコンテストは積極的に出て，ヒューリスティックなアプローチに慣れていきたいなと思います．たぶん．\n最後に，プロコンの関係者の皆様，観戦に来てくださった先生，応援してくださった方々，本当にありがとうございました．\n好きなお茶ランキング ところで，お茶は好きですか．私は好きです．Japanese like tea. year.\n注：価格はスーパーなどで売ってるペットボトルのお茶のことを指しています．\n1位：烏龍茶 この世で一番うまいお茶です．酔ったとき，気持ち悪いときに飲むと非常にすっきりします．あとだいたい価格がお手頃です．\n2位：緑茶の濃い茶系 体脂肪云々はよくわかりませんが，こちらも気分が悪いときに飲むとすっきりします．こちらは割高なことが多い気がします．\n3位：ほうじ茶 烏龍茶と風味の傾向が似ていて(当社比)しばしば比較されますが、私は烏龍茶派です．\n4位：抹茶入り玄米茶 刺身のお供にしたいお茶第1位．某回転寿司のお茶の味と非常に近いです．\n総括 一般に，お茶は美味しいです．\nまとめ プロコンのお供は烏龍茶一択ですね．皆さんのおすすめのお茶はなんですか．\n","date":"0001-01-01T00:00:00Z","permalink":"https://shibaken28.github.io/my-blog-4/contents/procon32/","title":"第32回全国高専プロコン競技部門参戦記と好きなお茶ランキング"}]