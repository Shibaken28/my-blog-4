---
title: "山梨大学コンピュータ理工科過去問を解く"
description: 
slug: Yamanashi_Univ
date: 2023-05-25T12:08:30+09:00
image: 
categories:
    - 情報数学
    - 編入
---

## はじめに

**解答はあくまで私が解いたものであり、正解を保証するものではありません。** また、解答に誤りがある可能性もあります。ご了承ください。

山梨大学は編入試験を含め、入試問題を公開しています。神。
[山梨大学過去問集へのリンク](https://www.yamanashi.ac.jp/admission/293)

## 令和5年度
1. 筆記試験
プログラミング、計算機アーキテクチャ、情報数学の3科目を出題し、2科目の選択解答
としました。試験時間は80分です。試験問題は別紙の通りです。
2. 口述試験
コンピュータ理工学に関する専門分野の基礎的事項、意欲、コミュニケーション力、思
考力に関する口述試験を行いました。試験時間は10分です。

### プログラミング
#### 問題1
> ソートアルゴリズムの安定性とは何かを説明しなさい。

安定性とは、同じ値を持つ要素があった場合、ソート前とソート後でそれらの順番が入れ替わるかどうかのことである。ソート前とソート後で順番が変わらない場合、安定なソートであり、変わる場合、不安定なソートである。

> 「挿入ソート」，「マージソート」，「クイックソート」の3つのアルゴリズムについて、安定かどうかを答えなさい。

- 挿入ソート：安定
    - 数字を挿入するときに、確定部分を前から順番に見ていって、挿入する数字よりも大きい数字があったら、その数字の前に挿入するようにすると安定なソートになる。逆に、確定部分を後ろから見ていき、挿入する数字よりも小さい数字があったら、その数字の後ろに挿入するようにすると不安定なソート(同じ数字は逆順)になる。
- マージソート：安定
    - 要素を分割したときに、同じ値を持つ要素があった場合、左側の要素を優先してマージするようにすると安定なソートになる。逆に、右側の要素を優先してマージするようにすると不安定なソートになる。
- クイックソート：不安定
    - ピボットの選択により、同じ値を持つ要素の順番が変わることがあるため、不安定なソートになる。

> データ数が$n$のとき、「挿入ソート」，「マージソート」，「クイックソート」の3つのアルゴリズムの平均計算量、最悪計算量、最良計算量のオーダーを答えなさい。

- 挿入ソート
    - 平均計算量：$O(n^2)$
    - 最悪計算量：$O(n^2)$
        - 逆順の配列をソートする場合
    - 最良計算量：$O(n)$
        - 整列済みの配列をソートする場合

- マージソート
    - 平均計算量：$O(n\log n)$
        - マージする際に、$n$回比較する。それを$\log n$回繰り返すので、$O(n\log n)$となる。
    - 最悪計算量：$O(n\log n)$
    - 最良計算量：$O(n\log n)$
        - 数列がどのような形をしていても、比較回数は変わらない。

- クイックソート
    - 平均計算量：$O(n\log n)$
        - 厳密な導出は結構難しいので、省略
    - 最悪計算量：$O(n^2)$
        - ピボットが常に最大値または最小値の場合
    - 最良計算量：$O(n\log n)$
        - ピボットの選択により、$n$回比較する。それを$\log n$回繰り返すので、$O(n\log n)$となる。

#### 問題2
> キー値が 0 から 15 までの整数値を取るとき，キー値の集合からハッシュ表を作成することを考えます．レコードはキー値のみで他にデータはないものとします．ハッシュ表のサイズ L を 5 とし，ハッシュ表の各要素は 0~4 の番地を持つものとします．ハッシュ関数 h(x)を h(x) = 3x mod L とします．

> ハッシュ値が 2 で衝突するような 3 つの異なるキー値を挙げなさい．

$3x \mod 5 = 2$となるような$x$を求めると、$x=4,9,14$。

> 空のハッシュ表に，(a)の 3 つのキー値を分離チェイン法（チェイン法，分離連鎖法）によって格納する様子を図示しなさい．ただし，キー値が格納されているところだけの様子が分かればよく，その他の部分は書き入れる必要はありません．

チェイン法は、結合リストを用いて同じ番地に複数のデータを入れる。(図は省略)

> 空のハッシュ表に，(a)の 3 つのキー値を開番地法（空き番地法，オープンアドレス法）によって格納する様子を図示しなさい．ただし，代替ハッシュは線形走査法（線形探査法）で求めなさい．また，キー値が格納されているところだけの様子が分かればよく，その他の部分は書き入れる必要はありません．

オープンアドレス法は、衝突が起きた場合に、ひとつ後ろの番地に格納する方法である。その場所も衝突していた場合は、さらにひとつ後ろの番地に格納する。これを繰り返す。(図は省略)

#### 問題3
> データ数を n とする時，平衡２分探索木に格納されたデータの中から，特定のデータを探索する作業の平均計算量のオーダーを答えなさい．平衡２分探索木は「どのノードの左右部分木の高さの差も 1 以下」という条件を満たす２分探索木です．

木の高さのオーザーは$O(\log n)$であるため、平均計算量のオーダーも$O(\log n)$となる。

> 次のプログラムは，２分探索木の実装の一部です．空欄（ア）～（ウ）に当てはまる，再帰を用いたコードを記述しなさい．

`p`の子のうち、高い方の高さに1を加えたものが高さである。

```c
int height(BinaryNode* p){
    // p が指しているノードを根とする木の高さを返す．
    if ( p == NULL ) return 0;
    return 1 + ( ( height(p->left) > height(p->right) ) ? height(p->left) : height(p->right) );
}
```

全てのノードについて検証をしなければならないということに注意。再帰関数に慣れていないと難しい。
あるノードの子を根とする木が平衡２分探索木のバランス条件を満たしていて、かつ、そのノードの左右部分木の高さの差が1以下であるとき、そのノードを根とする木は平衡２分探索木のバランス条件を満たしている。
```c
bool is_balanced(BinaryNode *p)
{
    // p が指しているノードを根とする木が平衡２分探索木のバランス条件を満たしているかどうかを返す．
    if (p == NULL)
        return true;
    if (is_balanced(p->left) && is_balanced(p->right))
        return (abs(height(p->left) - height(p->right)) <= 1);
    else
        return false;
}

```

> main 関数の「エ」の時点での２分探索木を図示しなさい．この２分探索木を前順（行きかけ順，preorder）ならびに中順（通りがけ順，inorder）でなぞったときのノードの訪問順序を答えなさい．

二分探索木は次のようになる
```
      5
   /     \
  2       7
 / \     /
1   3   6
     \
      4
```
- 行きかけ順(preorder): 5, 2, 1, 3, 4, 7, 6
- 通りがけ順(inorder): 1, 2, 3, 4, 5, 6, 7
- (帰りかけ順(postorder): 1, 4, 3, 2, 6, 7, 5)

### 情報数学
#### 問題1
> $𝑛$ 個の元からなる集合 $𝐴$ には $2^n$ 個の部分集合があることを数学的帰納法を用いて証明しなさい．

- $n=0$のとき。$2^0=2$である。$A$の部分集合は$\phi$の1つである。よって、$n=0$のとき成立する。
- $n=k$のとき、$A= \lbrace a_1,a_2,\cdots a_k \rbrace $の部分集合は$2^k$個あると仮定する。$n=k+1$のとき、$A= \lbrace a_1,a_2,\cdots a_k,a_{k+1} \rbrace $の部分集合は、$a_{k+1}$を含まない部分集合は$2^k$個ある。$a_{k+1}$を含む部分集合は、$a_{k+1}$を含まない部分集合に$a_{k+1}$を加えたものである。よって、$2^k+2^k=2^{k+1}$個ある。よって、$n=k+1$のときも成立する。

#### 問題2

>  2 個の赤球と 18 個の白球が入った袋から，太郎，花子がこの順で 1 回ずつ球を取り出すとき，太郎が赤球を取り出す事象を 𝑇，花子が赤球を取り出す事象を 𝐻 とします．なお，取り出した球は袋に戻さないものとします．次の問いに答えなさい．

> 太郎が赤球を取り出した後，花子も赤球を取り出す確率 𝑃(𝑇∩ 𝐻) を求めなさい．

$$
\frac{2}{20} \times \frac{1}{19} = \frac{1}{190}
$$

> 太郎が赤球を取り出す確率 𝑃(𝑇) と花子が赤球を取り出す確率 𝑃(𝐻) は等しいことを証明しなさい．

- 太郎が赤球を取り出す確率は$\frac{2}{20}=\frac{1}{10}$である。
- 花子が赤球を取り出す確率は、
    - 太郎が赤球を取り出した後、花子が赤球を取り出す確率は$\frac{2}{20} \times \frac{1}{19} = \frac{1}{190}$である。
    - 太郎が白球を取り出した後、花子が赤球を取り出す確率は$\frac{18}{20} \times \frac{2}{19} = \frac{18}{190}$である。
- よって、花子が赤球を取り出す確率は$\frac{1}{190} + \frac{18}{190} = \frac{19}{190} = \frac{1}{10}$であり、太郎が赤球を取り出す確率と等しい。

#### 問題3
{{< figure src="img/r5-1.png" >}}

1. (i)$\rightarrow$(ii)について

$|C|=2$であるから、$C$の要素を$0,1$としたときに、頂点の集合$L,R$を次のように定める。$L=\lbrace v\in V|f(v)=0 \rbrace,R=\lbrace v\in V|f(v)=1 \rbrace$とする。このとき、$L,R$は$L\cup R=V$かつ$L\cap R=\phi$である。すなわち、$L\subseteq V$かつ$R=V\setminus L$であり、各辺$(v,w)\in E$に対して、$v\in L,w\in R$または$v\in R,w\in L$である。よって、$G$は二部グラフである。

2. (ii)$\rightarrow$(i)について

$f:V\rightarrow C$を次のように定める。$f(v)=0$ if $v\in L$、$f(v)=1$ if $v\in R$とする。このとき、各辺$(v,w)\in E$に対して、$f(v)\neq f(w)$である。よって、$G$は2彩色可能である。


3. (i)$\rightarrow$(iii)について

対偶を示す。「$G$に奇数の長さの閉路が存在する$\rightarrow$$G$が2彩色不可能である」を示す。
長さが奇数の閉路が頂点$v_1,v_2,\cdots,v_{2k+1}$を通るとする。$f(v_1)=0$とする。このとき、$f(v_2)=1,f(v_3)=0,\cdots,f(v_{2k+1})=0,f(v_1)=0$となる。$f(v_1)=f(v_{2k+1})$となり、$G$は2彩色不可能である。

4. (iii)$\rightarrow$(i)について

長さが偶数の閉路の通る頂点を$v_1,v_2,\cdots,v_{2k}$とする。$f(v_1)=0$とする。このとき、$f(v_2)=1,f(v_3)=0,\cdots,f(v_{2k})=0,f(v_1)=0$となる。$f(v_1)\ne f(v_{2k})$となり、閉路は2彩色可能である。また、閉路でない頂点は明らかに2彩色可能である。よって、$G$は2彩色可能である。

## 令和4年度
1. 筆記試験
プログラミング、計算機アーキテクチャ、情報数学から２科目を選択して解答してもら
いました。解答時間は80分です。試験問題は別紙の通りです。
2. 口述試験
コンピュータ理工学に関する専門分野の基礎的事項、意欲、コミュニケーション力、思
考力を試問しました。試験時間は10分です。

### プログラミング
#### 問題1
> 素数判定のプログラムの穴埋め

```cpp
bool isPrimeA(const int N)｛
    for(int i=2; i*i<=N; ++i) {
        if(N%i==0) return false;
    ｝
    return true;
｝

bool isPrimeB(const int N)｛
    for(int i=2; i<N; ++i) {
        if(N%i==0) return false;
    ｝
    return true;
```

> `isPrimeA`と`isPrimeB`について、それぞれのプログラムの最悪計算量を求めなさい。

入力が素数であった場合に計算量が最悪となる。

- `isPrimeA`の最悪計算量は$O(\sqrt{N})$である。
- `isPrimeB`の最悪計算量は$O(N)$である。

`isPrimeA`の方が効率が良い。

#### 問題2
> 部分和問題を解くプログラムについて、以下の問いに答えなさい。

```cpp
# include <iostream>
using namespace std;

bool isSubsetSum(const int a[], const int N, const int W){
    for(int bit = 0; bit < (1<<N); ++bit){
        int sum = 0;
        for(int i = 0; i < N; ++i){
            if(bit & (1<<i)) sum += a[i];
        }
        if(sum == W) return true;
    }
    return false;
}

int main(){
    const int N = 4, W = 19;
    const int a[] = {3,5,7,9};

    if(isSubsetSum(a,N,W)) cout << "Yes" << endl;
    else cout << "No" << endl;
    
    return 0;
}
```

> 関数boolisSubsetSum( )内の//(A)の行の｢bit&(1くくi)｣は,この部分和問題を解くためのどのような処理をおこなっているか.この中の｢&｣および｢くく｣の機能の説明を含めて, 150字程度で説明しなさい．

`<<`は左シフト演算子、`&`はAND演算子である。`(1<<i)`は下から`i`番目のビット(一番下を`0`番目とする)のみが`1`である数を表し、`bit & (1<<i)`は`bit`の下から`i`番目のビットが`1`であるかどうかを判定する。`i`番目のビットが立っているときに、`a[i]`を部分和の用いるとすると、`bit`が$0$から$2^N-1$まで変化することで、全ての部分和を求めることができる。

> このプログラムの最悪時間計算量を求めなさい．

部分和問題の答えがNoだったときに、`for`文が`2^N`回実行される。よって、計算量は$O(2^N)$である。

> このソースコードのアルゴリズムの時間計算量よりも効率の良い、$O(NW)$の時間計算量のアルゴリズムを説明しなさい。

動的計画法を説明する。

`bool`型の二次元配列`dp`を用意し、`dp[i][j]`の値を「`i`番目($a_0,a_1,\cdots a_{i-1}$)までの数からいくつかを選んで和を`j`にすることができるか」の判定問題の答えとする。
`dp[0][0]`は`true`とする。`dp[i][j]`の値は、`dp[i-1][j]`の値と`dp[i-1][j-a[i]]`の値を用いて、`dp[i][j] = dp[i-1][j] || dp[i-1][j-a[i]]`として求めることができる。`dp[N][W]`の値が`true`であれば、部分和問題の答えはYesである。

#### 問題3
> 都県名の一覧を処理するソースコードについて、答えなさい。

{{< figure src="img/r4-1.png" >}}

> このソースコードをコンパイルして実行したときの,標準出力への出力をすべて書き出しなさい．

この実装では、リスト構造を用いている。
`func1`では`v`の`next`を`p`の`next`に変更し、`p`の`next`を`v`にしている。すなわち、`p`の次の要素を`v`に変更している。

`func2`では、`n`の次が指しているポインタを`cur`とし、`cur`の`pref`を表示している。`cur`は`cur`の`next`に変更し、`cur`の`next`が`n`であれば終了する。

`func3`では、`n`以外のリストの要素を全削除している。

以上のことを踏まえると、
```
Tokyo->
Kanagawa->Tokyo->
Saitama->Kanagawa->Tokyo->
Nagano->Saitama->Kanagawa->Tokyo->
Nagano->Yamanashi->Saitama->Kanagawa->Tokyo->
```
となる。

> main( )関数内の｢//(A)｣の行で呼び出されるfunc1( )について,このときに渡される実引数に基づく実行の様子を説明しなさい.必要であれば,図を用いてかまわない．

略

> このソースコードで都県名の一覧に用いられているデータ構造の代わりに配列の使用を考える.設問(b)の処理においては,時間計算量の観点から,配列の方が効率が悪い.その理由を150字程度で説明しなさい．

このソースコードのアルゴリズムでは、どの場所に挿入するのも$O(1)$で行うことができるが、配列は挿入する場合、挿入する場所以降の要素を全てずらす必要があるため、最悪で$O(N)$の計算量がかかる。

### 情報数学
#### 問題1
> 2種の記号AとBの発生確率がそれぞれ$0.8$と$0.2$である記憶のない情報源Sを考える.このとき,以下の設問に答えなさい.計算には $\log_2 10=3.322$を用いてよい.また,答えは小数点以下第4位を四捨五入して表しなさい．

> $S$のエントロピーを求めなさい．

$$
H(S) = -\sum p_i \log_2 p_i = -0.8 \log_2 0.8 - 0.2 \log_2 0.2 \simeq 0.722
$$

$\log 0.2 = \log (2/10) = \log 2 - \log 10 = -2.322 $、$\log 0.8 = \log (8/10) = \log 8 - \log 10 = -0.322$であることに注意。

> $S$を2次に拡大してからハフマン符号化した場合に生成される符号を示しなさい。また、1情報源記号あたりの平均符号長を求めなさい。(b)

$S$を$2$次に拡大し、ハフマン符号化すると、以下のようになる($AB$と$BA$は逆でも良い)。

|情報源|AA|AB|BA|BB|
|---|---|---|---|---|
|発生確率|0.64|0.16|0.16|0.04|
|符号|0|10|110|111|

また、1情報源記号あたりの平均符号長は、$0.64\times 1 + 0.16\times 2 + 0.16\times 3 + 0.04\times 3 = 1.56$となる。

> AとBの発生確率が偏っているので,ランレングス符号化を行う.ただし,Aは長さ4までのランを考え,Bは長さ1のランのみを考える.すなわち,下記の5種類のランを考える.これをハフマン符号化し,生成される符号を示しなさい.また, 1情報源記号当たりの平均符号長を求めなさい． (c)

|情報源|AAAA|AAAB|AAB|AB|B|
|---|---|---|---|---|---|
|発生確率|0.4096|0.1024|0.128|0.16|0.2|
|符号|0|110|111|100|101|

1情報源記号あたりの平均符号長は、$0.4096\times 1 + 0.1024\times 3 + 0.128\times 3 + 0.16\times 3 + 0.2\times 3 = 2.08$となる。

> (c)の符号化は(b)の符号化に比べて,どれだけ符号化の効率(1情報源記号当たりの平均符号長に対するエントロピーの比)が改善されているか答えなさい．

$(b)$のエントロピーは$1.444$、$c$のエントロピーは$2.468$である。

エントロピーは「一つの情報源に対してどれほどの情報量があるか」を示す指標であるから、エントロピーを平均符号長で割ることで、一つの記号あたりの情報量を示すことができる。
- $b$の場合、$1.444/1.56 = 0.925$
- $c$の場合、$2.468/2.08 = 1.186$

これらの差である$0.261$bit(binary unit)分だけ、符号化の効率が改善されている。


#### 問題2
固有値の問題。詳細は省略する。
$$
A=\begin{pmatrix}
2 & 1 & -1 \\\\
1 & 0 & -1 \\\\
1 & -1& 0
\end{pmatrix}
$$

$A$の固有値と固有ベクトルは、
$$
\lambda_1 = 1, \lambda_2 = -1, \lambda_3 = 2
$$
$$
v_1 = (1,0,1)^T, v_2 = (0,1,1)^T, v_3 = (3,1,1)^T
$$
である。

$$
x = (-1,-3,-1)^T = 2v_1-2v_2-v_3
$$
と表されるので、
$$
A^n x = 2 \cdot 1^n v_1 - 2 \cdot (-1)^n v_2 - 2^n v_3
$$
よって、
$$
A^n x = \begin{pmatrix}
2-3\cdot 2^n \\\\
-2\cdot (-1)^n - 2^n \\\\
2 - 2 \cdot(-1)^n - 2^n
\end{pmatrix}
$$

## 令和3年度
### プログラミング
#### 問題1
なんと、アルゴリズムではなくコンパイルの仕組みが出ています。？？？？？？？？？

{{< figure src="img/r3-1.jpg" >}}

- (ア)：プリプロセス
    - マクロの展開やヘッダファイルなどを処理する。
- (イ)：構文解析
    - 字句解析では、`if`や`else`やセミコロン、括弧などを解析する。
    - 構文解析では、字句解析をもとに構文構造をまとめる。
- (ウ)：アセンブリファイル
- (エ)：オブジェクトファイル
- (オ)：ライブラリファイル

実行ファイルの実行速度を高速化するために、コンパイラは様々な最適化を行う。
- 関数のインライン展開：関数呼び出しを関数の中身に置き換える。
- 定数の畳み込み：定数同士の計算を、計算結果に置き換える。
- ループの展開(アンローリング)：ループ処理の内容を展開する。
- 無用命令の削除：冗長で無用な命令を削除する。
- 定数伝搬：変数を定数で置き換える。
- 共通部分式の削除：同じ計算を複数回行う場合、一度計算した結果を変数に格納しておき、再利用する。
    - 例えば、`a = b + c; d = b + c;`というコードがあった場合、`b + c`を一度計算しておき、`a = b + c; d = a;`とする。
- ループ内不変式の移動：ループ内で変化しない変数の計算をループの外に移動する。


#### 問題2
> 二分木をC言語を用いて実装する。

- 着目ノードの左の部分技のすべてのノードの値は、着目ノードの値より小さく
- 着目ノードの右の部分木のすべてのノードの値は、着目ノードの値より大きい
- その声質から、木の最も右のノードが木に保持される値の最大値、ミットも左のノードの値が最小値である。

- 入力データが`1,2,3,4,5,6,7,8`のとき、`1`が根で、右の子が`2`、`2`の右の子が`3`、`3`の右の子が`4`、`4`の右の子が`5`、`5`の右の子が`6`、`6`の右の子が`7`、`7`の右の子が`8`となる。
- 入力データが`4,6,2,8,1,5,3,7,-1`のとき
```
    4
   / \
  2   6
 / \ / \
1  3 5  8
       /
      7
```

- ある整数がノードに含まれるかどうかの処理の計算量は、木の高さに依存する。
    - 最良の場合、木の高さが$O(\log n)$であるから、$O(\log n)$
    - 最悪の場合、木の高さが$O(n)$であるから、$O(n)$

#### 問題3
 > 大きさ3の配列`v`を入力とし、次の条件を満たすような`v`の要素を返す。
 > - 一つ以上の他の要素よりも大きいかまたは等しい。
 > - 一つ以上の他の要素よりも小さいかまたは等しい。

要するに、中央値を求めれば良い。中央値を求める問題を10問も解かされる謎の問題。
|v[0]|v[1]|v[2]|中央値|
|---|---|---|---|
|3|5|7|5|
|3|7|5|5|
|5|3|7|5|
|3|5|5|5|
|5|5|5|5|
|3|0|1|1|
|0|0|0|0|
|3|-1|0|0|
|-2|-3|-4|-3|
|-2|0|-2|-2|


> CかC++で実装せよ。

いくつか方法はある。

- バブルソートのようにスワップしながらソートし、真ん中の値を返す。
- 各v[i]について、それぞれ条件を満たすかを調べる。
- 最大値と最小値を求め、v[0]+v[1]+v[2]から最大値と最小値を引く。

一番実装が楽そうなのは3番目の方法。変な方法ではあるが、特に指定されていないので問題ないと思われる。
```cpp
int func(int v[3]) {
    int max = v[0];
    int min = v[0];
    int sum = 0;
    for (int i = 1; i < 3; i++) {
        if (v[i] > max) {
            max = v[i];
        }
        if (v[i] < min) {
            min = v[i];
        }
        sum += v[i];
    }
    return sum - max - min;
}
```

### 情報数学
問題1から3のうち、2問選択して解答する。

#### 問題1
> $r(n+3)$と$r(n)$の差が$3$の倍数であることを証明せよ。
> $$
> r(n) = \sum_{i=1}^{m} d_i \quad (d_iは10進数表記でi番目の桁の数字を表し、mはnの桁数)
> $$

方針として、$n$を$3$で割ったあまりと、各位の数の和を$3$で割ったあまりが等しいことを証明すれば良い。

$$
\begin{align}
n &\equiv \sum_{i=1}^{m} 10^{i-1}d_i \pmod 3 \\\\
&\equiv \sum_{i=1}^{m} (3\times 333\cdots 3 + 1)^{i-1}d_i \pmod 3 \\\\
&\equiv \sum_{i=1}^{m} 1^{i-1}d_i \pmod 3 \\\\
&\equiv \sum_{i=1}^{m} d_i \pmod 3 \\\\
&\equiv r(n) \pmod 3
\end{align}
$$

よって、$n \equiv r(n) \pmod 3$、つまり$n$を$3$で割ったあまりと、各位の数の和を$3$で割ったあまりが等しい。
$n$を$3$で割ったあまりを$a$と置けば、$n = 3k+a$と整数$k$を用いて表せる。
$n+3=3k+a+3=3(k+1)+a$であるから、$n+3$を$3$で割ったあまりも$a$である。
したがって、$r(n+3) - r(n) \equiv a - a \equiv 0 \pmod 3$である。

#### 問題2

> ある会社は、A,B,C社から同じ製品を2:3:5の比率で購入している。A,B,C社の製品にはそれぞれ2.5%,1.5%,1.0%の割合で不良品が含まれている。

> (a) 購入した製品の中から1つを選んだとき、不良品である確率を求めよ。

- A社の製品を選び、かつ不良品である確率は$\frac{2}{10}\times \frac{25}{1000} = \frac{1}{200}$
- B社の製品を選び、かつ不良品である確率は$\frac{3}{10}\times \frac{15}{1000} = \frac{9}{2000}$
- C社の製品を選び、かつ不良品である確率は$\frac{5}{10}\times \frac{10}{1000} = \frac{1}{200}$
- したがって、不良品である確率は$\frac{1}{200} + \frac{9}{2000} + \frac{1}{200} = \frac{29}{2000}$

> (b) 購入した製品の中から1つを選んだら不良品であった。この不良品が、A社、B社、C社の製品である確率をそれぞれ求めよ。

ベイズの定理を用いる(個人的に、特にベイズの定理という名前を認識して使う必要はないと思う)。
- A社の製品である確率は$\frac{1}{200} \div \frac{29}{2000} = \frac{10}{29}$
- B社の製品である確率は$\frac{9}{2000} \div \frac{29}{2000} = \frac{9}{29}$
- C社の製品である確率は$\frac{1}{200} \div \frac{29}{2000} = \frac{10}{29}$
    - (ここで、$\frac{10}{29} + \frac{9}{29} + \frac{10}{29} = \frac{29}{29} = 1$であることを確認できる。)

#### 問題3
固有値に関する問題。詳細は省略する。
$$
A=\begin{pmatrix}
3 & -2 & -1 \\\\
0 & 1 & -1 \\\\
2 & 1 & 5 
\end{pmatrix}
$$

> (a) 行列$A$の行列式を求めよ。

$24$

> (b) 行列$A$の固有値を求めよ。

$\lambda_1 = 2, \lambda_2 = 3, \lambda_3 = 4$
$a_1= (-1,-1,1)^T, a_2 = (-3,-2,4)^T, a_3 = (-1,-1,3)^T$

> (c) 対角化する行列$P$とその逆行列$P^{-1}$を求めよ。

$$
P = \begin{pmatrix}
-1 & -3 & -1 \\\\
-1 & -2 & -1 \\\\
1 & 4 & 3
\end{pmatrix}
$$

$$
P^{-1} = \frac{1}{24}\begin{pmatrix}
6 & 9 & 3 \\\\
-2 & 17 & 3 \\\\
-2 & -7 & 3
\end{pmatrix}
$$

このとき、$P^{-1}AP = \begin{pmatrix}
2 & 0 & 0 \\\\
0 & 3 & 0 \\\\
0 & 0 & 4
\end{pmatrix}$
である。

## 令和2年度
### プログラミング
#### 問題1
{{< figure src="img/r2-1.jpg" >}}
> 二分木について、「親から子へ」「左から右へ」の順番を原則に答えよ
> (a) 深さ優先探索、幅優先探索をしたとき、訪問する順番を答えよ。

- 深さ優先探索: A,B,D,E,H,I,C,F,G,J
- 幅優先探索: A,B,C,D,E,F,G,H,I,J

> (b) in-order, pre-order, post-orderで木を巡回したとき、訪問する順番を答えよ。

- pre-order(行きがけ順、前順): A,B,D,E,H,I,C,F,G,J
- in-order(通りがけ順、中順): D,B,H,E,I,A,F,C,J,G
- post-order(帰りがけ順、後順): D,H,I,E,B,F,J,G,C,A

{{< figure src="img/r2-2.jpg" >}}

- stackを使っているので、右を先に探索するためには、**左、右の順番でpush**する必要がある。

#### 問題2
> `d[]`には`-10000`から`10000`までの整数が格納される。`d[]`の最大値と最小値を求めるプログラムを作成する。

```c
int d[100], minimum, maximum, i;
// dに値を格納する処理
mininmum = 10000; maximum = -10000;
for (i = 0;i < 100;i++){
    if (d[i] > maximum) maximum = d[i];
    else if (d[i] < minimum) minimum = d[i];
}
```
> (a) 上記のプログラムでは最大値と最小値が正しく求められない場合がある。その場合を示せ。

`else`が使われているため、`maximum`と`minimum`が同時に更新されることがなくなっている。
すなわち、`d[0],d[1],d[2],...,d[99]`が常に増え続けるよう(ただし`d[0]!=-10000`)な入力に対しては`minimum`が更新されず、`10000`のままとなってしまう。

> (b) 上記のプログラムを修正し、最大値と最小値を正しく求めるプログラムを作成せよ。

単に、`else if`を`if`に変えるだけで良い。

> (c) `d[]`の中に最小あるいは最大を取る値が複数個含まれていた場合に、最小値や最大値の値がそれぞれ何個含まれているかを求めるプログラムを作成せよ。

ループを$2$回回せば良い。

```c
int d[100], minimum, maximum, i, count_min, count_max;
// dに値を格納する処理
mininmum = 10000; maximum = -10000;
for(i = 0;i < 100;i++){
    if (d[i] > maximum) maximum = d[i];
    if (d[i] < minimum) minimum = d[i];
}

count_min = 0; count_max = 0;
for(i = 0;i < 100;i++){
    if (d[i] == maximum) count_max++;
    if (d[i] == minimum) count_min++;
}
```

#### 問題3
> (a) 値がコメントのようになるように(1),(2),(3),(4)を埋めよ。
```c
void rotate(int *x, int *y, int *z){
    int tmp;
    // (1)
    // (2)
    // (3)
    // (4)
}

int main(void){
    int a=7, b=61, c=199;
    // a=7, b=61, c=199
    rotate(&a, &b, &c);
    // a=61, b=199, c=7
    rotate(&a, &b, &c);
    // a=199, b=7, c=61
}
```

`a,b,c`が`b,c,a`の順番になれば良い。

```c
int tmp;
tmp = *x;
*x = *y;
*y = *z;
*z = tmp;
```

> (b) 関数定義において引数をポインタとする実装方法の特徴と有効な使い方について簡単に説明せよ。また、この実装方法の危険性についても説明せよ。

ポインタを用いると、値をコピーせずに、関数内で値を変更することができる。また、値をコピーする必要がないため、メモリの節約になる。ただし、ポインタはアドレスを指すため、誤ってアドレスの変更やアドレスの指す値の変更をしてしまうと、予期せぬ動作をする可能性がある。

### 情報数学
#### 問題1
> 次の3つの命題を仮定したとき、これらの命題から得られる結論をすべて求めよ。
> - $P_1$: ソクラテスは、人である。
> - $P_2$: 人はいつか死ぬ。
> - $P_3$: ベニクラゲは死なない。

整理すると、
- ソクラテス$\rightarrow$人間
- 人間$\rightarrow$死ぬ
- ベニクラゲ$\rightarrow$死なない

また、これらの対偶も成り立つので、

- 人間ではない$\rightarrow$ソクラテスではない
- 死なない$\rightarrow$人間ではない
- 死ぬ$\rightarrow$ベニクラゲではない

これらを組み合わせると、
```
ソクラテス -> 人間 -> 死ぬ -> ベニクラゲではない
ベニクラゲ -> 死なない -> 人間ではない -> ソクラテスではない
```
よって、$P_1,P_2,P_3$の他に、
- ソクラテスは死ぬ
- ソクラテスはベニクラゲではない
- 人間はベニクラゲではない
- ベニクラゲは人間ではない
- ベニクラゲはソクラテスではない
- 死なないならばソクラテスではない

の6つの結論が得られる。

#### 問題2
> $R$を集合$A$上の同値関係とする。各要素$a\in A$に対して$a$と同値関係にある要素の集合を同類値と呼び、$[a]$と表す。すなわち$[a]= \lbrace  x|(a,x)\in R \rbrace$である。このとき、次を証明せよ。

同値関係の定義は、関係が反射律、対称律、推移律を満たすことである。


> (a) $A$の各要素$a\in A$に対して、$a\in[a]$である。

同値類は反射律を満たすから、$(a,a)\in R$である。よって、$a\in[a]$である。

> (b) $[a]=[b]$のとき、かつこのときに限り、$(a,b)\in R$である。

$\rightarrow$の証明：
(a)の結論より、$ a \in [a]$である。また、$[a]=[b]$であるので、$a \in [b]$である。よって、$(a,b)\in R$である。

$\leftarrow$の証明：
$R$は同値関係であるため、$(a,b)\in R$のとき$a,b$は同値である。よって、$[a]=[b]$である。

> (c) $[a]\ne [b]$ならば、$[a]$と$[b]$は互いに素である。

対偶を示す。$a,b$が互いに素ではないとき、$a,b$は同値である。よって、(b)より$[a]=[b]$である。

#### 問題3

固有値に関する問題。詳細は省略する。
$$
A=\begin{pmatrix}
0 & 1 & 2 \\\\
-4 & 1 & 4 \\\\
-5 & 1 & 7 
\end{pmatrix}
$$

行列式は$10$

固有値と固有ベクトルは、$1$に対して$(1,-1,1)^T$、$2$に対して$(1,0,1)^T$、$5$に対して$(1,1,2)^T$である。


## 平成31年度
### プログラミング
#### 問題1
> $n$子の整数より構成される配列$x$から整数$t$を探索する関数`search`を作る。

```c
int search(int t, int* x, int n){
    int lower, upper, middle;
    lower = 0;
    upper = n01;
    while(lower <= upper){
        middle = (lower + upper) /2;
        if(x[middle] < t)
            lower = middle; //(1)
        else if (t < x[middle])
            upper = middle; //(2)
        else
            return middle;
    }
    return -1;
}
```

> (a)このプログラムが正しく動作するのに、`x`は昇順と降順どちらである必要があるか(ただし、狭義単調増加、狭義単調減少を指す)。

プログラムでは、二分探索を行っている。`x[middle]`が`t`より小さいときに、下限`lower`が`middle`におきかわっている。`middle`より前を見る必要がない、ということだから、`x`は昇順である必要があることがわかる。

> (b)入力によって、プログラムが停止しない場合がある。例えば、`x={1,2,3}`で、`t=3`のときに停止しない。プログラム中の`(1),(2)`の部分を変更して、このような場合にも停止するようにせよ。

`lower = middle + 1`、`upper = middle - 1`とすればよい。(要検証)

> (c)`x`が(a)とは逆の順序である場合に、`(1),(2)`の部分を修正してプログラムが動作するようにせよ。

`(b)`で、`(1)`と`(2)`を逆にすればよい。

> (d) このプログラムの計算量が$O(\log n)$になることを説明せよ。

一回で半分になるので、ループはおよそ$\log_2 n$回実行される。

#### 問題2
> (a) ヒープに関する説明の穴埋め問題

- ヒープは、要素の「あつまり」を表す ?型のデータ構造である。抽象的機能として、要素の並びを保持し、挿入と削除が可能な優先度付きキューの実装の一つと位置づけられる。一般に以下の2つの性質を持つ2分木と定義され、性質1より最小要素は必ず根頂点に格納される。
- 性質1：略
- 性質2：略

> (b)`n`子の整数より構成される配列`x`に対し、以下の<対応付け規則>から構成される2分木を`x`の2分木と呼ぶ。配列`x={20,18,13,19,24,15,28,40}`(この順番どおりに格納されている)の2分木を図示しなさい。
> - 規則1:x[0]を根頂点とする。
> - 規則2:$0\leq i \leq (n-1)/2$を満たす整数$i$に対し、`x[2*i+1]`を`x[i]`の左の子とする。
> - 規則3:$0\leq i \leq (n-2)/2$を満たす整数$i$に対し、`x[2*i+2]`を`x[i]`の右の子とする。

具体例を考えれば良い。
- `x[0]`が根である。
- `x[0]`の左の子が`x[1]`で、右の子は`x[2]`である。
- `x[1]`の左の子が`x[3]`で、右の子は`x[4]`である。
- `x[2]`の左の子が`x[5]`で、右の子は`x[6]`である。
- 以下同様

これは単に、上から下へ、左から右に、順番に並べたものと一致する。
```
          20
        /    \
      18      13
     /  \    /  \
   19   24  15  28
  /
40
```

> (c) 次ページのC言語のプログラムは、配列`x`の各要素を移動する関数`shift`を表している。(b)の配列`x={20,18,13,19,24,15,28,40}`について、`shift(0,x,8)`実行したときの`x`を答えなさい。

```c
void shift(int i, int* x, int n){
    int parent, child, temp;
    parent = i;
    child = 2*parent + 1;
    while(child < n){
        if(x[child] < x[parent]){
            temp = x[child];
            x[child] = x[parent];
            x[parent] = temp;
            parent = child;
            child = 2*parent + 1;
        }else{
            break;
        }
    }
}
```

- 初期は`x={20,18,13,19,24,15,28,40}`で`parent = 0, child = 1`
- `x[1] < x[0]`なので、`x={18,20,13,19,24,15,28,40}`で`parent = 1, child = 3`
- `x[3] < x[1]`なので、`x={18,19,13,20,24,15,28,40}`で`parent = 3, child = 7`
- `x[7] < x[3]`なので、変化はなく`x={18,19,13,20,24,15,28,40}`で終了

- (d) (c)の結果の`x`を、二分木をヒープにするには、プログラムにどのような処理を追加すればよいか。

任意の配列`x`ではなく、少なくとも(c)で回答した`x`についてヒープになれば良い。
余談ではあるが、任意の`x`についてヒープにする必要があると勘違いをし、非常に悩んだ。

```c
void shift(int i, int* x, int n){
    int parent, child, temp;
    parent = i;
    child = 2*parent + 1;
    while(child < n){
        if(child+1<n)if(x[child] > x[child + 1])child ++;
        if(x[child] < x[parent]){
            temp = x[child];
            x[child] = x[parent];
            x[parent] = temp;
            parent = child;
            child = 2*parent + 1;
        }else{
            break;
        }
    }
}
```

